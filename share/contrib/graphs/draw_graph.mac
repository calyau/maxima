/*
  
  GRAPHS - graph theory package for Maxima
  Copyright (C) 2007 Andrej Vodopivec <andrej.vodopivec@gmail.com>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or	 
  (at your option) any later version. 

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

*/


load("stringproc")$
load("numericalio")$
load("draw")$

gp_file_out : "out.txt"$
gp_file_in : "in.txt"$

circular_positions(G) := block(
  [v_list, numer : true, n : graph_size(G)],
  v_list : vertices(G),
  makelist([v_list[i+1], [2+cos(2*i*%pi/n), 2+sin(2*i*%pi/n)]], i, 0, graph_size(G)-1)
)$

write_file(G) := block(
  [display2d:false, file, e],
  file : openw(gp_file_in),
  printf(file, "graph {"),
  for e in edges(G) do (
    printf(file, "~s -- ~s~%", e[1], e[2])
  ),
  printf(file, "}"),
  close(file),
  'done
)$

read_file() := block(
  [lst : read_list(gp_file_out),
   v_pos : [], v, x, y],
  while length(lst)>0 do (
    v : first(lst), lst : rest(lst),
    if v = 'node then (
      v : first(lst), lst : rest(lst),
      x : first(lst), lst : rest(lst),
      y : first(lst), lst : rest(lst),
      v_pos : cons([v, [x, y]], v_pos)
    )
  ),
  v_pos
)$

graphviz_positions(G, program) := block(
  [command],
  write_file(G),
  if program = 'dot then
    command : concat("dot -Tplain \"", gp_file_in, "\" > \"", gp_file_out, "\"")
  else if program = 'twopi then
    command : concat("twopi -Tplain \"", gp_file_in, "\" > \"", gp_file_out, "\"")
  else if program = 'circo then
    command : concat("circo -Tplain \"", gp_file_in, "\" > \"", gp_file_out, "\"")
  else if program = 'fdp then
    command : concat("fdp -Tplain \"", gp_file_in, "\" > \"", gp_file_out, "\"")
  else
    command : concat("neato -Tplain \"", gp_file_in, "\" > \"", gp_file_out, "\""),
  system(command),
  read_file()
)$


/* taken from augmented_lagrangian */
with_parameters ([L]) ::= buildq (
  [a : subst (":", "=",  ev (L [1])), e : rest (L)],
  block (a, splice (e))
  );

draw_graph(G, [options]) := block(
  [
   show_id : false, show_label : false, show_weight : false,
   color : 'red, text_color : 'blue, vertex_type : 5,
   head_length : 0.03, head_angle : 20,
   vertices:[], edges:[], v_pos, vertex_labels:[], edge_weights:[],
   program : 'neato, directed : false,
   command, x_max, y_max, gp_options, terminal : 'screen, file_name : "graph",
   gp_file_in : temp_filename(gp_file_in), gp_file_out : temp_filename(gp_file_out)
  ],

  if not(is_graph(G)) and not(is_digraph(G)) then error("First argument to `draw_graph' is not a graph:", G),

  if get('wxmaxima, 'version)#false then terminal : 'wxmaxima,
  if is_digraph(G) then directed : true,
  
  with_parameters(options,
    
    if member(program, ['neato, 'dot, 'twopi, 'fdp, 'circo]) then
      v_pos : graphviz_positions(G, program)
    else
      v_pos : circular_positions(G),
    
    x_max : lmax(map(lambda([u], abs(part(u, 2, 1))), v_pos)),
    y_max : lmax(map(lambda([u], abs(part(u, 2, 2))), v_pos)),
    v_pos : map(
      lambda([u], [part(u, 1), [part(u, 2, 1)/x_max, part(u, 2, 2)/y_max]]),
      v_pos
    ),
    
    for e in edges(G) do (
      if directed=true then block(
        [p1 : assoc(e[1], v_pos), p2 : assoc(e[2], v_pos)],
        edges : cons(vector(p1, p2-p1), edges)
      )
      else
        edges : cons(points([assoc(e[1], v_pos), assoc(e[2], v_pos)]), edges)
    ),

    vertices : [points(map(second, v_pos))],
    if show_id=true then (
      for v in vertices(G) do block(
        [p : assoc(v, v_pos)],
        vertex_labels : cons(label(concat("  ", v), p[1], p[2]), vertex_labels)
      )
    )
    else if show_label=true then (
      for v in vertices(G) do block(
        [p : assoc(v, v_pos)],
        vertex_labels : cons(label(concat("  ", get_vertex_label(v, G)), p[1], p[2]), vertex_labels)
      )
    ),

    if show_weight=true then (
      for e in edges(G) do block(
        [p1 : assoc(e[1], v_pos), p2 : assoc(e[2], v_pos)],
        edge_weights : cons(label(concat(get_edge_weight(e, G)), (2*p1[1]+p2[1])/3, (2*p1[2]+p2[2])/3), edge_weights)
      )
    ),                           
    
    if terminal='wxmaxima then command : wxdraw2d else command : draw2d,
    
    if terminal#'wxmaxima then
      gp_options : ['terminal = terminal, 'file_name = file_name]
    else gp_options : [],
    
    apply(command, append(
       [
        'points_joined = false,
        'point_size = 1,
        'point_type = vertex_type,
        'color = color
       ],
        vertices,
       [
        'point_type = 0,
        'line_type = 'solid,
        'points_joined = true,
        'head_length = head_length,
        'head_angle = head_angle
       ],
        edges,
       [
        'color = text_color,
        'label_alignment = 'left
       ],
        vertex_labels,
        edge_weights,
       [
        'axis_top = false,
        'axis_bottom = false,
        'axis_left = false,
        'axis_right = false,
        'ytics = false,
        'xtics = false
       ],
        gp_options)
      )
    ),
    'done
 )$
