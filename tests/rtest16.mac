kill (all);
done;

/* Tests from Bug 1036900 */
/* These bugs were fixed in limit.lisp rev 1.7, 2004/10/04 */
limit(7^n/8^n,n,inf);
0$
limit(7^(n^2)/8^n,n,inf);
inf$
limit((10^n+9^n+8^n)^(1/n),n,inf);
10$
/* maxima currently (2004/10/05) gets this wrong */
limit(4^n/2^(2*n),n,inf);
1$
/* Test from Bug 1052308 */
/* Fixed in limit.lisp rev 1.11 */
assume(equal(zz,0));
[equal(zz,0)]$
limit(erf(nn*zz), nn, inf);
0$
limit(tanh(nn*zz), nn, inf);
0$

/* From A. Reiner.  Fixed in buildq.lisp rev. 1.4.
   Exposed a bug caused by the dynamical scope of VARLIST. */
buildq([foo:sin(baz+bar)],1);
1$

buildq([foo:[sin(baz+bar),sin(baz-bar)]],+splice(foo));
sin(baz+bar)+sin(baz-bar)$

/* Fixed in series.lisp rev 1.5, 04 Feb 2004.  
   First case returned second result */
powerseries(1/sqrt(1+x),x,0);
2*'sum(x^i1/beta(1/2-i1,i1+1),i1,0,inf);
powerseries(sqrt(1+x),x,0);
2*('sum(x^i2/beta(3/2-i2,i2+1),i2,0,inf))/3;

/* sf bug 1730044 - powerseries(1+x^n,x,0) wrong */
powerseries(1+x^n, x, 0);
('sum(x^(i3*n)/beta(2-i3,i3+1),i3,0,inf))/2;

(declare(n, integer), powerseries(1/(1+x^n), x, 0));
'sum((-1)^i4*x^(i4*n),i4,0,inf);


/* Examples from SF bug report [ 1722156 ] powerseries((x+1)/(1-2*x^2), x, 0);
 * tnx Dan Gildea
 */

gensumnum : 0;
0;

/* two simple roots */
powerseries((1)/((1-2*x)*(1-3*x)), x, 0);
'sum((3^(i1+1)+(-2*2^i1))*x^i1,i1,0,inf);

/* fibonacci */
powerseries((1)/(1-x-x^2), x, 0);
-'sum((-2*(sqrt(5)-1)^(-i2-1)*2^i2/sqrt(5)
 -2*(sqrt(5)+1)^(-i2-1)*(-2)^i2/sqrt(5))
 *x^i2,i2,0,inf);

/* 1 1 2 2 4 4 8 8 */
powerseries((1+x)/(1-2*x^2), x, 0);
'sum( (-1*(1/-(1/sqrt(2)))*(1/sqrt(2)-1)*(1/-(4/sqrt(2)))*(1/-(1/sqrt(2)))^i3 + 
      -1*(1/(1/sqrt(2)))*(-(1/sqrt(2))-1)*(1/(4/sqrt(2)))*(1/(1/sqrt(2)))^i3 ) * x^i3,i3,0,inf);

/* multiple root */
powerseries((1+x)/(1-x)^2, x, 0);
'sum(2*(i4+1)*x^i4-x^i4,i4,0,inf);

/* numerator higher order poly than denom */
powerseries((1+x^3)/(1-x-x^2), x, 0);
-2*x
 *'sum((-2*(sqrt(5)-1)^(-i5-1)*2^i5/sqrt(5)
   -2*(sqrt(5)+1)^(-i5-1)*(-2)^i5/sqrt(5))
   *x^i5,i5,0,inf)
  -x+1;

/* zero root in denom */
powerseries((1)/((1-2*x)*(x)), x, 0);
('sum(2^i6*x^i6,i6,0,inf))/x;

/* one simple and one repeated root in denom */
powerseries((1+x+x^2)/((1-2*x)*(1+x)^2), x, 0);
'sum(7*2^i7*x^i7/9+(i7+1)*(-1)^i7*x^i7/3-(-1)^i7*x^i7/9,i7,0,inf);

/* gcd of exps is two */
powerseries((1-x^2)/(1-4*x^2+x^4), x, 0);
'sum((-1*(1/(2-sqrt(3)))*(sqrt(3)-1)*(1/(2*(2-sqrt(3))-4))*(1/(2-sqrt(3)))^i8 +
      -1*(1/(sqrt(3)+2))*(-sqrt(3)-1)*(1/(2*(sqrt(3)+2)-4))*(1/(sqrt(3)+2))^i8 )*x^(2*i8), 
      i8, 0, inf);

/* Bug 1281737, fixed in limit.lisp rev 1.15 */
limit(atan(x)/(1/exp(1)-exp(-(1+x)^2)),x,inf,plus);
%e*%pi/2;

/* Verify that extended functionality of rhs/lhs works as advertised */

(kill (x, y, aa, bb, cc), infix("@@"), 0);
0;

map (lhs, [aa < bb, aa <= bb, aa = bb, aa # bb, equal (aa, bb), notequal (aa, bb), aa >= bb, aa > bb]);
[aa, aa, aa, aa, aa, aa, aa, aa];

map (rhs, [aa < bb, aa <= bb, aa = bb, aa # bb, equal (aa, bb), notequal (aa, bb), aa >= bb, aa > bb]);
[bb, bb, bb, bb, bb, bb, bb, bb];

map (lhs, [foo(x) := 2*x, bar(y) ::= 3*y, '(aa : bb), '(aa :: bb), ?marrow(aa, bb)]);
['(foo(x)), '(bar(y)), aa, aa, aa];

map (rhs, [foo(x) := 2*x, bar(y) ::= 3*y, '(aa : bb), '(aa :: bb), ?marrow(aa, bb)]);
[2*x, 3*y, bb, bb, bb];

[lhs (aa @@ bb), lhs (aa @@ bb @@ cc), rhs (aa @@ bb), rhs (aa @@ bb @@ cc)];
[aa, aa @@ bb, bb, cc];

map (lhs, [aa + bb, aa - bb, aa * bb, aa / bb, sin(aa), log(aa)]);
[aa + bb, aa - bb, aa * bb, aa / bb, sin(aa), log(aa)];

map (rhs, [aa + bb, aa - bb, aa * bb, aa / bb, sin(aa), log(aa)]);
[0, 0, 0, 0, 0, 0];

kill ("@@");
done;

/* Verify that grind treats nouns correctly. string calls MSIZE in src/grind.lisp.
 */

kill (all);
done;

string ('(integrate(f(x), x) + integrate(g(x), x, minf, inf) + diff(u, x) + sum(h(x), x, 1, n)));
"sum(h(x),x,1,n)+integrate(g(x),x,minf,inf)+integrate(f(x),x)+diff(u,x)";

string ('integrate(f(x), x) + 'integrate(g(x), x, minf, inf) + 'diff(u, x) + 'sum(h(x), x, 1, n));
"'sum(h(x),x,1,n)+'integrate(g(x),x,minf,inf)+'integrate(f(x),x)+'diff(u,x,1)";

/* GREAT puts nounified atoms before others, it appears ... */
string (%a%a + %b%b + nounify(%c%c) + nounify(%d%d) + %e%e + %f%f);
"%d%d+%c%c+%f%f+%e%e+%b%b+%a%a";

string (sin(x) * cos(x) + tan(x));
"tan(x)+cos(x)*sin(x)";

string ('foo(x, y, z) / bar(a, b, c) + 'baz(%pi - 'quux(%e ^ mumble(%i))));
"'foo(x,y,z)/bar(a,b,c)+'baz(%pi-'quux(%e^mumble(%i)))";

/* It's conceivable that someday nounified arithmetic operators would be treated differently by grind.
 * If/when that happens, revise this example accordingly.
 */
string ('"+"(a, b, '"."(c, d), '"^"(e, f)));
"'?mplus(a,b,'?mnctimes(c,d),'?mexpt(e,f))";

/* Bug 626697 */
limit(atan2(y,x),y,minf);
-'limit(atan2(y,x),y,inf);

/* Bug 1548643 */
limit(abs(sqrt(1-1/x)-1),x,0);
und;

/* Bug 671574 */
limit(x*atan(x)/(x+1),x,inf);
%pi/2;
limit(x*atan(x)-log(x),x,inf);
inf;

/* Bug 1152668 */
numer:true;
true;
limit(sin(x)/x,x,0);
1;
limit(sin(x)/x,x,0,plus);
1;
limit(sin(x)/x,x,0,minus);
1;
numer:false;
false;

/* Bug 593344 */
limit(abs(infinity));
inf;

/* Bug 626721 */
logarc(atan2(y,x));
-%i*log((%i*y+x)/sqrt(x^2+y^2));
rectform(ev(%,x=-1,y=1));
3*%pi/4; 

/* Bug 1469411 */
limit(t^2*exp(-4*t/3-8*exp(-t)),t,inf);
0;

/*
 * From bug 535363, but this isn't really fixed.  The fix for 1469411
 * broke this test, so we're adding it to make sure we don't break it.
 * 
*/

limit(exp(-1/x)/x^4,x,0,'plus);
0;

/* Bug 1594330 */
limit(x*(atan(x)-%pi/2),x,inf);
-1;

/*
 * Bug [ 1661490 ] An integral gives a wrong result.
 */
(assume(a>0,b>0,sqrt(b^2+a^2)-a>0,sqrt(sqrt(b^2+a^2)-a)*(sqrt(b^2+a^2)+a)^(3/2)-b^2>0),0);
0;
radcan(integrate(exp(-(a+%i*b)*x^2),x,minf,inf)/rectform(sqrt(%pi)/sqrt(a+%i*b)));
1;

/*
 * [ 1663704 ] integrate(sin(r*x)^7/x^4,x,0,inf) -> r^3*false
 *
 * Should return the integral instead of producing false.
 */
integrate(sin(a*x)^7/x^4,x,0,inf);
'integrate(sin(a*x)^7/x^4,x,0,inf);

/*
 * [ 1646761 ] limit atanh @ -1 / 1 all wrong...
 */
/* Limit at 1 is (complex) infinity).  But one-sided limit can be inf (real infinity). */
limit(atanh(x),x,1);
infinity;
limit(atanh(x),x,1,'minus);
inf;
limit(atanh(x),x,-1);
infinity;
limit(atanh(x),x,-1,'plus);
minf;

/* There shouldn't be an error message printed out here.  Need to look at output to see. */
limit(2*atanh(x),x,1);
infinity;
limit(2*atanh(x),x,1,'minus);
inf;

limit(atanh(a-1)-log(a)/2,a,0,'plus),logarc:true;
-log(2)/2;

end;
end$
