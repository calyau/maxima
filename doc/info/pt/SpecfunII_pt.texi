@c /SpecfunII.texi/1.8/Thu Apr 21 04:58:35 2005/
@menu
* Introdu@value{cedilha}@~ao a Polin@^omios Ortogonais::  
* Defini@value{cedilha}@~oes para Polin@^omios Ortogonais::  
@end menu


@c SEEMS LIKE THIS INTRODUCTION COULD REORGANIZED -- IT'S A BIT HAPHAZARD
@node Introdu@value{cedilha}@~ao a Polin@^omios Ortogonais, Defini@value{cedilha}@~oes para Polin@^omios Ortogonais, , Polin@^omios Ortogonais
@section Introdu@value{cedilha}@~ao a Polin@^omios Ortogonais

O pacote @code{specfun} cont@'em C@'odigo
Maxima para a avalia@,{c}@~ao de todos os polin@^omios ortogonais listados no 
Cap@'itulo 22 de Abramowitz e Stegun. Esses incluem polin@^omios de
Chebyshev, Laguerre, Hermite, Jacobi, Legendre, e ultraesf@'erico
(Gegenbauer).  Adicionalmente, @code{specfun} cont@'em c@'odigos para 
fun@,{c}@~oes de Bessel esf@'ericas, fun@,{c}@~oes de Hankel esf@'ericas, e fun@,{c}@~oes harm@^onicas esf@'ericas.
O pacote @code{specfun} n@~ao @'e parte do Maxima propriamente;
ele @'e chamado por meio de requisi@,{c}@~ao de usu@'ario via @code{load} ou automaticamente via o sistema @code{autoload}.

A seguinte tabela lista cada fun@,{c}@~ao em @code{specfun}.
@code{specfun} @'e um nome Maxima, restri@,{c}@~oes sobre seus argumentos, e uma 
refer@^encia para o algor@'itmo que @code{specfun} usa para avaliar isso.
Com poucas excess@~oes, @code{specfun} segue as conven@,{c}@~oes de
Abramowitz e Stegun.
Em todos os casos, @math{m} e @math{n} devem ser inteiros.
@c UM, I REALLY DON'T THINK THIS DISCLAIMER IS NECESSARY
@c Before you use @code{specfun}, check
@c that @code{specfun}'s conventions match your expectations.

A&S refere-se a Abramowitz e Stegun, @emph{Handbook of 
Mathematical Functions} (10th edi@,{c}@~ao, Dezembro de 1972), 
G&R refere-se a Gradshteyn e Ryzhik, 
@emph{Table of Integrals, Series, and Products}
(1980 edi@,{c}@~ao corrigida e ampliada), e Merzbacher 
refere-se a @emph{Quantum Mechanics} (segunda edi@,{c}@~ao, 1970).

@c CONSIDER STRIKING OUT RESTRICTIONS COLUMN TO MAKE TABLE NARROWER
@multitable @columnfractions 0.25 0.25 0.25 0.25
@item @emph{Fun@value{cedilha}@~ao} @tab  @emph{Nome Maxima}  @tab @emph{Restri@,{c}@~oes} @tab @emph{Refer@^encia(s)}
@item @ Chebyshev T @tab chebyshev_t(n, x) @tab @math{n > -1} @tab A&S 22.5.31 
@item  Chebyshev U @tab chebyshev_u(n, x) @tab @math{n > -1} @tab A&S 22.5.32 
@item generalized Laguerre @tab gen_laguerre(n,a,x) @tab @math{n > -1} @tab A&S p@'agina 789
@item Laguerre @tab laguerre(n,x) @tab @math{n > -1} @tab A&S 22.5.67
@item Hermite @tab hermite(n,x) @tab @math{ n > -1} @tab A&S 22.4.40, 22.5.41
@item Jacobi @tab jacobi_p(n,a,b,x) @tab @math{ n > -1, a, b > -1} @tab A&S p@'agina 789
@item associated Legendre P @tab assoc_legendre_p(n,m,x) @tab @math{n > -1} @tab A&S 22.5.37, 8.6.6, 8.2.5
@item associated Legendre Q @tab assoc_legendre_q(n,m,x) @tab @math{n > -1, m > -1} @tab G & R 8.706
@item Legendre P @tab legendre_p(n,m,x) @tab @math{n > -1} @tab A&S 22.5.35
@item Legendre Q @tab legendre_q(n,m,x) @tab @math{n > -1} @tab A&S 8.6.19
@item spherical Hankel 1st @tab spherical_hankel1(n, x) @tab @math{n > -1} @tab A&S 10.1.36
@item spherical Hankel 2nd @tab spherical_hankel2(n, x) @tab @math{n > -1} @tab A&S 10.1.17
@item spherical Bessel J @tab spherical_bessel_j(n,x) @tab @math{n > -1} @tab A&S 10.1.8, 10.1.15
@item spherical Bessel Y @tab spherical_bessel_y(n,x) @tab @math{n > -1} @tab A&S 10.1.9, 10.1.15
@item spherical harmonic @tab spherical_harmonic(n,m,x,y) @tab @math{n > -1, |m| <= n} @tab Merzbacher 9.64
@item ultraspherical (Gegenbauer) @tab ultraspherical(n,a,x) @tab @math{ n > -1} @tab A&S 22.5.27
@end multitable

O pacote @code{specfun} @'e prim@'ariamente planejado para computa@,{c}@~ao 
simb@'olica. A computa@,{c}@~ao simb@'olica espera que @code{specfun} forne@,{c}a resultados acurados
em ponto flutuante tamb@'em; todavia, nenhuma reinvidica@,{c}@~ao foi feita para que os algor@'itmos 
sejam tamb@'em adequados para avalia@,{c}@~ao num@'erica.  Algum esfor@,{c}o, todavia,
tem sido feito para fornecer
@c "GOOD NUMERICAL PERFORMANCE" -- LET'S BE MORE PRECISE. FAST? ACCURATE? SOMETHING ELSE?
boa performace num@'erica.
Quando todos os argumentos, exceto pela ordem, forem n@'umeros em ponto flutuante (mas n@~ao grandes n@'umeros em ponto flutuante), 
muitas fun@,{c}@~oes em @code{specfun} chamam uma vers@~ao mododeclarada da
fun@,{c}@~ao de Jacobi.  Isso aumenta grandemente a velocidade de avalia@,{c}@~ao de n@'umeros em ponto flutuante
de polin@^omios ortogonais.

@code{specfun} manuseia muitos dom@'inios de erro atrav@'es do retorno de uma fun@,{c}@~ao
n@~ao avaliada.  
Nenhuma regra de simplifica@,{c}@~ao (baseada em rela@,{c}@~oes recursivas) @'e definida para fun@,{c}@~oes n@~ao avaliadas.
Isso @'e poss@'ivel para uma express@~ao
envolvendo adi@,{c}@~oes de fun@,{c}@~oes especiais n@~ao avaliadas para tender para zero, ainda
Maxima @'e incapaz de reduzir essas fun@,{c}@~oes a zero.
@c DISCLAIMER UNNECESSARY
@c Be careful.

@code{load ("specfun")} chama o pacote @code{specfun}.
Alternativamente, @code{setup_autoload} faz com que o pacote seja chamado
quando uma das fun@,{c}@~oes @code{specfun} aparecer em uma express@~ao.
@code{setup_autoload} pode aparecer na linha de comando ou no arquivo @code{maxima-init.mac}.
Veja @code{setup_autoload}.

Um exemplo de uso de @code{specfun} @'e

@c EXAMPLE GENERATED FROM FOLLOWING INPUT
@c load ("specfun")$
@c [hermite (0, x), hermite (1, x), hermite (2, x)];
@c diff (hermite (n, x), x);
@example
(%i1) load ("specfun")$
(%i2) [hermite (0, x), hermite (1, x), hermite (2, x)];
                                         2
(%o2)               [1, 2 x, - 2 (1 - 2 x )]
(%i3) diff (hermite (n, x), x);
(%o3)                 2 n hermite(n - 1, x)
@end example

@c FOLLOWING REMARKS ABOUT WRONG NUMBER OF ARGUMENTS CAUSING FATAL ERROR
@c WITH COMPILED CODE SEEM OUT OF DATE:
@c TESTING WITH 5.9.1 CMUCL, 5.9.1CVS CLISP, 5.9.1CVS GCL,
@c I GET ERROR MESSAGES ABOUT WRONG NUMBER OF ARGUMENTS (NOT FATAL)

@c When using the compiled version of @code{specfun}, be especially
@c careful to  use the correct number of function arguments; calling
@c them with too few arguments may generate a fatal error messages.  
@c For example
@c @example
@c (%i1) load("specfun")$
@c /* chebyshev_t requires two arguments. */
@c (%i2) chebyshev_t(8);
@c Error: Caught fatal error [memory may be damaged]
@c Fast links are on: do (si::use-fast-links nil) for debugging
@c Error signalled by MMAPCAR.
@c Broken at SIMPLIFY.  Type :H for Help.
@c @end example
@c Maxima code translated into Lisp handles such errors more gracefully. 
@c If @code{specfun.lisp} is installed on your machine, the same computation 
@c results in  a clear error message.  For example
@c @example
@c (%i1) load("specfun.lisp")$
@c (%i2) chebyshev_t(8);
@c Error: Expected 2 args but received 1 args
@c Fast links are on: do (si::use-fast-links nil) for debugging
@c Error signalled by MACSYMA-TOP-LEVEL.
@c Broken at |$CHEBYSHEV_T|.  Type :H for Help.
@c @end example 

@c NEED CONTEXT FOR THIS REMARK, OR MAYBE JUST CUT IT
Geralmente, c@'odigo compilado executa mais r@'apidamente que o c@'odigo traduzido; todavia, 
c@'odigo traduzido pode ser melhor para desenvolvimento de programas.

Algumas fun@,{c}@~oes 
@c SUM IS CONSTRUCTED BY jacobi_p FOR SYMBOLIC n. OTHER FUNCTIONS CALL jacobi_p OR EACH OTHER.
@c THERE ARE SOME FUNCTIONS WHICH IMPOSE THE REQUIREMENT THAT n BE NUMERICAL,
@c SO THEY NEVER CALL A FUNCTION ON THIS LIST WITH A SYMBOLIC n.
(a saber @code{jacobi_p}, @code{ultraspherical}, @code{chebyshev_t},
@code{chebyshev_u} e @code{legendre_p}),
retornam um representa@,{c}@~ao de s@'erie quando a ordem for um inteiro simb@'olico.
A representa@,{c}@~ao de s@'erie n@~ao @'e
usada por @code{specfun} para qualquer computa@,{c}@~ao,
mas essa representa@,{c}@~ao de s@'erie pode ser simplificada pelo Maxima automaticamente,
ou a simplifica@,{c}@~ao pode ser poss@'ivel para usar as s@'eries para avaliar a fun@,{c}@~ao
atrav@'es de manipula@,{c}@~oes adicionais.
Por exemplo:

@c EXAMPLE GENERATED FROM FOLLOWING INPUT
@c load ("specfun")$
@c legendre_p (n, x);
@c ultraspherical (n, 3/2, 2);
@c declare (n, integer)$
@c legendre_p (n, x);
@c ultraspherical (n, 3/2, 2);
@example
(%i1) load ("specfun")$
(%i2) legendre_p (n, x);
(%o2)                   legendre_p(n, x)
(%i3) ultraspherical (n, 3/2, 2);
             genfact(3, n, - 1) jacobi_p(n, 1, 1, 2)
(%o3)        ---------------------------------------
                       genfact(2, n, - 1)
(%i4) declare (n, integer)$
(%i5) legendre_p (n, x);
       n - 1
       ====
       \                                                 n - i%
(%o5) ( >     binomial(n, i%) binomial(n, n - i%) (x - 1)
       /
       ====
       i% = 1

                                    i%          n          n   n
                             (x + 1)   + (x + 1)  + (x - 1) )/2
(%i6) ultraspherical (n, 3/2, 2);
                          n - 1
                          ====
                          \       i%
(%o6) genfact(3, n, - 1) ( >     3   binomial(n + 1, i%)
                          /
                          ====
                          i% = 1

                                    n
 binomial(n + 1, n - i%) + (n + 1) 3  + n + 1)

                      n
/(genfact(2, n, - 1) 2 )
@end example

O primeiro e o @'ultimo termos
da adi@,{c}@~ao s@~ao adicionados fora do somat@'orio.  Removendo esses
dois termos evita-se erros do Maxima associados com termos @math{0^0}
em uma adi@,{c}@~ao que pode avaliar para 1, mas avaliada para 0 em um somat@'orio
no Maxima. Porque a soma de @'indices vai de 1 a
@math{n - 1}, o menor @'indice de
soma exceder@'a o maior @'indice de soma quando @math{n = 0}; 
escolhendo @code{sumhack} para @code{true} temos uma corre@,{c}@~ao. Por exemplo:

@c EXAMPLE GENERATED FROM FOLLOWING INPUT
@c load ("specfun")$
@c declare (n, integer)$
@c e: legendre_p(n,x)$
@c ev (e, sum, n = 0);
@c ev (e, sum, n = 0, sumhack = true);
@example 
(%i1) load ("specfun")$
(%i2) declare (n, integer)$
(%i3) e: legendre_p(n,x)$
(%i4) ev (e, sum, n=0);
Lower bound to sum: 1
is greater than the upper bound: - 1
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) ev (e, sum, n=0, sumhack=true);
(%o5)                           1
@end example

Muitas fun@,{c}@~oes em @code{specfun} possuem uma propriedade @code{gradef}; 
derivadas com rela@,{c}@~ao a ordem ou outros parâmetros de fun@,{c}@~oes 
s@~ao indefinidas, e uma tentativa de calcular tal uma derivada retorna como resiltado uma mensagem de erro.

O pacote @code{specfun} e sua documenta@,{c}@~ao foram escritos por
Barton Willis da Universidade de Nebraska em Kearney. Foi
liberado sob os termos da Licen@,{c}a P@'ublica Geral (GPL).
@c HMM, SHOULD BUG REPORTS BE DIRECTED TO SF BUG TRACKER ??
@c PERHAPS FOR SHARE PACKAGES WE SHOULD HAVE BUG REPORTS GO TO THE SF BUG TRACKER AND 
@c ASK AUTHORS TO MONITOR THE BUG TRACKER FOR ITEMS RELATED TO THEIR PACKAGE.
Envie relat@'orios de erro e coment@'arios sobre esse pacote para 
willisb@@unk.edu.  Em seu relat@'orio, por favor inclua 
a vers@~ao do Maxima, como reportado por @code{build_info()},
e a vers@~ao de @code{specfun}, como reportado por @code{get ('specfun, 'version)}.

@c end concepts Orthogonal Polynomials
@node Defini@value{cedilha}@~oes para Polin@^omios Ortogonais, , Introdu@value{cedilha}@~ao a Polin@^omios Ortogonais, Polin@^omios Ortogonais
@section Defini@value{cedilha}@~oes para Polin@^omios Ortogonais

@anchor{assoc_legendre_p}
@deffn {Fun@value{cedilha}@~ao} assoc_legendre_p (@var{n}, @var{m}, @var{x})
Retorna a fun@,{c}@~ao associada de Legendre
de primeiro tipo para inteiros @math{ n > -1 } e
@math{ m > -1}.  Quando @math{ | m | > n } e @math{ n >= 0},
teremos   @math{assoc_legendre_p (n, m, x) = 0}.
Refer@^encia: A&S 22.5.37 p@'agina 779,  A&S 8.6.6 (segunda 
equa@,{c}@~ao) p@'agina 334, e A&S 8.2.5 p@'agina 333.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja @ref{assoc_legendre_q}, @ref{legendre_p}, e @ref{legendre_q}.
@end deffn

@anchor{assoc_legendre_q}
@deffn {Fun@value{cedilha}@~ao} assoc_legendre_q (@var{n}, @var{m}, @var{x})

Retorna a fun@,{c}@~ao associada de Legendre
de segundo tipo para inteiros @math{ n > -1 } e
@math{ m > -1}. 

Refer@^encia: Gradshteyn e Ryzhik  8.706 p@'agina 1000.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{assoc_legendre_p}, @ref{legendre_p}, e @ref{legendre_q}.
@end deffn

@anchor{chebyshev_t}
@deffn {Fun@value{cedilha}@~ao}   chebyshev_t (@var{n}, @var{x})

Retorna a fun@,{c}@~ao de Chebyshev de primeiro tipo
para inteiros @math{ n > -1}.

Refer@^encia: A&S 22.5.31 p@'agina 778 e A&S 6.1.22 p@'agina 256.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{chebyshev_u}.

@end deffn

@anchor{chebyshev_u}
@deffn {Fun@value{cedilha}@~ao}   chebyshev_u (@var{n}, @var{x})

Retorna a fun@,{c}@~ao de Chebyshev de 
segundo tipo para inteiros @math{ n > -1}.

Refer@^encia A&S, 22.8.3 p@'agina 783 e A&S 6.1.22 p@'agina 256. 

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{chebyshev_t}.

@end deffn

@anchor{gen_laguerre}
@deffn {Fun@value{cedilha}@~ao}   gen_laguerre (@var{n}, @var{a}, @var{x})

Retorna o polin@^omio generalizado de Laguerre
para inteiros @math{ n > -1}.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Refer@^encia tabela na p@'agina 789 em A&S.
@end deffn

@anchor{hermite}
@deffn {Fun@value{cedilha}@~ao} hermite (@var{n}, @var{x})

Retorna o polin@^omio de Hermite para
inteiros @math{ n > -1}.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Refer@^encia  A&S 22.5.40 e 22.5.41, p@'agina 779.

@end deffn

@anchor{jacobi_p}
@deffn {Fun@value{cedilha}@~ao}  jacobi_p (@var{n}, @var{a}, @var{b}, @var{x})

Retorna o polin@^omio de Jacobi para
inteiros @math{ n > -1 } e @math{ a } e @math{ b }
simb@'olicos ou @math{ a > -1}  e @math{b > -1}.  
(Os polin@^omios de  Jacobi s@~ao atualmente definidos para todos
@math{ a } e @math{ b }; todavia, o polin@^omio de Jacobi
peso @math{ (1-x)^a(1+x)^b} n@~ao @'e integr@'avel para @math{ a <= -1} ou para
@math{ b <= -1}.) 

Quando @math{a, b}, e @math{ x } forem n@'umeros em ponto flutuante (mas n@~ao grandes n@'umeros em ponto flutuante)  
@code{specfun} chama uma vers@~ao especial modo declarada de @math{jacobi_p}.
Para valore num@'ericos, a vers@~ao modo declarada @'e mais 
r@'apida que a outra vers@~ao. Muitas fun@,{c}@~oes em @code{specfun} s@~ao 
calculados como um caso especial dos polin@^omios de Jacobi; Eles tamb@'em 
desfrutam do impulso de velocidade da vers@~ao modo declarada de 
@math{ jacobi}.

Se @math{ n } tiver sido declarado para ser um inteiro, 
@math{jacobi_p (n, a, b, x)} retorna uma representa@,{c}@~ao de somat@'orio
para a fun@,{c}@~ao de Jacobi. Porque Maxima simplifica 
@math{0^0}  para @math{ 0 } em uma adi@,{c}@~ao, dois termos da adi@,{c}@~ao s@~ao
adicionados fora do somat@'orio.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Refer@^encia  tabela na p@'agina 789 em A&S.

@c NEEDS EXAMPLES
@end deffn

@anchor{laguerre}
@deffn {Fun@value{cedilha}@~ao}  laguerre (@var{n}, @var{x})

Retorna o polin@^omio de Laguerre para 
inteiros @math{ n > -1}.  

Refer@^encia A&S 22.5.16, p@'agina 778 e A&S p@'agina 789.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{gen_laguerre}.

@end deffn

@anchor{legendre_p}
@deffn {Fun@value{cedilha}@~ao}  legendre_p (@var{n}, @var{x})

Retorna o polin@^omio de Legendre de 
primeiro tipo para inteiros @math{ n > -1}.  

Refer@^encia A&S 22.5.35 p@'agina 779.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja @ref{legendre_q}.

@end deffn

@anchor{legendre_q}
@deffn {Fun@value{cedilha}@~ao}  legendre_q (@var{n}, @var{x})

Retorna o polin@^omio de Legendre de 
primeiro tipo para inteiros @math{ n > -1}.  

Refer@^encia A&S 8.6.19 p@'agina 334.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{legendre_p}.

@end deffn

@anchor{spherical_bessel_j}
@deffn {Fun@value{cedilha}@~ao} spherical_bessel_j (@var{n}, @var{x})

Retorna a fun@,{c}@~ao de Bessel esf@'erica do
primeiro tipo para inteiros @math{ n > -1}.  

Refer@^encia A&S 10.1.8 p@'agina 437 e A&S 10.1.15 p@'agina 439.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{spherical_hankel1}, @ref{spherical_hankel2}, 
e @ref{spherical_bessel_y}.

@end deffn

@anchor{spherical_bessel_y}
@deffn {Fun@value{cedilha}@~ao} spherical_bessel_y (@var{n}, @var{x})

Retorna a fun@,{c}@~ao de Bessel esf@'erica do
segundo tipo para inteiros @math{ n > -1}.  

Refer@^encia A&S 10.1.9 p@'agina 437 e 10.1.15 p@'agina 439.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{spherical_hankel1}, @ref{spherical_hankel2}, 
e @ref{spherical_bessel_y}.

@end deffn

@anchor{spherical_hankel1}
@deffn {Fun@value{cedilha}@~ao} spherical_hankel1 (@var{n}, @var{x})

Retorna a fun@,{c}@~ao de Hankel esf@'erica do
primeiro tipo para inteiros @math{ n > -1}.  

Refer@^encia A&S 10.1.36 p@'agina 439.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{spherical_hankel2}, @ref{spherical_bessel_j}, e
@ref{spherical_bessel_y}.

@end deffn

@anchor{spherical_hankel2}
@deffn {Fun@value{cedilha}@~ao} spherical_hankel2 (@var{n}, @var{x})

Retorna a fun@,{c}@~ao de Hankel esf@'erica do
segundo tipo para inteiros @math{ n > -1}.  

Refer@^encia  A&S 10.1.17 p@'agina 439.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{spherical_hankel1}, @ref{spherical_bessel_j}, e
@ref{spherical_bessel_y}.

@end deffn

@anchor{spherical_harmonic}
@deffn {Fun@value{cedilha}@~ao} spherical_harmonic (@var{n}, @var{m}, @var{x}, @var{y})

Retorna a fun@,{c}@~ao harm@^onica esf@'erica
para inteiros @math{ n > -1} e @math{ | m | <= n }.

Refer@^encia  Merzbacher 9.64.

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{assoc_legendre_p}.

@end deffn

@anchor{ultraspherical}
@deffn {Fun@value{cedilha}@~ao} ultraspherical (@var{n}, @var{a}, @var{x})

Retorna os polin@^omios ultraesf@'ericos para  
inteiros @math{ n > -1}.  Os polin@^omios ultraesf@'ericos s@~ao
tamb@'em conhecidos com polin@^omios de Gegenbauer.

Refer@^encia A&S 22.5.27

@code{load ("specfun")} chama essa fun@,{c}@~ao.

Veja tamb@'em @ref{jacobi_p}.

@end deffn

