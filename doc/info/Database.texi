@menu
* Introduction to Maximas Database::
* Functions and Variables for Properties::
* Functions and Variables for Facts::
* Functions and Variables for Predicates::
@end menu

@c -----------------------------------------------------------------------------
@node Introduction to Maximas Database, Functions and Variables for Properties, Maximas Database, Maximas Database
@section Introduction to Maximas Database
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@node Functions and Variables for Properties, Functions and Variables for Facts, Introduction to Maximas Database, Maximas Database
@section Functions and Variables for Properties
@c -----------------------------------------------------------------------------

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c THIS ITEM IS EXTREMELY IMPORTANT
@c ENSURE THAT ALL KEYWORDS RECOGNIZED BY declare HAVE THEIR OWN DOCUMENTATION ITEMS !!
@c ALSO: HOW TO FIND THE LIST OF ALL SYMBOLS WHICH HAVE A GIVEN PROPERTY ??

@c -----------------------------------------------------------------------------
@anchor{declare}
@deffn {Function} declare (@var{a_1}, @var{p_1}, @var{a_2}, @var{p_2}, @dots{})

Assigns the atom or list of atoms @var{a_i} the property or list of properties
@var{p_i}.  When @var{a_i} and/or @var{p_i} are lists, each of the atoms gets
all of the properties.

@code{declare} quotes its arguments.
@code{declare} always returns @code{done}.


As noted in the description for each declaration flag, for some flags
@code{featurep(@var{object}, @var{feature})} returns @code{true} if @var{object}
has been declared to have @var{feature}.  However, @code{featurep} does not
recognize some flags; this is a bug.

See also @code{features}.

@code{declare} recognizes the following properties:

@table @asis
@item @code{evfun}
Makes @var{a_i} known to @code{ev} so that the function named by @var{a_i}
is applied when @var{a_i} appears as a flag argument of @code{ev}.
See @code{evfun}.

@item @code{evflag}
Makes @var{a_i} known to the @code{ev} function so that @var{a_i} is bound to
@code{true} during the execution of @code{ev} when @var{a_i} appears as a flag
argument of @code{ev}.  See @code{evflag}.

@c OBSOLETE @code{special} (RECOGNIZED BY DECLARE BUT NEVER USED ANYWHERE)

@item @code{bindtest}
Tells Maxima to trigger an error when @var{a_i} is evaluated unbound.

@item @code{noun}
Tells Maxima to parse @var{a_i} as a noun.  The effect of this is to replace
instances of @var{a_i} with @code{'@var{a_i}} or @code{nounify(@var{a_i})},
depending on the context.

@item @code{constant}
Tells Maxima to consider @var{a_i} a symbolic constant.
@c WHAT MAXIMA KNOWS ABOUT SYMBOLIC CONSTANTS IS PRETTY LIMITED
@c DUNNO IF WE WANT TO GET INTO DETAILS HERE.
@c MAYBE IN THE DOCUMENTATION FOR CONSTANT (IF THERE IS SUCH)

@item @code{scalar}
Tells Maxima to consider @var{a_i} a scalar variable.

@item @code{nonscalar}
Tells Maxima to consider @var{a_i} a nonscalar variable.
The usual application is to declare a variable as a symbolic vector or matrix.

@item @code{nonarray}
Tells Maxima to consider @var{a_i} not an array.  This declaration prevents
multiple evaluation of a subscripted variable name.

@item @code{mainvar}
Tells Maxima to consider @var{a_i} a "main variable".  A main variable succeeds
all other constants and variables in the canonical ordering of Maxima
expressions, as determined by @code{ordergreatp}.

@item @code{alphabetic}
Tells Maxima to recognize all characters in @var{a_i} (which must be a string)
as alphabetic characters.

@item @code{feature}
Tells Maxima to recognize @var{a_i} as the name of a feature.
Other atoms may then be declared to have the @var{a_i} property.

@item @code{rassociative}, @code{lassociative}
Tells Maxima to recognize @var{a_i} as a right-associative or left-associative
function.

@item @code{nary}
Tells Maxima to recognize @var{a_i} as an n-ary function.

The @code{nary} declaration is not the same as calling the @code{nary} function.
The sole effect of @code{declare(foo, nary)} is to instruct the Maxima
simplifier to flatten nested expressions, for example, to simplify
@code{foo(x, foo(y, z))} to @code{foo(x, y, z)}.

@item @code{symmetric}, @code{antisymmetric}, @code{commutative}
Tells Maxima to recognize @var{a_i} as a symmetric or antisymmetric function.
@code{commutative} is the same as @code{symmetric}.

@item @code{oddfun}, @code{evenfun}
Tells Maxima to recognize @var{a_i} as an odd or even function.

@item @code{outative}
Tells Maxima to simplify @var{a_i} expressions by pulling constant factors out
of the first argument.

When @var{a_i} has one argument, a factor is considered constant if it is a
literal or declared constant.

When @var{a_i} has two or more arguments, a factor is considered constant if the
second argument is a symbol and the factor is free of the second argument.

@item @code{multiplicative}
Tells Maxima to simplify @var{a_i} expressions by the substitution
@code{@var{a_i}(x * y * z * ...)} @code{-->} 
@code{@var{a_i}(x) * @var{a_i}(y) * @var{a_i}(z) * ...}.
The substitution is carried out on the first argument only.

@item @code{additive}
Tells Maxima to simplify @var{a_i} expressions by the substitution
@code{@var{a_i}(x + y + z + ...)} @code{-->}
@code{@var{a_i}(x) + @var{a_i}(y) + @var{a_i}(z) + ...}.
The substitution is carried out on the first argument only.

@item @code{linear}
Equivalent to declaring @var{a_i} both @code{outative} and @code{additive}.

@c OBSOLETE @code{analytic} (RECOGNIZED BY DECLARE BUT NEVER USED ANYWHERE)

@item @code{integer}, @code{noninteger}
Tells Maxima to recognize @var{a_i} as an integer or noninteger variable.

@item @code{even}, @code{odd}
Tells Maxima to recognize @var{a_i} as an even or odd integer variable.

@item @code{rational}, @code{irrational}
Tells Maxima to recognize @var{a_i} as a rational or irrational real variable.

@item @code{real}, @code{imaginary}, @code{complex}
Tells Maxima to recognize @var{a_i} as a real, pure imaginary, or complex
variable.

@item @code{increasing}, @code{decreasing}
Tells Maxima to recognize @var{a_i} as an increasing or decreasing function.
@c MAXIMA FAILS TO DEDUCE F(2) > F(1) FOR INCREASING FUNCTION F
@c AND FAILS TO DEDUCE ANYTHING AT ALL ABOUT DECREASING FUNCTIONS
@c REPORTED AS SF BUG # 1483194

@item @code{posfun}
Tells Maxima to recognize @var{a_i} as a positive function.

@item @code{integervalued}
Tells Maxima to recognize @var{a_i} as an integer-valued function.

@end table

Examples:

@code{evfun} and @code{evflag} declarations.

@c ===beg===
@c declare (expand, evfun);
@c (a + b)^3;
@c (a + b)^3, expand;
@c declare (demoivre, evflag);
@c exp (a + b*%i);
@c exp (a + b*%i), demoivre;
@c ===end===
@example
(%i1) declare (expand, evfun);
(%o1)                         done
(%i2) (a + b)^3;
                                   3
(%o2)                       (b + a)
(%i3) (a + b)^3, expand;
                     3        2      2      3
(%o3)               b  + 3 a b  + 3 a  b + a
(%i4) declare (demoivre, evflag);
(%o4)                         done
(%i5) exp (a + b*%i);
                             %i b + a
(%o5)                      %e
(%i6) exp (a + b*%i), demoivre;
                      a
(%o6)               %e  (%i sin(b) + cos(b))
@end example

@code{bindtest} declaration.

@c ===beg===
@c aa + bb;
@c declare (aa, bindtest);
@c aa + bb;
@c aa : 1234;
@c aa + bb;
@c ===end===
@example
(%i1) aa + bb;
(%o1)                        bb + aa
(%i2) declare (aa, bindtest);
(%o2)                         done
(%i3) aa + bb;
aa unbound variable
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) aa : 1234;
(%o4)                         1234
(%i5) aa + bb;
(%o5)                       bb + 1234
@end example

@code{noun} declaration.

@c ===beg===
@c factor (12345678);
@c declare (factor, noun);
@c factor (12345678);
@c ''%, nouns;
@c ===end===
@example
(%i1) factor (12345678);
                             2
(%o1)                     2 3  47 14593
(%i2) declare (factor, noun);
(%o2)                         done
(%i3) factor (12345678);
(%o3)                   factor(12345678)
(%i4) ''%, nouns;
                             2
(%o4)                     2 3  47 14593
@end example

@code{constant}, @code{scalar}, @code{nonscalar}, and @code{mainvar}
declarations.

@c ===beg===
@c declare (bb, constant);
@c declare (cc, scalar);
@c declare (dd, nonscalar);
@c declare (ee, mainvar);
@c ===end===
@example
@end example

@code{alphabetic} declaration.

@c ===beg===
@c xx\~yy\`\@ : 1729;
@c declare ("~`@", alphabetic);
@c xx~yy`@ + @yy`xx + `xx@@yy~;
@c listofvars (%);
@c ===end===
@example
(%i1) xx\~yy\`\@@ : 1729;
(%o1)                         1729
(%i2) declare ("~`@@", alphabetic);
(%o2)                         done
(%i3) xx~yy`@@ + @@yy`xx + `xx@@@@yy~;
(%o3)               `xx@@@@yy~ + @@yy`xx + 1729
(%i4) listofvars (%);
(%o4)                  [@@yy`xx, `xx@@@@yy~]
@end example

@code{feature} declaration.

@c ===beg===
@c declare (FOO, feature);
@c declare (x, FOO);
@c featurep (x, FOO);
@c ===end===
@example
(%i1) declare (FOO, feature);
(%o1)                         done
(%i2) declare (x, FOO);
(%o2)                         done
(%i3) featurep (x, FOO);
(%o3)                         true
@end example

@code{rassociative} and @code{lassociative} declarations.

@c ===beg===
@c declare (F, rassociative);
@c declare (G, lassociative);
@c ===end===
@example
@end example

@code{nary} declaration.

@c ===beg===
@c H (H (a, b), H (c, H (d, e)));
@c declare (H, nary);
@c H (H (a, b), H (c, H (d, e)));
@c ===end===
@example
(%i1) H (H (a, b), H (c, H (d, e)));
(%o1)               H(H(a, b), H(c, H(d, e)))
(%i2) declare (H, nary);
(%o2)                         done
(%i3) H (H (a, b), H (c, H (d, e)));
(%o3)                   H(a, b, c, d, e)
@end example

@code{symmetric} and @code{antisymmetric} declarations.

@c ===beg===
@c S (b, a);
@c declare (S, symmetric);
@c S (b, a);
@c S (a, c, e, d, b);
@c T (b, a);
@c declare (T, antisymmetric);
@c T (b, a);
@c T (a, c, e, d, b);
@c ===end===
@example
(%i1) S (b, a);
(%o1)                        S(b, a)
(%i2) declare (S, symmetric);
(%o2)                         done
(%i3) S (b, a);
(%o3)                        S(a, b)
(%i4) S (a, c, e, d, b);
(%o4)                   S(a, b, c, d, e)
(%i5) T (b, a);
(%o5)                        T(b, a)
(%i6) declare (T, antisymmetric);
(%o6)                         done
(%i7) T (b, a);
(%o7)                       - T(a, b)
(%i8) T (a, c, e, d, b);
(%o8)                   T(a, b, c, d, e)
@end example

@code{oddfun} and @code{evenfun} declarations.

@c ===beg===
@c o (- u) + o (u);
@c declare (o, oddfun);
@c o (- u) + o (u);
@c e (- u) - e (u);
@c declare (e, evenfun);
@c e (- u) - e (u);
@c ===end===
@example
(%i1) o (- u) + o (u);
(%o1)                     o(u) + o(- u)
(%i2) declare (o, oddfun);
(%o2)                         done
(%i3) o (- u) + o (u);
(%o3)                           0
(%i4) e (- u) - e (u);
(%o4)                     e(- u) - e(u)
(%i5) declare (e, evenfun);
(%o5)                         done
(%i6) e (- u) - e (u);
(%o6)                           0
@end example

@code{outative} declaration.

@c ===beg===
@c F1 (100 * x);
@c declare (F1, outative);
@c F1 (100 * x);
@c declare (zz, constant);
@c F1 (zz * y);
@c ===end===
@example
(%i1) F1 (100 * x);
(%o1)                       F1(100 x)
(%i2) declare (F1, outative);
(%o2)                         done
(%i3) F1 (100 * x);
(%o3)                       100 F1(x)
(%i4) declare (zz, constant);
(%o4)                         done
(%i5) F1 (zz * y);
(%o5)                       zz F1(y)
@end example

@code{multiplicative} declaration.

@c ===beg===
@c F2 (a * b * c);
@c declare (F2, multiplicative);
@c F2 (a * b * c);
@c ===end===
@example
(%i1) F2 (a * b * c);
(%o1)                       F2(a b c)
(%i2) declare (F2, multiplicative);
(%o2)                         done
(%i3) F2 (a * b * c);
(%o3)                   F2(a) F2(b) F2(c)
@end example

@code{additive} declaration.

@c ===beg===
@c F3 (a + b + c);
@c declare (F3, additive);
@c F3 (a + b + c);
@c ===end===
@example
(%i1) F3 (a + b + c);
(%o1)                     F3(c + b + a)
(%i2) declare (F3, additive);
(%o2)                         done
(%i3) F3 (a + b + c);
(%o3)                 F3(c) + F3(b) + F3(a)
@end example

@code{linear} declaration.

@c ===beg===
@c 'sum (F(k) + G(k), k, 1, inf);
@c declare (nounify (sum), linear);
@c 'sum (F(k) + G(k), k, 1, inf);
@c ===end===
@example
(%i1) 'sum (F(k) + G(k), k, 1, inf);
                       inf
                       ====
                       \
(%o1)                   >    (G(k) + F(k))
                       /
                       ====
                       k = 1
(%i2) declare (nounify (sum), linear);
(%o2)                         done
(%i3) 'sum (F(k) + G(k), k, 1, inf);
@group
                     inf          inf
                     ====         ====
                     \            \
(%o3)                 >    G(k) +  >    F(k)
                     /            /
                     ====         ====
                     k = 1        k = 1
@end group
@end example

@opencatbox
@category{Declarations and inferences}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{get}
@deffn {Function} get (@var{a}, @var{i})

Retrieves the user property indicated by @var{i} associated with
atom @var{a} or returns @code{false} if @var{a} doesn't have property @var{i}.

@code{get} evaluates its arguments.

@c ===beg===
@c put (%e, 'transcendental, 'type);
@c put (%pi, 'transcendental, 'type)$
@c put (%i, 'algebraic, 'type)$
@c typeof (expr) := block ([q],
@c         if numberp (expr)
@c         then return ('algebraic),
@c         if not atom (expr)
@c         then return (maplist ('typeof, expr)),
@c         q: get (expr, 'type),
@c         if q=false
@c         then errcatch (error(expr,"is not numeric.")) else q)$
@c typeof (2*%e + x*%pi);
@c typeof (2*%e + %pi);
@c ===end===
@example
(%i1) put (%e, 'transcendental, 'type);
(%o1)                    transcendental
(%i2) put (%pi, 'transcendental, 'type)$
(%i3) put (%i, 'algebraic, 'type)$
(%i4) typeof (expr) := block ([q],
        if numberp (expr)
        then return ('algebraic),
        if not atom (expr)
        then return (maplist ('typeof, expr)),
        q: get (expr, 'type),
        if q=false
        then errcatch (error(expr,"is not numeric.")) else q)$
(%i5) typeof (2*%e + x*%pi);
x is not numeric.
(%o5)  [[transcendental, []], [algebraic, transcendental]]
(%i6) typeof (2*%e + %pi);
(%o6)     [transcendental, [algebraic, transcendental]]

@end example

@opencatbox
@category{Declarations and inferences}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{nonarray}
@deffn {Property} nonarray

The command @code{declare(a, nonarray)} tells Maxima to consider @var{a} not
an array.  This declaration prevents multiple evaluation, if @var{a} is a
subscripted variable.

Example:

@c ===beg===
@c a:'b$ b:'c$ c:'d$
@c a[x];
@c declare(a, nonarray);
@c a[x];
@c ===end===
@example
(%i1) a:'b$ b:'c$ c:'d$

(%i4) a[x];
(%o4)                          d
                                x
(%i5) declare(a, nonarray);
(%o5)                         done
(%i6) a[x];
(%o6)                          a
                                x
@end example

@opencatbox
@category{Expressions}
@closecatbox
@end deffn

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{posfun}
@defvr {Declaration} posfun

@code{declare (f, posfun)} declares @code{f} to be a positive function.
@code{is (f(x) > 0)} yields @code{true}.

@opencatbox
@category{Declarations and inferences} @category{Operators}
@closecatbox
@end defvr

@c NEEDS WORK ESPECIALLY EXAMPLES
@c WHOLE BUSINESS WITH PROPERTIES IS PRETTY CONFUSING, TRY TO CLEAR IT UP

@c -----------------------------------------------------------------------------
@anchor{printprops}
@deffn  {Function} printprops (@var{a}, @var{i})
@deffnx {Function} printprops ([@var{a_1}, @dots{}, @var{a_n}], @var{i})
@deffnx {Function} printprops (all, @var{i})

Displays the property with the indicator @var{i} associated with the atom
@var{a}.  @var{a} may also be a list of atoms or the atom @code{all} in which
case all of the atoms with the given property will be used.  For example,
@code{printprops ([f, g], atvalue)}.  @code{printprops} is for properties that
cannot otherwise be displayed, i.e.  for @mrefcomma{atvalue}@w{}
@mrefcomma{atomgrad} @mrefcomma{gradef} and @mrefdot{matchdeclare}

@opencatbox
@category{Declarations and inferences} @category{Display functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Functions and Variables for Facts, Functions and Variables for Predicates, Functions and Variables for Properties, Maximas Database
@section Functions and Variables for Facts
@c -----------------------------------------------------------------------------

@c After studying src/compar.lisp, it appears that askexp would
@c work as advertised, except that it doesn't appear to be possible
@c to open a break prompt with ^A or any other character.
@c What should we do about askexp ???

@c -----------------------------------------------------------------------------
@anchor{askexp}
@defvr {System variable} askexp

When @code{asksign} is called,
@code{askexp} is the expression @code{asksign} is testing.

At one time, it was possible for a user to inspect @code{askexp}
by entering a Maxima break with control-A.

@opencatbox
@category{Declarations and inferences}
@closecatbox
@end defvr

@c THERE IS PROBABLY MORE TO THE STORY THAN WHAT IS INDICATED HERE ...

@c -----------------------------------------------------------------------------
@anchor{askinteger}
@deffn  {Function} askinteger (@var{expr}, integer)
@deffnx {Function} askinteger (@var{expr})
@deffnx {Function} askinteger (@var{expr}, even)
@deffnx {Function} askinteger (@var{expr}, odd)

@code{askinteger (@var{expr}, integer)} attempts to determine from the
@code{assume} database whether @var{expr} is an integer.
@code{askinteger} prompts the user if it cannot tell otherwise,
@c UMM, askinteger AND asksign DO NOT APPEAR TO HAVE ANY EFFECT ON THE assume
@c DATABASE !!!
and attempt to install the information in the database if possible.
@code{askinteger (@var{expr})} is equivalent to
@code{askinteger (@var{expr}, integer)}.

@code{askinteger (@var{expr}, even)} and @code{askinteger (@var{expr}, odd)}
likewise attempt to determine if @var{expr} is an even integer or odd integer,
respectively.

@opencatbox
@category{Declarations and inferences}
@closecatbox
@end deffn

@c THERE IS PROBABLY MORE TO THE STORY THAN WHAT IS INDICATED HERE ...

@c -----------------------------------------------------------------------------
@anchor{asksign}
@deffn {Function} asksign (@var{expr})

First attempts to determine whether the specified
expression is positive, negative, or zero.  If it cannot, it asks the
user the necessary questions to complete its deduction.  The user's
answer is recorded in the data base for the duration of the current
computation. The return value of @code{asksign} is one of @code{pos},
@code{neg}, or @code{zero}.

@opencatbox
@category{Declarations and inferences}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{is}
@deffn {Function} is (@var{expr})

Attempts to determine whether the predicate @var{expr} is provable from the
facts in the @code{assume} database.

If the predicate is provably @code{true} or @code{false}, @code{is} returns
@code{true} or @code{false}, respectively.  Otherwise, the return value is
governed by the global flag @code{prederror}.  When @code{prederror} is
@code{true}, @code{is} complains with an error message.  Otherwise, @code{is}
returns @code{unknown}.

@code{ev(@var{expr}, pred)} (which can be written  @code{@var{expr}, pred} at
the interactive prompt) is equivalent to @code{is(@var{expr})}.

See also @code{assume}, @code{facts}, and @code{maybe}.

Examples:

@code{is} causes evaluation of predicates.

@c ===beg===
@c %pi > %e;
@c is (%pi > %e);
@c ===end===
@example
(%i1) %pi > %e;
(%o1)                       %pi > %e
(%i2) is (%pi > %e);
(%o2)                         true
@end example

@code{is} attempts to derive predicates from the @code{assume} database.

@c ===beg===
@c assume (a > b);
@c assume (b > c);
@c is (a < b);
@c is (a > c);
@c is (equal (a, c));
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) assume (b > c);
(%o2)                        [b > c]
(%i3) is (a < b);
(%o3)                         false
(%i4) is (a > c);
(%o4)                         true
(%i5) is (equal (a, c));
(%o5)                         false
@end example

If @code{is} can neither prove nor disprove a predicate from the @code{assume}
database, the global flag @code{prederror} governs the behavior of @code{is}.

@c ===beg===
@c assume (a > b);
@c prederror: true$
@c is (a > 0);
@c prederror: false$
@c is (a > 0);
@c ===end===
@example
(%i1) assume (a > b);
(%o1)                        [a > b]
(%i2) prederror: true$
(%i3) is (a > 0);
Maxima was unable to evaluate the predicate:
a > 0
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) prederror: false$
(%i5) is (a > 0);
(%o5)                        unknown
@end example

@opencatbox
@category{Predicate functions} @category{Declarations and inferences}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{maybe}
@deffn {Function} maybe (@var{expr})

Attempts to determine whether the predicate @var{expr} is provable from the
facts in the @code{assume} database.

If the predicate is provably @code{true} or @code{false}, @code{maybe} returns
@code{true} or @code{false}, respectively.  Otherwise, @code{maybe} returns
@code{unknown}.

@code{maybe} is functionally equivalent to @code{is} with
@code{prederror: false}, but the result is computed without actually assigning
a value to @code{prederror}.

See also @code{assume}, @code{facts}, and @code{is}.

Examples:

@c ===beg===
@c maybe (x > 0);
@c assume (x > 1);
@c maybe (x > 0);
@c ===end===
@example
(%i1) maybe (x > 0);
(%o1)                        unknown
(%i2) assume (x > 1);
(%o2)                        [x > 1]
(%i3) maybe (x > 0);
(%o3)                         true
@end example

@opencatbox
@category{Predicate functions} @category{Declarations and inferences}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{sign}
@deffn {Function} sign (@var{expr})

Attempts to determine the sign of @var{expr} on the basis of the facts in the
current data base.  It returns one of the following answers: @code{pos}
(positive), @code{neg} (negative), @code{zero}, @code{pz} (positive or zero),
@code{nz} (negative or zero), @code{pn} (positive or negative), or @code{pnz}
(positive, negative, or zero, i.e. nothing known).

@opencatbox
@category{Declarations and inferences}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Functions and Variables for Predicates, , Functions and Variables for Facts, Maximas Database
@section Functions and Variables for Predicates
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{charfun}
@deffn {Function} charfun (@var{p})

Return 0 when the predicate @var{p} evaluates to @code{false}; return 1 when
the predicate evaluates to @code{true}.  When the predicate evaluates to
something other than @code{true} or @code{false} (unknown),  return a noun form.

Examples:

@c ===beg===
@c charfun (x < 1);
@c subst (x = -1, %);
@c e : charfun ('"and" (-1 < x, x < 1))$
@c [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
@c ===end===
@example
(%i1) charfun (x < 1);
(%o1)                    charfun(x < 1)
(%i2) subst (x = -1, %);
(%o2)                           1
(%i3) e : charfun ('"and" (-1 < x, x < 1))$
(%i4) [subst (x = -1, e), subst (x = 0, e), subst (x = 1, e)];
(%o4)                       [0, 1, 0]
@end example

@opencatbox
@category{Mathematical functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{compare}
@deffn {Function} compare (@var{x}, @var{y})

Return a comparison operator @var{op} (@code{<}, @code{<=}, @code{>}, @code{>=},
@code{=}, or @code{#}) such that @code{is (@var{x} @var{op} @var{y})} evaluates
to @code{true}; when either @var{x} or @var{y} depends on @code{%i} and
@code{@var{x} # @var{y}}, return @code{notcomparable}; when there is no such
operator or Maxima isn't able to determine the operator, return @code{unknown}.

Examples:

@c ===beg===
@c compare (1, 2);
@c compare (1, x);
@c compare (%i, %i);
@c compare (%i, %i + 1);
@c compare (1/x, 0);
@c compare (x, abs(x));
@c ===end===
@example
(%i1) compare (1, 2);
(%o1)                           <
(%i2) compare (1, x);
(%o2)                        unknown
(%i3) compare (%i, %i);
(%o3)                           =
(%i4) compare (%i, %i + 1);
(%o4)                     notcomparable
(%i5) compare (1/x, 0);
(%o5)                           #
(%i6) compare (x, abs(x));
(%o6)                          <=
@end example

The function @code{compare} doesn't try to determine whether the real domains of
its arguments are nonempty; thus

@c ===beg===
@c compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
@c ===end===
@example
(%i1) compare (acos (x^2 + 1), acos (x^2 + 1) + 1);
(%o1)                           <
@end example

@c IT IS NOT QUITE TRUE, WHAT ABOUT x=0 ?
The real domain of @code{acos (x^2 + 1)} is empty.

@opencatbox
@category{Declarations and inferences}
@closecatbox
@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES
@c CROSS REF declare, properties, ETC

@c -----------------------------------------------------------------------------
@anchor{constant}
@deffn {Special operator} constant

@code{declare (@var{a}, constant)} declares @var{a} to be a constant.
See @mrefdot{declare}
@c WHAT EXACTLY ARE THE CONSEQUENCES OF DECLARING AN ATOM TO BE CONSTANT ??

@opencatbox
@category{Declarations and inferences} @category{Constants}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{constantp}
@deffn {Function} constantp (@var{expr})

Returns @code{true} if @var{expr} is a constant expression, otherwise returns
@code{false}.
@c WHAT DOES MAXIMA KNOW ABOUT CONSTANT EXPRESSIONS ??

An expression is considered a constant expression if its arguments are
numbers (including rational numbers, as displayed with @code{/R/}),
symbolic constants such as @mrefcomma{%pi} @mrefcomma{%e} and @mrefcomma{%i}@w{}
variables bound to a constant or declared constant by @mrefcomma{declare}@w{}
or functions whose arguments are constant.

@code{constantp} evaluates its arguments.

Examples:

@c ===beg===
@c constantp (7 * sin(2));
@c constantp (rat (17/29));
@c constantp (%pi * sin(%e));
@c constantp (exp (x));
@c declare (x, constant);
@c constantp (exp (x));
@c constantp (foo (x) + bar (%e) + baz (2));
@c ===end===
@example
(%i1) constantp (7 * sin(2));
(%o1)                                true
(%i2) constantp (rat (17/29));
(%o2)                                true
(%i3) constantp (%pi * sin(%e));
(%o3)                                true
(%i4) constantp (exp (x));
(%o4)                                false
(%i5) declare (x, constant);
(%o5)                                done
(%i6) constantp (exp (x));
(%o6)                                true
(%i7) constantp (foo (x) + bar (%e) + baz (2));
(%o7)                                false
(%i8) 
@end example

@opencatbox
@category{Predicate functions} @category{Constants}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{equal}
@deffn {Function} equal (@var{a}, @var{b})

Represents equivalence, that is, equal value.

By itself, @code{equal} does not evaluate or simplify.
The function @code{is} attempts to evaluate @code{equal} to a Boolean value.
@code{is(equal(@var{a}, @var{b}))} returns @code{true} (or @code{false}) if
and only if @var{a} and @var{b} are equal (or not equal) for all possible
values of their variables, as determined by evaluating
@code{ratsimp(@var{a} - @var{b})}; if @code{ratsimp} returns 0, the two
expressions are considered equivalent.  Two expressions may be equivalent even
if they are not syntactically equal (i.e., identical).

When @code{is} fails to reduce @code{equal} to @code{true} or @code{false}, the
result is governed by the global flag @code{prederror}.  When @code{prederror}
is @code{true}, @code{is} complains with an error message.  Otherwise, @code{is}
returns @code{unknown}.

In addition to @code{is}, some other operators evaluate @code{equal} and
@code{notequal} to @code{true} or @code{false}, namely @code{if}, @code{and},
@code{or}, and @code{not}.

@c FOLLOWING STATEMENT IS MORE OR LESS TRUE BUT I DON'T THINK THE DETAILS ARE CORRECT
@c Declarations (integer, complex, etc)
@c for variables appearing in @var{a} and @var{b} are ignored by @code{equal}.
@c All variables are effectively assumed to be real-valued.

The negation of @code{equal} is @code{notequal}.

Examples:

By itself, @code{equal} does not evaluate or simplify.

@c ===beg===
@c equal (x^2 - 1, (x + 1) * (x - 1));
@c equal (x, x + 1);
@c equal (x, y);
@c ===end===
@example
(%i1) equal (x^2 - 1, (x + 1) * (x - 1));
                        2
(%o1)            equal(x  - 1, (x - 1) (x + 1))
(%i2) equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) equal (x, y);
(%o3)                      equal(x, y)
@end example

The function @code{is} attempts to evaluate @code{equal} to a Boolean value.
@code{is(equal(@var{a}, @var{b}))} returns @code{true} when
@code{ratsimp(@var{a} - @var{b})} returns 0.  Two expressions may be equivalent
even if they are not syntactically equal (i.e., identical).

@c ===beg===
@c ratsimp (x^2 - 1 - (x + 1) * (x - 1));
@c is (equal (x^2 - 1, (x + 1) * (x - 1)));
@c is (x^2 - 1 = (x + 1) * (x - 1));
@c ratsimp (x - (x + 1));
@c is (equal (x, x + 1));
@c is (x = x + 1);
@c ratsimp (x - y);
@c is (equal (x, y));
@c is (x = y);
@c ===end===
@example
(%i1) ratsimp (x^2 - 1 - (x + 1) * (x - 1));
(%o1)                           0
(%i2) is (equal (x^2 - 1, (x + 1) * (x - 1)));
(%o2)                         true
(%i3) is (x^2 - 1 = (x + 1) * (x - 1));
(%o3)                         false
(%i4) ratsimp (x - (x + 1));
(%o4)                          - 1
(%i5) is (equal (x, x + 1));
(%o5)                         false
(%i6) is (x = x + 1);
(%o6)                         false
(%i7) ratsimp (x - y);
(%o7)                         x - y
(%i8) is (equal (x, y));
(%o8)                        unknown
(%i9) is (x = y);
(%o9)                         false
@end example

When @code{is} fails to reduce @code{equal} to @code{true} or @code{false},
the result is governed by the global flag @code{prederror}.

@c ===beg===
@c [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
@c ratsimp (aa - bb);
@c prederror : true;
@c is (equal (aa, bb));
@c prederror : false;
@c is (equal (aa, bb));
@c ===end===
@example
(%i1) [aa : x^2 + 2*x + 1, bb : x^2 - 2*x - 1];
                    2             2
(%o1)             [x  + 2 x + 1, x  - 2 x - 1]
(%i2) ratsimp (aa - bb);
(%o2)                        4 x + 2
(%i3) prederror : true;
(%o3)                         true
(%i4) is (equal (aa, bb));
Maxima was unable to evaluate the predicate:
       2             2
equal(x  + 2 x + 1, x  - 2 x - 1)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) prederror : false;
(%o5)                         false
(%i6) is (equal (aa, bb));
(%o6)                        unknown
@end example

Some operators evaluate @code{equal} and @code{notequal} to @code{true} or
@code{false}.

@c ===beg===
@c if equal (y, y - 1) then FOO else BAR;
@c eq_1 : equal (x, x + 1);
@c eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
@c [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
@c ===end===
@example
(%i1) if equal (y, y - 1) then FOO else BAR;
(%o1)                          BAR
(%i2) eq_1 : equal (x, x + 1);
(%o2)                    equal(x, x + 1)
(%i3) eq_2 : equal (y^2 + 2*y + 1, (y + 1)^2);
                         2                   2
(%o3)             equal(y  + 2 y + 1, (y + 1) )
(%i4) [eq_1 and eq_2, eq_1 or eq_2, not eq_1];
(%o4)                  [false, true, true]
@end example

Because @code{not @var{expr}} causes evaluation of @var{expr},
@code{not equal(@var{a}, @var{b})} is equivalent to
@code{is(notequal(@var{a}, @var{b}))}.

@c ===beg===
@c [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
@c is (notequal (2*z, 2*z - 1));
@c ===end===
@example
(%i1) [notequal (2*z, 2*z - 1), not equal (2*z, 2*z - 1)];
(%o1)            [notequal(2 z, 2 z - 1), true]
(%i2) is (notequal (2*z, 2*z - 1));
(%o2)                         true
@end example

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{notequal}
@deffn {Function} notequal (@var{a}, @var{b})

Represents the negation of @code{equal(@var{a}, @var{b})}.

Examples:

@c ===beg===
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c not equal (a, b);
@c maybe (notequal (a, b));
@c assume (a > b);
@c equal (a, b);
@c maybe (equal (a, b));
@c notequal (a, b);
@c maybe (notequal (a, b));
@c ===end===
@example
(%i1) equal (a, b);
(%o1)                      equal(a, b)
(%i2) maybe (equal (a, b));
(%o2)                        unknown
(%i3) notequal (a, b);
(%o3)                    notequal(a, b)
(%i4) not equal (a, b);
(%o4)                    notequal(a, b)
(%i5) maybe (notequal (a, b));
(%o5)                        unknown
(%i6) assume (a > b);
(%o6)                        [a > b]
(%i7) equal (a, b);
(%o7)                      equal(a, b)
(%i8) maybe (equal (a, b));
(%o8)                         false
(%i9) notequal (a, b);
(%o9)                    notequal(a, b)
(%i10) maybe (notequal (a, b));
(%o10)                        true
@end example

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{unknown}
@deffn {Function} unknown (@var{expr})

Returns @code{true} if and only if @var{expr} contains an operator or function
not recognized by the Maxima simplifier.

@opencatbox
@category{Predicate functions} @category{Simplification functions}
@closecatbox
@end deffn

@c THIS FUNCTION APPEARS TO BE A HACK; SEE 4'TH ITEM BELOW
@c DUNNO WHETHER WE CAN CLEAR THIS UP

@c -----------------------------------------------------------------------------
@anchor{zeroequiv}
@deffn {Function} zeroequiv (@var{expr}, @var{v})

Tests whether the expression @var{expr} in the variable @var{v} is equivalent
to zero, returning @code{true}, @code{false}, or @code{dontknow}.

@code{zeroequiv} has these restrictions:

@enumerate
@item
Do not use functions that Maxima does not know how to
differentiate and evaluate.
@item
If the expression has poles on the real line, there may be errors
in the result (but this is unlikely to occur).
@item
If the expression contains functions which are not solutions to first order
differential equations (e.g.  Bessel functions) there may be incorrect results.
@item
The algorithm uses evaluation at randomly chosen points for carefully selected
subexpressions.  This is always a somewhat hazardous business, although the
algorithm tries to minimize the potential for error.
@end enumerate

For example @code{zeroequiv (sin(2 * x) - 2 * sin(x) * cos(x), x)} returns
@code{true} and @code{zeroequiv (%e^x + x, x)} returns @code{false}.
On the other hand @code{zeroequiv (log(a * b) - log(a) - log(b), a)} returns 
@code{dontknow} because of the presence of an extra parameter @code{b}.

@opencatbox
@category{Predicate functions}
@closecatbox
@end deffn

