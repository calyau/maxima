@menu
* Comments::
* Files::                       
* Functions and Variables for File Input and Output::  
@end menu

@c -----------------------------------------------------------------------------
@node Comments, Files, File Input and Output, File Input and Output
@section Comments
@c -----------------------------------------------------------------------------

A comment in Maxima input is any text between @code{/*} and @code{*/}.

The Maxima parser treats a comment as whitespace for the purpose of finding
tokens in the input stream; a token always ends at a comment.  An input such as
@code{a/* foo */b} contains two tokens, @code{a} and @code{b},
and not a single token @code{ab}.  Comments are otherwise ignored by Maxima;
neither the content nor the location of comments is stored in parsed input
expressions.

Comments can be nested to arbitrary depth.  The @code{/*} and @code{*/}
delimiters form matching pairs.  There must be the same number of @code{/*}
as there are @code{*/}.

Examples:

@c ===beg===
@c /* aa is a variable of interest */  aa : 1234;
@c /* Value of bb depends on aa */  bb : aa^2;
@c /* User-defined infix operator */  infix ("b");
@c /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
@c /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
@c ===end===
@example
(%i1) /* aa is a variable of interest */  aa : 1234;
(%o1)                         1234
(%i2) /* Value of bb depends on aa */  bb : aa^2;
(%o2)                        1522756
(%i3) /* User-defined infix operator */  infix ("b");
(%o3)                           b
(%i4) /* Parses same as a b c, not abc */  a/* foo */b/* bar */c;
(%o4)                         a b c
(%i5) /* Comments /* can be nested /* to any depth */ */ */  1 + xyz;
(%o5)                        xyz + 1
@end example

@opencatbox
@category{Syntax}
@closecatbox

@c -----------------------------------------------------------------------------
@node Files, Functions and Variables for File Input and Output, Comments, File Input and Output
@section Files
@c -----------------------------------------------------------------------------

A file is simply an area on a particular storage device which contains data 
or text.  Files on the disks are figuratively grouped into "directories".
A directory is just a list of files.  Commands which deal with files are:

@code{save},
@code{load},
@code{loadfile},
@code{stringout},
@code{batch},
@code{demo},
@code{writefile},
@code{closefile}, and
@code{appendfile}.

When a file name is passed to functions like @code{plot2d}, @code{save}, or 
@code{writefile} and the file name does not include a path, Maxima stores 
the file in the current working directory.  The current working directory 
depends on the system like Windows or Linux and on the installation.

@c -----------------------------------------------------------------------------
@node Functions and Variables for File Input and Output,  , Files, File Input and Output
@section Functions and Variables for File Input and Output
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{file_output_append}
@defvr {Option variable} file_output_append
Default value: @code{false}

@code{file_output_append} governs whether file output functions append or
truncate their output file.  When @code{file_output_append} is @code{true}, such
functions append to their output file.  Otherwise, the output file is truncated.

@code{save}, @code{stringout}, and @code{with_stdout} respect
@code{file_output_append}.  Other functions which write output files do not
respect @code{file_output_append}.  In particular, plotting and translation
functions always truncate their output file, and @code{tex} and
@code{appendfile} always append.
@c WHAT ABOUT WRITEFILE ??

@opencatbox
@category{File output} @category{Global flags}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{appendfile}
@deffn {Function} appendfile (@var{filename})

Appends a console transcript to @var{filename}.  @code{appendfile} is the same
as @code{writefile}, except that the transcript file, if it exists, is always
appended.

@code{closefile} closes the transcript file opened by @code{appendfile} or
@code{writefile}.

@opencatbox
@category{File output} @category{Console interaction}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{batch}
@deffn  {Function} batch (@var{filename})
@deffnx {Function} batch (@var{filename}, @code{option})

@code{batch(@var{filename})} reads Maxima expressions from @var{filename} and 
evaluates them.  @code{batch} searches for @var{filename} in the list 
@code{file_search_maxima}.  See @code{file_search}.

@code{batch(@var{filename}, @code{demo})} is like @code{demo(@var{filename})}.
In this case @code{batch} searches for @var{filename} in the list
@code{file_search_demo}.  See @code{demo}.

@code{batch(@var{filename}, @code{test})} is like @code{run_testsuite} with the
option @code{display_all=true}.  For this case @code{batch} searches 
@var{filename} in the list @code{file_search_maxima} and not in the list
@code{file_search_tests} like @code{run_testsuite}.  Furthermore, 
@code{run_testsuite} runs tests which are in the list @code{testsuite_files}.
With @code{batch} it is possible to run any file in a test mode, which can be 
found in the list @code{file_search_maxima}.  This is useful, when writing a
test file.

@var{filename} comprises a sequence of Maxima expressions, each terminated with
@code{;} or @code{$}.  The special variable @code{%} and the function @code{%th}
refer to previous results within the file.  The file may include @code{:lisp}
constructs.  Spaces, tabs, and newlines in the file are ignored.  A suitable
input file may be created by a text editor or by the @code{stringout} function.

@code{batch} reads each input expression from @var{filename}, displays the input
to the console, computes the corresponding output expression, and displays the
output expression.  Input labels are assigned to the input expressions and
output labels are assigned to the output expressions.  @code{batch} evaluates
every input expression in the file unless there is an error.  If user input is
requested (by @code{asksign} or @code{askinteger}, for example) @code{batch}
pauses to collect the requisite input and then continue.

@c CTRL-C BREAKS batch IN CMUCL, BUT CLISP (ALTHO IT SHOWS "User break") 
@c KEEPS GOING !!! DON'T KNOW ABOUT GCL !!!
It may be possible to halt @code{batch} by typing @code{control-C} at the
console.  The effect of @code{control-C} depends on the underlying Lisp
implementation.

@code{batch} has several uses, such as to provide a reservoir for working
command lines, to give error-free demonstrations, or to help organize one's
thinking in solving complex problems.

@code{batch} evaluates its argument.  @code{batch} returns the path of
@var{filename} as a string, when called with no second argument or with the 
option @code{demo}.  When called with the option @code{test}, the return value
is a an empty list @code{[]} or a list with @var{filename} and the numbers of
the tests which have failed.

See also @code{load}, @code{batchload}, and @code{demo}.

@opencatbox
@category{Session management} @category{File input}
@closecatbox
@end deffn

@c RECOMMEND CUTTING THIS ITEM, AS THE load SUBSUMES FUNCTIONALITY OF batchload

@c -----------------------------------------------------------------------------
@anchor{batchload}
@deffn {Function} batchload (@var{filename})

Reads Maxima expressions from @var{filename} and evaluates them, without
displaying the input or output expressions and without assigning labels to
output expressions.  Printed output (such as produced by @code{print} or
@code{describe}) is displayed, however.

The special variable @code{%} and the function @code{%th} refer to previous
results from the interactive interpreter, not results within the file.
The file cannot include @code{:lisp} constructs.

@code{batchload} returns the path of @var{filename}, as a string.
@code{batchload} evaluates its argument.

See also @code{batch} and @code{load}.
@c batchload APPEARS TO HAVE THE SAME EFFECT AS load.
@c WHY NOT GET RID OF batchload ???

@opencatbox
@category{Session management} @category{File input}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{closefile}
@deffn {Function} closefile ()

Closes the transcript file opened by @code{writefile} or @code{appendfile}.

@opencatbox
@category{File output} @category{Console interaction}
@closecatbox
@end deffn

@c HMM, THIS NEXT ITEM IS DEFINED IN A SHARE FILE (itensor.lisp); 
@c DOES ITS DESCRIPTION WANT TO BE ELSEWHERE ???

@c -----------------------------------------------------------------------------
@anchor{dispcon}
@deffn  {Function} dispcon (@var{tensor_1}, @var{tensor_2}, @dots{})
@deffnx {Function} dispcon (all)

Displays the contraction properties of its arguments as were given to
@code{defcon}.  @code{dispcon (all)} displays all the contraction properties
which were defined.

@opencatbox
@category{Display functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{error_size}
@defvr {Option variable} error_size
Default value: 10

@code{error_size} modifies error messages according to the size of expressions
which appear in them.  If the size of an expression (as determined by the Lisp
function @code{ERROR-SIZE}) is greater than @code{error_size}, the expression is
replaced in the message by a symbol, and the symbol is assigned the expression.
The symbols are taken from the list @code{error_syms}.

Otherwise, the expression is smaller than @code{error_size}, and the expression
is displayed in the message.

See also @code{error} and @code{error_syms}.

Example:
@c OUTPUT GENERATED BY THE FOLLOWING
@c U: (C^D^E + B + A)/(cos(X-1) + 1)$
@c error_size: 20$
@c error ("Example expression is", U);
@c errexp1;
@c error_size: 30$
@c error ("Example expression is", U);

The size of @code{U}, as determined by @code{ERROR-SIZE}, is 24.

@example
(%i1) U: (C^D^E + B + A)/(cos(X-1) + 1)$

(%i2) error_size: 20$

(%i3) error ("Example expression is", U);

Example expression is errexp1
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) errexp1;
                            E
                           D
                          C   + B + A
(%o4)                    --------------
                         cos(X - 1) + 1
(%i5) error_size: 30$

(%i6) error ("Example expression is", U);

                         E
                        D
                       C   + B + A
Example expression is --------------
                      cos(X - 1) + 1
 -- an error.  Quitting.  To debug this try debugmode(true);
@end example

@opencatbox
@category{Debugging} @category{Display flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{error_syms}
@defvr {Option variable} error_syms
Default value: @code{[errexp1, errexp2, errexp3]}

In error messages, expressions larger than @code{error_size} are replaced by
symbols, and the symbols are set to the expressions.  The symbols are taken from
the list @code{error_syms}.  The first too-large expression is replaced by
@code{error_syms[1]}, the second by @code{error_syms[2]}, and so on.

If there are more too-large expressions than there are elements of
@code{error_syms}, symbols are constructed automatically, with the @var{n}-th
symbol equivalent to @code{concat ('errexp, @var{n})}.

See also @code{error} and @code{error_size}.

@opencatbox
@category{Debugging} @category{Display flags and variables}
@closecatbox
@end defvr

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{filename_merge}
@deffn {Function} filename_merge (@var{path}, @var{filename})

Constructs a modified path from @var{path} and @var{filename}.  If the final
component of @var{path} is of the form @code{###.@var{something}}, the component
is replaced with @code{@var{filename}.@var{something}}.  Otherwise, the final
component is simply replaced by @var{filename}.

The result is a Lisp pathname object.

@opencatbox
@category{File input} @category{File output}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{file_search}
@deffn  {Function} file_search (@var{filename})
@deffnx {Function} file_search (@var{filename}, @var{pathlist})

@code{file_search} searches for the file @var{filename} and returns the path to
the file (as a string) if it can be found; otherwise @code{file_search} returns
@code{false}.  @code{file_search (@var{filename})} searches in the default
search directories, which are specified by the @code{file_search_maxima},
@code{file_search_lisp}, and @code{file_search_demo} variables.

@code{file_search} first checks if the actual name passed exists,
before attempting to match it to ``wildcard'' file search patterns.
See @code{file_search_maxima} concerning file search patterns.

The argument @var{filename} can be a path and file name, or just a file name,
or, if a file search directory includes a file search pattern, just the base of
the file name (without an extension).  For example,

@example
file_search ("/home/wfs/special/zeta.mac");
file_search ("zeta.mac");
file_search ("zeta");
@end example

all find the same file, assuming the file exists and 
@code{/home/wfs/special/###.mac} is in @code{file_search_maxima}.

@code{file_search (@var{filename}, @var{pathlist})} searches only in the
directories specified by @var{pathlist}, which is a list of strings.  The
argument @var{pathlist} supersedes the default search directories, so if the
path list is given, @code{file_search} searches only the ones specified, and not
any of the default search directories.  Even if there is only one directory in
@var{pathlist}, it must still be given as a one-element list.

The user may modify the default search directories.
See @code{file_search_maxima}.

@code{file_search} is invoked by @code{load} with @code{file_search_maxima} and
@code{file_search_lisp} as the search directories.

@opencatbox
@category{File input}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{file_search_maxima}
@anchor{file_search_lisp}
@anchor{file_search_demo}
@anchor{file_search_usage}
@anchor{file_search_tests}
@defvr  {Option variable} file_search_maxima
@defvrx {Option variable} file_search_lisp
@defvrx {Option variable} file_search_demo
@defvrx {Option variable} file_search_usage
@defvrx {Option variable} file_search_tests

These variables specify lists of directories to be searched by @code{load},
@code{demo}, and some other Maxima functions.  The default values of these
variables name various directories in the Maxima installation.

The user can modify these variables, either to replace the default values or to
append additional directories.  For example,

@example
file_search_maxima: ["/usr/local/foo/###.mac",
    "/usr/local/bar/###.mac"]$
@end example

replaces the default value of @code{file_search_maxima}, while

@example
file_search_maxima: append (file_search_maxima,
    ["/usr/local/foo/###.mac", "/usr/local/bar/###.mac"])$
@end example

appends two additional directories.  It may be convenient to put such an
expression in the file @code{maxima-init.mac} so that the file search path is
assigned automatically when Maxima starts.

Multiple filename extensions and multiple paths can be specified by special 
``wildcard'' constructions.  The string @code{###} expands into the sought-after
name, while a comma-separated list enclosed in curly braces
@code{@{foo,bar,baz@}} expands into multiple strings.  For example, supposing
the sought-after name is @code{neumann},

@example
"/home/@{wfs,gcj@}/###.@{lisp,mac@}"
@end example

@flushleft
expands into @code{/home/wfs/neumann.lisp}, @code{/home/gcj/neumann.lisp},
@code{/home/wfs/neumann.mac}, and @code{/home/gcj/neumann.mac}.
@end flushleft

@opencatbox
@category{File input} @category{Global variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{file_type}
@deffn {Function} file_type (@var{filename})

Returns a guess about the content of @var{filename}, based on the filename 
extension.  @var{filename} need not refer to an actual file; no attempt is made 
to open the file and inspect the content.

The return value is a symbol, either @code{object}, @code{lisp}, or
@code{maxima}.  If the extension is matches one of the values in
@code{file_type_maxima} @code{file_type} returns @code{maxima}.  If the
extension matchees one of the values in @code{file_type_lisp},
@code{file_type} returns @code{lisp}.  If none of the above,
@code{file_type} returns @code{object}.

See also @code{pathname_type}.

See @code{file_type_maxima} and @code{file_type_lisp} for the default values.

Examples:

@c === beg ===
@c map('file_type,
@c     ["test.lisp", "test.mac", "test.dem", "test.txt"]);
@c === end ===
@example
(%i2) map('file_type,
          ["test.lisp", "test.mac", "test.dem", "test.txt"]);
(%o2)            [lisp, maxima, maxima, object]
@end example

@opencatbox
@category{File input}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{file_type_lisp}
@defvr {Option variable} file_type_lisp
Default value:  @code{[l, lsp, lisp]}

@code{file_type_lisp} is a list of file extensions that maxima recognizes
as denoting a Lisp source file.

See also @code{file_type}.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{file_type_maxima}
@defvr {Option variable} file_type_maxima
Default value:  @code{[mac, mc, demo, dem, dm1, dm2, dm3, dmt]}

@code{file_type_maxima} is a list of file extensions that maxima recognizes
as denoting a Maxima source file.

See also @code{file_type}.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{load}
@deffn {Function} load (@var{filename})

Evaluates expressions in @var{filename}, thus bringing variables, functions, and
other objects into Maxima.  The binding of any existing object is clobbered by
the binding recovered from @var{filename}.  To find the file, @code{load} calls
@code{file_search} with @code{file_search_maxima} and @code{file_search_lisp}
as the search directories.  If @code{load} succeeds, it returns the name of the
file.  Otherwise @code{load} prints an error message.

@code{load} works equally well for Lisp code and Maxima code.  Files created by
@code{save}, @code{translate_file}, and @code{compile_file}, which create Lisp
code, and @code{stringout}, which creates Maxima code, can all be processed by
@code{load}.  @code{load} calls @code{loadfile} to load Lisp files and
@code{batchload} to load Maxima files.

@code{load} does not recognize @code{:lisp} constructs in Maxima files, and
while processing @var{filename}, the global variables @code{_}, @code{__},
@code{%}, and @code{%th} have whatever bindings they had when @code{load} was
called.

See also @code{loadfile}, @code{batch}, @code{batchload}, and @code{demo}.
@code{loadfile} processes Lisp files; @code{batch}, @code{batchload}, and
@code{demo} process Maxima files.

See @code{file_search} for more detail about the file search mechanism.

@code{load} evaluates its argument.

@opencatbox
@category{Session management} @category{File input}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{load_pathname}
@defvr {System variable} load_pathname
Default value: @code{false}

When a file is loaded with the functions @code{load}, @code{loadfile} or 
@code{batchload} the system variable @code{load_pathname} is bound to the 
pathname of the file which is processed.

The variable @code{load_pathname} can be accessed from the file during the
loading.

Example:

Suppose we have a batchfile @code{test.mac} in the directory
@flushleft
@code{"/home/dieter/workspace/mymaxima/temp/"} with the following commands
@end flushleft

@example
print("The value of load_pathname is: ", load_pathname)$
print("End of batchfile")$
@end example

then we get the following output

@example
(%i1) load("/home/dieter/workspace/mymaxima/temp/test.mac")$
The value of load_pathname is:  
                   /home/dieter/workspace/mymaxima/temp/test.mac 
End of batchfile
@end example

@opencatbox
@category{File input}
@closecatbox
@end defvr

@c RECOMMEND CUTTING THIS ITEM, AS THE load SUBSUMES FUNCTIONALITY OF loadfile

@c -----------------------------------------------------------------------------
@anchor{loadfile}
@deffn {Function} loadfile (@var{filename})

Evaluates Lisp expressions in @var{filename}.  @code{loadfile} does not invoke
@code{file_search}, so @code{filename} must include the file extension and as
much of the path as needed to find the file.

@code{loadfile} can process files created by @code{save}, @code{translate_file},
and @code{compile_file}.  The user may find it more convenient to use
@code{load} instead of @code{loadfile}.

@opencatbox
@category{Session management} @category{File input}
@closecatbox
@end deffn

@c loadprint DOESN'T EXACTLY WORK LIKE THIS, BUT IT HARDLY SEEMS WORTH FIXING
@c I GUESS THIS COULD BE UPDATED TO DESCRIBE THE WAY IT ACTUALLY WORKS

@c -----------------------------------------------------------------------------
@anchor{loadprint}
@defvr {Option variable} loadprint
Default value: @code{true}

@code{loadprint} tells whether to print a message when a file is loaded.

@itemize @bullet
@item
When @code{loadprint} is @code{true}, always print a message.
@item
When @code{loadprint} is @code{'loadfile}, print a message only if
a file is loaded by the function @code{loadfile}.
@item
When @code{loadprint} is @code{'autoload},
print a message only if a file is automatically loaded.
See @code{setup_autoload}.
@item
When @code{loadprint} is @code{false}, never print a message.
@end itemize

@opencatbox
@category{File input} @category{Global flags}
@closecatbox
@end defvr

@c STILL EXISTS, NEEDS CLARIFICATION !!!

@c -----------------------------------------------------------------------------
@anchor{packagefile}
@defvr {Option variable} packagefile
Default value: @code{false}

Package designers who use @code{save} or @code{translate} to create packages
(files) for others to use may want to set @code{packagefile: true} to prevent
information from being added to Maxima's information-lists (e.g.  @code{values},
@code{functions}) except where necessary when the file is loaded in.  In this
way, the contents of the package will not get in the user's way when he adds his
own data.  Note that this will not solve the problem of possible name conflicts.
Also note that the flag simply affects what is output to the package file.
Setting the flag to @code{true} is also useful for creating Maxima init files.

@opencatbox
@category{Translation flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{pathname_directory}
@anchor{pathname_name}
@anchor{pathname_type}
@deffn  {Function} pathname_directory (@var{pathname})
@deffnx {Function} pathname_name (@var{pathname})
@deffnx {Function} pathname_type (@var{pathname})

These functions return the components of @var{pathname}.

Examples:

@c === beg ===
@c pathname_directory("/home/dieter/maxima/changelog.txt");
@c pathname_name("/home/dieter/maxima/changelog.txt");
@c pathname_type("/home/dieter/maxima/changelog.txt");
@c === end ===
@example 
(%i1) pathname_directory("/home/dieter/maxima/changelog.txt");
(%o1)                 /home/dieter/maxima/
(%i2) pathname_name("/home/dieter/maxima/changelog.txt");
(%o2)                       changelog
(%i3) pathname_type("/home/dieter/maxima/changelog.txt");
(%o3)                          txt
@end example

@opencatbox
@category{File input}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{printfile}
@deffn {Function} printfile (@var{path})

Prints the file named by @var{path} to the console.  @var{path} may be a string
or a symbol; if it is a symbol, it is converted to a string.

If @var{path} names a file which is accessible from the current working
directory, that file is printed to the console.  Otherwise, @code{printfile}
attempts to locate the file by appending @var{path} to each of the elements of
@code{file_search_usage} via @code{filename_merge}.

@code{printfile} returns @var{path} if it names an existing file,
or otherwise the result of a successful filename merge.

@opencatbox
@category{File input} @category{Console interaction}
@closecatbox
@end deffn

@c RECOMMEND CUTTING THIS ITEM AND CUTTING $tcl_output IN src/plot.lisp
@c THIS REALLY, REALLY SEEMS LIKE CRUFT:
@c $tcl_output IS NEVER CALLED WITHIN MAXIMA SOURCE,
@c AND THIS EXTREMELY NARROW, LIMITED FUNCTIONALITY ISN'T USEFUL TO USERS
@c AND IT'S BROKEN: INCORRECT OUTPUT FOR CLISP, DIES ON GCL

@c -----------------------------------------------------------------------------
@anchor{tcl_output}
@deffn  {Function} tcl_output (@var{list}, @var{i0}, @var{skip})
@deffnx {Function} tcl_output (@var{list}, @var{i0})
@deffnx {Function} tcl_output ([@var{list_1}, @dots{}, @var{list_n}], @var{i})

Prints elements of a list enclosed by curly braces @code{@{ @}},
suitable as part of a program in the Tcl/Tk language.

@code{tcl_output (@var{list}, @var{i0}, @var{skip})}
prints @var{list}, beginning with element @var{i0} and printing elements
@code{@var{i0} + @var{skip}}, @code{@var{i0} + 2 @var{skip}}, etc.

@code{tcl_output (@var{list}, @var{i0})}
is equivalent to @code{tcl_output (@var{list}, @var{i0}, 2)}.

@code{tcl_output ([@var{list_1}, ..., @var{list_n}], @var{i})}
prints the @var{i}'th elements of @var{list_1}, @dots{}, @var{list_n}.

Examples:
@c EXAMPLE INPUT
@c tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$
@c tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$
@c tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$
@c tcl_output ([x1, y1, x2, y2, x3, y3], 2)$
@c tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

@c EXAMPLE OUTPUT: CLISP
@c OUTPUT IS OK FOR FIRST TWO, BROKEN FOR OTHERS
@c GCL OUTPUT: SAME FOR FIRST TWO
@c GCL FAILS ON OTHERS (IN EACH CASE COMPLAINING ELEMENTS ARE "not of type (OR RATIONAL LISP:FLOAT)"
@example
(%i1) tcl_output ([1, 2, 3, 4, 5, 6], 1, 3)$

 @{1.000000000     4.000000000     
 @}
(%i2) tcl_output ([1, 2, 3, 4, 5, 6], 2, 3)$

 @{2.000000000     5.000000000     
 @}
(%i3) tcl_output ([3/7, 5/9, 11/13, 13/17], 1)$

 @{((RAT SIMP) 3 7) ((RAT SIMP) 11 13) 
 @}
(%i4) tcl_output ([x1, y1, x2, y2, x3, y3], 2)$

 @{$Y1 $Y2 $Y3 
 @}
(%i5) tcl_output ([[1, 2, 3], [11, 22, 33]], 1)$

 @{SIMP 1.000000000     11.00000000     
 @}
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{reveal}
@deffn {Function} reveal (@var{expr}, @var{depth})

Replaces parts of @var{expr} at the specified integer @var{depth}
with descriptive summaries.

@itemize @bullet
@item
Sums and differences are replaced by @code{Sum(@var{n})}
where @var{n} is the number of operands of the sum.
@item
Products are replaced by @code{Product(@var{n})}
where @var{n} is the number of operands of the product.
@item
Exponentials are replaced by @code{Expt}.
@item
Quotients are replaced by @code{Quotient}.
@item
Unary negation is replaced by @code{Negterm}.
@item
Lists are replaced by @code{List(@var{n})} where @var{n} ist the number of
elements of the list.
@end itemize

When @var{depth} is greater than or equal to the maximum depth of @var{expr},
@code{reveal (@var{expr}, @var{depth})} returns @var{expr} unmodified.

@code{reveal} evaluates its arguments.
@code{reveal} returns the summarized expression.

Example:

@c === beg ===
@c e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
@c reveal (e, 1);
@c reveal (e, 2);
@c reveal (e, 3);
@c reveal (e, 4);
@c reveal (e, 5);
@c reveal (e, 6);
@c === end ===
@example
(%i1) e: expand ((a - b)^2)/expand ((exp(a) + exp(b))^2);
                          2            2
                         b  - 2 a b + a
(%o1)               -------------------------
                        b + a     2 b     2 a
                    2 %e      + %e    + %e
(%i2) reveal (e, 1);
(%o2)                       Quotient
(%i3) reveal (e, 2);
                             Sum(3)
(%o3)                        ------
                             Sum(3)
(%i4) reveal (e, 3);
@group
                     Expt + Negterm + Expt
(%o4)               ------------------------
                    Product(2) + Expt + Expt
@end group
(%i5) reveal (e, 4);
                       2                 2
                      b  - Product(3) + a
(%o5)         ------------------------------------
                         Product(2)     Product(2)
              2 Expt + %e           + %e
(%i6) reveal (e, 5);
                         2            2
                        b  - 2 a b + a
(%o6)              --------------------------
                       Sum(2)     2 b     2 a
                   2 %e       + %e    + %e
(%i7) reveal (e, 6);
                          2            2
                         b  - 2 a b + a
(%o7)               -------------------------
                        b + a     2 b     2 a
                    2 %e      + %e    + %e
@end example

@opencatbox
@category{Expressions} @category{Display functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{rmxchar}
@defvr {Option variable} rmxchar
Default value: @code{]}

@code{rmxchar} is the character drawn on the right-hand side of a matrix.

See also @code{lmxchar}.

@opencatbox
@category{Display flags and variables}
@closecatbox
@end defvr

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{save}
@deffn  {Function} save (@var{filename}, @var{name_1}, @var{name_2}, @var{name_3}, @dots{})
@deffnx {Function} save (@var{filename}, values, functions, labels, @dots{})
@deffnx {Function} save (@var{filename}, [@var{m}, @var{n}])
@deffnx {Function} save (@var{filename}, @var{name_1}=@var{expr_1}, @dots{})
@deffnx {Function} save (@var{filename}, all)
@deffnx {Function} save (@var{filename}, @var{name_1}=@var{expr_1}, @var{name_2}=@var{expr_2}, @dots{})

Stores the current values of @var{name_1}, @var{name_2}, @var{name_3}, @dots{},
in @var{filename}.  The arguments are the names of variables, functions, or
other objects.  If a name has no value or function associated with it, it is
ignored.  @code{save} returns @var{filename}.

@code{save} stores data in the form of Lisp expressions.
The data stored by @code{save} may be recovered by @code{load (@var{filename})}.

The global flag @code{file_output_append} governs whether @code{save} appends or
truncates the output file.  When @code{file_output_append} is @code{true},
@code{save} appends to the output file.  Otherwise, @code{save} truncates the
output file.  In either case, @code{save} creates the file if it does not yet
exist.

The special form @code{save (@var{filename}, values, functions, labels, ...)}
stores the items named by @code{values}, @code{functions}, @code{labels}, etc.
The names may be any specified by the variable @code{infolists}.
@code{values} comprises all user-defined variables.

The special form @code{save (@var{filename}, [@var{m}, @var{n}])} stores the
values of input and output labels @var{m} through @var{n}.  Note that @var{m}
and @var{n} must be literal integers.  Input and output labels may also be
stored one by one, e.g., @code{save ("foo.1", %i42, %o42)}.
@code{save (@var{filename}, labels)} stores all input and output labels.
When the stored labels are recovered, they clobber existing labels.

The special form @code{save (@var{filename}, @var{name_1}=@var{expr_1},
@var{name_2}=@var{expr_2}, ...)} stores the values of @var{expr_1},
@var{expr_2}, @dots{}, with names @var{name_1}, @var{name_2}, @dots{}
It is useful to apply this form to input and output labels, e.g.,
@code{save ("foo.1", aa=%o88)}.  The right-hand side of the equality in this
form may be any expression, which is evaluated.  This form does not introduce
the new names into the current Maxima environment, but only stores them in
@var{filename}.

These special forms and the general form of @code{save} may be mixed at will.
For example, @code{save (@var{filename}, aa, bb, cc=42, functions, [11, 17])}.

The special form @code{save (@var{filename}, all)} stores the current state of
Maxima.  This includes all user-defined variables, functions, arrays, etc., as
well as some automatically defined items.  The saved items include system
variables, such as @code{file_search_maxima} or @code{showtime}, if they have
been assigned new values by the user; see @code{myoptions}.

@code{save} evaluates @var{filename} and quotes all other arguments.

@opencatbox
@category{Session management} @category{File output}
@closecatbox
@end deffn

@c NEEDS MORE WORK !!!

@c -----------------------------------------------------------------------------
@anchor{savedef}
@defvr {Option variable} savedef
Default value: @code{true}

When @code{savedef} is @code{true}, the Maxima version of a user function is
preserved when the function is translated.  This permits the definition to be
displayed by @code{dispfun} and allows the function to be edited.

When @code{savedef} is @code{false}, the names of translated functions are
removed from the @code{functions} list.

@opencatbox
@category{Translation flags and variables}
@closecatbox
@end defvr

@c THIS FUNCTION IS IN THE SHARE PACKAGE itensor.lisp
@c MOVE THIS DESCRIPTION TO Itensor.texi

@c -----------------------------------------------------------------------------
@anchor{show}
@deffn {Function} show (@var{expr})

Displays @code{expr} with the indexed objects in it shown
having covariant indices as subscripts, contravariant indices as
superscripts.  The derivative indices are displayed as subscripts,
separated from the covariant indices by a comma.

@opencatbox
@category{Package itensor} @category{Display functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{showratvars}
@deffn {Function} showratvars (@var{expr})

Returns a list of the canonical rational expression (CRE) variables in
expression @code{expr}.

See also @code{ratvars}.

@opencatbox
@category{Rational expressions} @category{Display functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{stringout}
@deffn  {Function} stringout (@var{filename}, @var{expr_1}, @var{expr_2}, @var{expr_3}, @dots{})
@deffnx {Function} stringout (@var{filename}, [@var{m}, @var{n}])
@deffnx {Function} stringout (@var{filename}, input)
@deffnx {Function} stringout (@var{filename}, functions)
@deffnx {Function} stringout (@var{filename}, values)

@code{stringout} writes expressions to a file in the same form the expressions
would be typed for input.  The file can then be used as input for the
@code{batch} or @code{demo} commands, and it may be edited for any purpose.
@code{stringout} can be executed while @code{writefile} is in progress.

The global flag @code{file_output_append} governs whether @code{stringout}
appends or truncates the output file.  When @code{file_output_append} is
@code{true}, @code{stringout} appends to the output file.  Otherwise,
@code{stringout} truncates the output file.  In either case, @code{stringout}
creates the file if it does not yet exist.

The general form of @code{stringout} writes the values of one or more 
expressions to the output file.  Note that if an expression is a
variable, only the value of the variable is written and not the name
of the variable.  As a useful special case, the expressions may be
input labels (@code{%i1}, @code{%i2}, @code{%i3}, @dots{}) or output labels
(@code{%o1}, @code{%o2}, @code{%o3}, @dots{}).

If @code{grind} is @code{true}, @code{stringout} formats the output using the
@code{grind} format.  Otherwise the @code{string} format is used.  See
@code{grind} and @code{string}.

The special form @code{stringout (@var{filename}, [@var{m}, @var{n}])} writes
the values of input labels m through n, inclusive.

The special form @code{stringout (@var{filename}, input)} writes all
input labels to the file.

The special form @code{stringout (@var{filename}, functions)} writes all
user-defined functions (named by the global list @code{functions}) to the file.

The special form @code{stringout (@var{filename}, values)} writes all
user-assigned variables (named by the global list @code{values}) to the file.
Each variable is printed as an assignment statement, with the name of the
variable, a colon, and its value.  Note that the general form of
@code{stringout} does not print variables as assignment statements.

@opencatbox
@category{Session management} @category{File output}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{tex}
@deffn  {Function} tex (@var{expr})
@deffnx {Function} tex (@var{expr}, @var{destination})
@deffnx {Function} tex (@var{expr}, false)
@deffnx {Function} tex (@var{label})
@deffnx {Function} tex (@var{label}, @var{destination})
@deffnx {Function} tex (@var{label}, false)

Prints a representation of an expression suitable for the TeX document
preparation system.  The result is a fragment of a document, which can be copied
into a larger document but not processed by itself.

@code{tex (@var{expr})} prints a TeX representation of @var{expr} on the
console.

@code{tex (@var{label})} prints a TeX representation of the expression named by
@var{label} and assigns it an equation label (to be displayed to the left of the
expression).  The TeX equation label is the same as the Maxima label.

@var{destination} may be an output stream or file name.  When @var{destination}
is a file name, @code{tex} appends its output to the file.  The functions
@code{openw} and @code{opena} create output streams.

@code{tex (@var{expr}, false)} and @code{tex (@var{label}, false)}
return their TeX output as a string.

@code{tex} evaluates its first argument after testing it to see if it is a
label.  Quote-quote @code{''} forces evaluation of the argument, thereby
defeating the test and preventing the label.

See also @code{texput}.

Examples:

@example
(%i1) integrate (1/(1+x^3), x);
                                    2 x - 1
                  2            atan(-------)
             log(x  - x + 1)        sqrt(3)    log(x + 1)
(%o1)      - --------------- + ------------- + ----------
                    6             sqrt(3)          3
(%i2) tex (%o1);
$$-@{@{\log \left(x^2-x+1\right)@}\over@{6@}@}+@{@{\arctan \left(@{@{2\,x-1
 @}\over@{\sqrt@{3@}@}@}\right)@}\over@{\sqrt@{3@}@}@}+@{@{\log \left(x+1\right)
 @}\over@{3@}@}\leqno@{\tt (\%o1)@}$$
(%o2)                          (\%o1)
(%i3) tex (integrate (sin(x), x));
$$-\cos x$$
(%o3)                           false
(%i4) tex (%o1, "foo.tex");
(%o4)                          (\%o1)
@end example

@code{tex (@var{expr}, false)} returns its TeX output as a string.

@c ===beg===
@c S : tex (x * y * z, false);
@c S;
@c ===end===
@example
(%i1) S : tex (x * y * z, false);
(%o1) $$x\,y\,z$$
(%i2) S;
(%o2) $$x\,y\,z$$
@end example

@opencatbox
@category{TeX output} @category{File output}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{tex1}
@deffn {Function} tex1 (@var{e})

Returns a string which represents the TeX output for the expressions @var{e}.
The TeX output is not enclosed in delimiters for an equation or any other
environment.

Examples:

@c ===beg===
@c tex1 (sin(x) + cos(x));
@c ===end===
@example
(%i1) tex1 (sin(x) + cos(x));
(%o1)                     \sin x+\cos x
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{texput}
@deffn  {Function} texput (@var{a}, @var{s})
@deffnx {Function} texput (@var{a}, @var{f})
@deffnx {Function} texput (@var{a}, @var{s}, @var{operator_type})
@deffnx {Function} texput (@var{a}, [@var{s_1}, @var{s_2}], matchfix)
@deffnx {Function} texput (@var{a}, [@var{s_1}, @var{s_2}, @var{s_3}], matchfix)

Assign the TeX output for the atom @var{a}, which can be a symbol or the name
of an operator.

@code{texput (@var{a}, @var{s})} causes the @code{tex} function to interpolate
the string @var{s} into the TeX output in place of @var{a}.

@code{texput (@var{a}, @var{f})} causes the @code{tex} function to call the
function @var{f} to generate TeX output.  @var{f} must accept one argument,
which is an expression which has operator @var{a}, and must return a string
(the TeX output).  @var{f} may call @code{tex1} to generate TeX output for the
arguments of the input expression.

@code{texput (@var{a}, @var{s}, @var{operator_type})}, where @var{operator_type}
is @code{prefix}, @code{infix}, @code{postfix}, @code{nary}, or @code{nofix},
causes the @code{tex} function to interpolate @var{s} into the TeX output in
place of @var{a}, and to place the interpolated text in the appropriate
position.

@code{texput (@var{a}, [@var{s_1}, @var{s_2}], matchfix)} causes the @code{tex}
function to interpolate @var{s_1} and @var{s_2} into the TeX output on either
side of the arguments of @var{a}.  The arguments (if more than one) are
separated by commas.

@code{texput (@var{a}, [@var{s_1}, @var{s_2}, @var{s_3}], matchfix)} causes the
@code{tex} function to interpolate @var{s_1} and @var{s_2} into the TeX output
on either side of the arguments of @var{a}, with @var{s_3} separating the
arguments.

Examples:

Assign TeX output for a variable.

@c ===beg===
@c texput (me,"\\mu_e");
@c tex (me);
@c ===end===
@example
(%i1) texput (me,"\\mu_e");
(%o1)                         \mu_e
(%i2) tex (me);
$$\mu_e$$
(%o2)                         false
@end example

Assign TeX output for an ordinary function (not an operator).

@c ===beg===
@c texput (lcm, "\\mathrm{lcm}");
@c tex (lcm (a, b));
@c ===end===
@example
(%i1) texput (lcm, "\\mathrm@{lcm@}");
(%o1)                     \mathrm@{lcm@}
(%i2) tex (lcm (a, b));
$$\mathrm@{lcm@}\left(a , b\right)$$
(%o2)                         false
@end example

Call a function to generate TeX output.

@c ===beg===
@c texfoo (e) := block ([a, b], [a, b] : args (e),
@c   concat ("\\left[\\stackrel{",tex1(b),"}{",tex1(a),"}\\right]"))$
@c texput (foo, texfoo);
@c tex (foo (2^x, %pi));
@c ===end===
@example
(%i1) texfoo (e) := block ([a, b], [a, b] : args (e),
  concat("\\left[\\stackrel@{",tex1(b),"@}@{",tex1(a),"@}\\right]"))$
(%i2) texput (foo, texfoo);
(%o2)                        texfoo
(%i3) tex (foo (2^x, %pi));
$$\left[\stackrel@{\pi@}@{2^@{x@}@}\right]$$
(%o3)                         false
@end example

Assign TeX output for a prefix operator.

@c ===beg===
@c prefix ("grad");
@c texput ("grad", " \\nabla ", prefix);
@c tex (grad f);
@c ===end===
@example
(%i1) prefix ("grad");
(%o1)                         grad
(%i2) texput ("grad", " \\nabla ", prefix);
(%o2)                        \nabla 
(%i3) tex (grad f);
$$ \nabla f$$
(%o3)                         false
@end example

Assign TeX output for an infix operator.

@c ===beg===
@c infix ("~");
@c texput ("~", " \\times ", infix);
@c tex (a ~ b);
@c ===end===
@example
(%i1) infix ("~");
(%o1)                           ~
(%i2) texput ("~", " \\times ", infix);
(%o2)                        \times 
(%i3) tex (a ~ b);
$$a \times b$$
(%o3)                         false
@end example

Assign TeX output for a postfix operator.

@c ===beg===
@c postfix ("##");
@c texput ("##", "!!", postfix);
@c tex (x ##);
@c ===end===
@example
(%i1) postfix ("##");
(%o1)                          ##
(%i2) texput ("##", "!!", postfix);
(%o2)                          !!
(%i3) tex (x ##);
$$x!!$$
(%o3)                         false
@end example

Assign TeX output for a nary operator.

@c ===beg===
@c nary ("@@");
@c texput ("@@", " \\circ ", nary);
@c tex (a @@ b @@ c @@ d);
@c ===end===
@example
(%i1) nary ("@@@@");
(%o1)                          @@@@
(%i2) texput ("@@@@", " \\circ ", nary);
(%o2)                         \circ 
(%i3) tex (a @@@@ b @@@@ c @@@@ d);
$$a \circ b \circ c \circ d$$
(%o3)                         false
@end example

Assign TeX output for a nofix operator.

@c ===beg===
@c nofix ("foo");
@c texput ("foo", "\\mathsc{foo}", nofix);
@c tex (foo);
@c ===end===
@example
(%i1) nofix ("foo");
(%o1)                          foo
(%i2) texput ("foo", "\\mathsc@{foo@}", nofix);
(%o2)                     \mathsc@{foo@}
(%i3) tex (foo);
$$\mathsc@{foo@}$$
(%o3)                         false
@end example

Assign TeX output for a matchfix operator.

@c ===beg===
@c matchfix ("<<", ">>");
@c texput ("<<", [" \\langle ", " \\rangle "], matchfix);
@c tex (<<a>>);
@c tex (<<a, b>>);
@c texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"], 
@c       matchfix);
@c tex (<<a>>);
@c tex (<<a, b>>);
@c ===end===
@example
(%i1) matchfix ("<<", ">>");
(%o1)                          <<
(%i2) texput ("<<", [" \\langle ", " \\rangle "], matchfix);
(%o2)                [ \langle ,  \rangle ]
(%i3) tex (<<a>>);
$$ \langle a \rangle $$
(%o3)                         false
(%i4) tex (<<a, b>>);
$$ \langle a , b \rangle $$
(%o4)                         false
(%i5) texput ("<<", [" \\langle ", " \\rangle ", " \\, | \\,"],
      matchfix);
(%o5)           [ \langle ,  \rangle ,  \, | \,]
(%i6) tex (<<a>>);
$$ \langle a \rangle $$
(%o6)                         false
(%i7) tex (<<a, b>>);
$$ \langle a \, | \,b \rangle $$
(%o7)                         false
@end example

@opencatbox
@category{TeX output}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{get_tex_environment}
@deffn  {Function} get_tex_environment (@var{op})
@deffnx {Function} set_tex_environment (@var{op}, @var{before}, @var{after})

Customize the TeX environment output by @code{tex}.
As maintained by these functions, the TeX environment comprises two strings:
one is printed before any other TeX output, and the other is printed after.

Only the TeX environment of the top-level operator in an expression
is output; TeX environments associated with other operators are ignored.

@code{get_tex_environment} returns the TeX enviroment which is applied
to the operator @var{op}; returns the default if no other environment
has been assigned.

@code{set_tex_environment} assigns the TeX environment for the operator
@var{op}.

Examples:

@c ===beg===
@c get_tex_environment (":=");
@c tex (f (x) := 1 - x);
@c set_tex_environment (":=", "$$", "$$");
@c tex (f (x) := 1 - x);
@c ===end===
@example
(%i1) get_tex_environment (":=");
(%o1) [
\begin@{verbatim@}
, ;
\end@{verbatim@}
]
(%i2) tex (f (x) := 1 - x);

\begin@{verbatim@}
f(x):=1-x;
\end@{verbatim@}

(%o2)                         false
(%i3) set_tex_environment (":=", "$$", "$$");
(%o3)                       [$$, $$]
(%i4) tex (f (x) := 1 - x);
$$f(x):=1-x$$
(%o4)                         false
@end example

@opencatbox
@category{TeX output}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{get_tex_enviroment_default}
@deffn  {Function} get_tex_environment_default ()
@deffnx {Function} set_tex_environment_default (@var{before}, @var{after})

Customize the TeX environment output by @code{tex}.
As maintained by these functions, the TeX environment comprises two strings:
one is printed before any other TeX output, and the other is printed after.

@code{get_tex_environment_default} returns the TeX environment which is
applied to expressions for which the top-level operator has no
specific TeX environment (as assigned by @code{set_tex_environment}).

@code{set_tex_environment_default} assigns the default TeX environment.

Examples:

@c ===beg===
@c get_tex_environment_default ();
@c tex (f(x) + g(x));
@c set_tex_environment_default ("\\begin{equation}
@c ", "
@c \\end{equation}");
@c tex (f(x) + g(x));
@c ===end===
@example
(%i1) get_tex_environment_default ();
(%o1)                       [$$, $$]
(%i2) tex (f(x) + g(x));
$$g\left(x\right)+f\left(x\right)$$
(%o2)                         false
(%i3) set_tex_environment_default ("\\begin@{equation@}
", "
\\end@{equation@}");
(%o3) [\begin@{equation@}
, 
\end@{equation@}]
(%i4) tex (f(x) + g(x));
\begin@{equation@}
g\left(x\right)+f\left(x\right)
\end@{equation@}
(%o4)                         false
@end example

@opencatbox
@category{TeX output}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION

@c -----------------------------------------------------------------------------
@anchor{system}
@deffn {Function} system (@var{command})

Executes @var{command} as a separate process.  The command is passed to the
default shell for execution.  @code{system} is not supported by all operating
systems, but generally exists in Unix and Unix-like environments.

Supposing @code{_hist.out} is a list of frequencies which you wish to plot as a
bar graph using @code{xgraph}.

@example
(%i1) (with_stdout("_hist.out",
           for i:1 thru length(hist) do (
             print(i,hist[i]))),
       system("xgraph -bar -brw .7 -nl < _hist.out"));
@end example

In order to make the plot be done in the background (returning control to
Maxima) and remove the temporary file after it is done do:

@example
system("(xgraph -bar -brw .7 -nl < _hist.out;  rm -f _hist.out)&")
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{with_stdout}
@deffn  {Function} with_stdout (@var{f}, @var{expr_1}, @var{expr_2}, @var{expr_3}, @dots{})
@deffnx {Function} with_stdout (@var{s}, @var{expr_1}, @var{expr_2}, @var{expr_3}, @dots{})

Evaluates @var{expr_1}, @var{expr_2}, @var{expr_3}, @dots{} and writes any
output thus generated to a file @var{f} or output stream @var{s}.  The evaluated
expressions are not written to the output.  Output may be generated by
@code{print}, @code{display}, @code{grind}, among other functions.

The global flag @code{file_output_append} governs whether @code{with_stdout}
appends or truncates the output file @var{f}.  When @code{file_output_append} is
@code{true}, @code{with_stdout} appends to the output file.  Otherwise,
@code{with_stdout} truncates the output file.  In either case,
@code{with_stdout} creates the file if it does not yet exist.

@code{with_stdout} returns the value of its final argument.

See also @code{writefile}.

@c THIS DOESN'T SEEM VERY IMPORTANT TO MENTION ...
@c Note the binding of display2d to be
@c false, otherwise the printing will have things like "- 3" instead
@c of "-3".
@c
@example
@c THIS EXAMPLE USES SOME UNIX-ISH CONSTRUCTS -- WILL IT WORK IN WINDOWS ???
@c ALSO IT'S SORT OF COMPLICATED AND THE SIMPLER SECOND EXAMPLE ILLUSTRATES with_stdout BETTER !!!
@c mygnuplot (f, var, range, number_ticks) :=
@c  block ([numer:true, display2d:false],
@c  with_stdout("tmp.out",
@c    dx: (range[2]-range[1])/number_ticks,
@c    for x: range[1] thru range[2] step dx
@c       do print (x, at (f, var=x))),
@c  system ("echo \"set data style lines; set title '", f,"' ;plot '/tmp/gnu'
@c ;pause 10 \" | gnuplot"))$
(%i1) with_stdout ("tmp.out", for i:5 thru 10 do
      print (i, "! yields", i!))$
(%i2) printfile ("tmp.out")$
5 ! yields 120 
6 ! yields 720 
7 ! yields 5040 
8 ! yields 40320 
9 ! yields 362880 
10 ! yields 3628800
@end example

@opencatbox
@category{File output}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{writefile}
@deffn {Function} writefile (@var{filename})

Begins writing a transcript of the Maxima session to @var{filename}.
All interaction between the user and Maxima is then recorded in this file,
@c FOLLOWING CLAIM PROBABLY NEEDS TO BE QUALIFIED
just as it appears on the console.

As the transcript is printed in the console output format, it cannot be reloaded
into Maxima.  To make a file containing expressions which can be reloaded,
see @code{save} and @code{stringout}.  @code{save} stores expressions in Lisp
form, while @code{stringout} stores expressions in Maxima form.

The effect of executing @code{writefile} when @var{filename} already exists
depends on the underlying Lisp implementation; the transcript file may be
clobbered, or the file may be appended.  @code{appendfile} always appends to
the transcript file.

It may be convenient to execute @code{playback} after @code{writefile} to save
the display of previous interactions.  As @code{playback} displays only the
input and output variables (@code{%i1}, @code{%o1}, etc.), any output generated
by a print statement in a function (as opposed to a return value) is not
displayed by @code{playback}.

@code{closefile} closes the transcript file opened by @code{writefile} or
@code{appendfile}.

@opencatbox
@category{File output} @category{Console interaction}
@closecatbox
@end deffn

