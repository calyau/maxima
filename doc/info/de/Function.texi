@c Language: German
@c English original: Function.texi CVS 1.42

@menu
* Einführung in Funktionsdefinitionen::  
* Funktionen::                    
* Makros::
* Definitionen für Funktionsdefinitionen::  
@end menu

@node Einführung in Funktionsdefinitionen, Funktionen, , Funktionsdefinitionen
@section Einführung in Funktionsdefinitionen

@node Funktionen, Makros, Einführung in Funktionsdefinitionen, Funktionsdefinitionen
@c NEEDS WORK, THIS TOPIC IS IMPORTANT
@c MENTION DYNAMIC SCOPE (VS LEXICAL SCOPE)
@section Funktionen
@subsection Gewöhnliche Funktionen

Um in Maxima eine Funktion zu definieren, verwendet man 
i.A. den := Operator. Z.B.

@example
f(x) := sin(x)
@end example

@noindent
definiert eine Funktion @code{f}.
Anonyme Funktionen können mit Hilfe von @code{lambda} erzeugt werden. 
Zum Beispiel kann 

@example
lambda ([i, j], ...)
@end example

@noindent
anstelle von @code{f} verwendet werden, wenn 

@example
f(i,j) := block ([], ...);
@end example

Bei gegebener Liste @code{l} würde  

@example
map (lambda ([i], i+1), l)
@end example

@noindent
eine Liste zurückgeben, in der jedes Element mit 1 addiert wurde.

Man kann ebenso eine Funktion mit einer variablen Anzahl an Argumenten definieren.  
Dem abschließenden Argument wird auf diese Weise eine Liste mit den 
zusätzlichen Argumenten zugewiesen:

@example
(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
@end example

Die rechte Seite einer Funktionsdefinition ist ein Ausdruck. 
Möchte man eine Folge von Ausdrücken verwenden, gibt man 

@example
f(x) := (expr1, expr2, ...., exprn);
@end example

ein. Der Wert von @var{exprn} ist dann der Rückgabewert der Funktion.

Will man von einem Ausdruck innerhalb der Funktion aus einen Rücksprung erzeugen, 
muss man @code{block} und @code{return} verwenden.

@example
block ([], expr1, ..., if (a > 10) then return(a), ..., exprn)
@end example

ist selbst ein Ausdruck, kann also als rechte Seite einer Funktionsdefinition 
dienen. 
In diesem Beispiel kann es vorkommen, dass der Rücksprung vor der Auswertung 
des letzten Ausdrucks stattfindet.

@c COPY THIS STUFF TO @defun block AS NEEDED
@c ESPECIALLY STUFF ABOUT LOCAL VARIABLES
Die erste @code{[]} in einem @code{block} kann eine Reihe von 
Variablen und Variablenzuweisungen enthalten, so wie @code{[a: 3, b, c: []]}, 
was bewirken würde, dass sich die drei Variablen @code{a}, @code{b} 
und @code{c} nicht auf ihre globalen Werte beziehen (sollte es diese geben), 
sondern spezielle Werte besitzen, solange der Code innerhalb des @code{block} 
oder innerhalb von Funktionen, die innerhalb des @code{block} aufgerufen werden, 
ausgeführt wird. Man nennt dies @i{dynamische} Bindung, 
da die Variablen nur vom Beginn bis zum Zeitpunkt des Endes des @code{block} 
bestehen. 
Im Falle eines @code{return} oder @code{throw} aus dem @code{block} 
werden die alten Werte der Variablen (sollte es diese geben) wieder eingesetzt.
Es ist sicherlich eine gute Idee, auf diese Weise Variablen zu schützen. 
Beachte, dass Zuweisungen an die Blockvariablen parallel vorgenommen werden. 
Das bedeutet, dass wenn man oben noch @code{c: a} verwendet hätte, der 
Wert von @code{c} der Wert von @code{a} zum Zeitpunkt des Blockbeginns 
sein würde, bevor also @code{a} gebunden wurde. 
So etwas wie 

@example
block ([a: a], expr1, ... a: a+3, ..., exprn)
@end example

wird demnach den externen Wert von @code{a} davor bewahren, 
verändert zu werden, aber erlaubt, diesen Wert zu verwenden.
Dies geschieht, da die rechte Seite der Zuweisungen erst im 
Eingangszusammenhang ausgewertet wird, bevor die Bindung stattfindet.
Einfach @code{block ([x], ...} zu verwenden, würde bewirken, dass
@code{x} sich selbst als Wert hat, gerade so als hätte man eine neue
@b{Maxima} Sitzung begonnen.

Die aktuellen Argumente einer Funktion werden in exakt derselben Weise 
behandelt, wie Variablen in einem Block. So hätten wir in

@example
f(x) := (expr1, ..., exprn);
@end example

und

@example
f(1);
@end example

den gleichen Auswertungszusammenhang für die Ausdrücke wie mit

@example
block ([x: 1], expr1, ..., exprn)
@end example

Da bei einer Funktionsdefinition mit := die rechte Seite erst 
zur Laufzeit ausgewertet wird, ist es manchmal ratsam, 
@code{define} oder eventuell auch @code{buildq} zur 
Definition einer Funktion zu verwenden.  

@subsection Array-Funktionen

Eine Array-Funktion speichert bei einem gegebenen Argument 
den Funktionswert beim ersten Aufruf,  
und gibt bei erneutem Aufruf mit dem gleichen Argument 
den gespeicherten Wert zurück, ohne ihn neu zu berechnen. 
So eine Funktion wird tabellenführend (@i{memoizing function}) genannt.

Die Namen der Array-Funktionen werden der globalen Liste 
@code{arrays} hinzugefügt (und nicht der globalen Liste 
@code{functions}).
@code{arrayinfo} gibt die Liste der Argumente zurück, für 
die es gespeicherte Funktionswerte gibt.
@code{dispfun} und @code{fundef} geben die Definition der 
Array-Funktion zurück.

@code{arraymake} erzeugt den Aufruf einer Array-Funktion, 
analog zum Aufruf von @code{funmake} bei gewöhnlichen Funktionen. 
@code{arrayapply} wendet eine Array-Funktion auf seine Argumente an, 
so wie @code{apply} bei gewöhnlichen Funktionen. 
Es gibt jedoch nicht exakt analoges zu @code{map} für 
Array-Funktionen, obwohl 
@code{map(lambda([@var{x}], @var{a}[@var{x}]), @var{L})} oder
@code{makelist(@var{a}[@var{x}], @var{x}, @var{L})}, wobei @var{L} 
eine Liste ist, nicht weit davon entfernt sind.

@code{remarray} entfernt die Definition einer Array-Funktion 
(einschließlich der gespeicherten Werte), genauso wie 
@code{remfunction} bei gewöhnlichen Funktionen. 

@code{kill(@var{a}[@var{x}])} entfernt den für das Argument 
@var{x} gespeicherten Wert einer Array-Funktion @var{a}; 
beim nächsten Aufruf von @var{a} mit dem Argument @var{x} 
wird der Funktionswert neu berechnet.
Es gibt jedoch keine Möglichkeit, auf einmal alle gespeicherten 
Werte zu löschen, außer durch @code{kill(@var{a})} oder 
@code{remarray(@var{a})}, was gleichzeitig die Funktionsdefinition 
löscht.


@node Makros, Definitionen für Funktionsdefinitionen, Funktionen, Funktionsdefinitionen
@section Makros

@deffn {Funktion} buildq (@var{L}, @var{expr})
Führt eine parallele Ersetzung der in der Liste @var{L} 
aufgeführten Variablen in dem Ausdruck @var{expr} durch, 
ohne dabei @var{expr} auszuwerten.

Der resultierende Ausdruck wird vereinfacht, aber nicht 
ausgewertet, nachdem @code{buildq} die Ersetzung durchgeführt hat.

Die Elemente in @var{L} sind Symbole oder Zuweisungen 
@code{@var{symbol}: @var{value}}, die parallel ausgewertet werden.

Die Bindung der Variablen auf der rechten Seite der Zuweisung 
ist die Bindung dieser Variablen in dem Zusammenhang, 
in dem @code{buildq} aufgerufen wird, und 
nicht die Bindung dieser Variablen in der Liste @var{L}.
Wenn einer Variable in @var{L} nicht ausdrücklich ein Wert 
zugewiesen wurde, ist seine Bindung in @code{buildq} dieselbe, 
wie in dem Zusammenhang, aus dem @code{buildq} aufgerufen wird.

Die in @var{L} genannten Variablen werden dann parallel in 
@var{expr} ersetzt. Das heißt, die Ersetzung ist für jede 
Variable festgelegt, bevor die Ersetzung ausgeführt wird, 
so dass die Ersetzung einer Variable auf die andere keinen 
Einfluss hat.

Wenn irgend eine Variable @var{x} in @var{expr} in der Form 
@code{splice (@var{x})} auftritt, dann muss @var{x} an eine Liste 
gebunden sein, und die Liste wird dann in @var{expr} 
verzahnt statt ersetzt.

Variablen in @var{expr}, die nicht in @var{L} auftauchen, 
werden in das Ergebnis wörtlich eingetragen, so als ob sie 
in dem Zusammenhang, aus dem @code{buildq} aufgerufen wird, 
gebunden wären.

Beispiele

@code{a} ist ausdrücklich an @code{x} gebunden,
während @code{b} dieselbe Bindung hat (nämlich 29) wie 
in dem aufrufenden Zusammenhang, 
und @code{c} wird wörtlich übertagen.
Der resultierende Ausdruck wird nicht vor der ausdrücklichen 
Auswertung @code{''%} ausgewertet.

@c ===beg===
@c (a: 17, b: 29, c: 1729)$
@c buildq ([a: x, b], a + b + c);
@c ''%;
@c ===end===
@example
(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
@end example

@code{e} ist an eine Liste gebunden, die als solche auch 
in den Argumenten von @code{foo} auftaucht, aber 
verzahnt in den Argumenten von @code{bar}.

@c ===beg===
@c buildq ([e: [a, b, c]], foo (x, e, y));
@c buildq ([e: [a, b, c]], bar (x, splice (e), y));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
@end example

Das Ergebnis wird nach der Ersetzung vereinfacht.
Würde die Vereinfachung vor der Ersetzung stattfinden,
würden diese beiden Ausdrücke dasselbe ergeben.

@c ===beg===
@c buildq ([e: [a, b, c]], splice (e) + splice (e));
@c buildq ([e: [a, b, c]], 2 * splice (e));
@c ===end===
@example
(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
@end example

Die Variablen in @var{L} sind parallel gebunden; 
wären sie nacheinander gebunden, würde das erste 
Ergebnis @code{foo (b, b)} sein.
Auch die Ersetzungen werden parallel ausgeführt;
vergleiche das zweite Ergebnis mit dem von @code{subst},
welches die Ersetzungen nacheinander ausführt.

@c ===beg===
@c buildq ([a: b, b: a], foo (a, b));
@c buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
@c subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
@c ===end===
@example
(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u], bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u], bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
@end example

Folgend wird eine Liste von Gleichungen konstruiert, 
mit jeweils Variablen oder Ausdrücken auf der linken Seite  
und deren Werte auf der rechten.
@code{macroexpand} zeigt den Rückgabewert von @code{show_values}.

@c ===beg===
@c show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
@c (a: 17, b: 29, c: 1729)$
@c show_values (a, b, c - a - b);
@c macroexpand (show_values (a, b, c - a - b));
@c ===end===
@example
(%i1) show_values ([L]) ::= buildq ([L], map ("=", 'L, L));
(%o1)   show_values([L]) ::= buildq([L], map("=", 'L, L))
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)          [a = 17, b = 29, c - b - a = 1683]
(%i4) macroexpand (show_values (a, b, c - a - b));
(%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])
@end example

@end deffn

@deffn {Funktion} macroexpand (@var{expr})
Gibt, wenn @code{expr} ein Makro-Funktionsaufruf ist,
die Makro-Expansion von @var{expr} zurück, ohne den 
Ausdruck dabei auszuwerten.
Andernfalls gibt @code{macroexpand} @var{expr} zurück.

Sollte die Expansion von @var{expr} einen weiteren 
Makro-Funktionsaufruf liefern, wird auch dieser 
Makro-Funktionsaufruf expandiert.

@code{macroexpand} quotiert (Operator @code{'}) seine Argumente.
Wenn jedoch die Expansion der Makrofunktion Seiteneffekte 
bewirkt, werden auch diese Seiteneffekte ausgeführt.

Siehe auch @code{::=}, @code{macros} und @code{macroexpand1}.

Beispiele

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@end deffn

@deffn {Funktion} macroexpand1 (@var{expr})
Gibt, wenn @code{expr} ein Makro-Funktionsaufruf ist,
die Makro-Expansion von @var{expr} zurück, ohne den 
Ausdruck dabei auszuwerten.
Andernfalls gibt @code{macroexpand1} @var{expr} zurück.

@code{macroexpand1} quotiert (Operator @code{'}) seine Argumente.
Sollte die Expansion der Makrofunktion Seiteneffekte 
bewirken, werden auch diese Seiteneffekte ausgeführt.

Sollte die Expansion von @var{expr} einen weiteren 
Makro-Funktionsaufruf liefern, wird dieser Makro-Funktionsaufruf 
jedoch nicht expandiert.

Siehe auch @code{::=}, @code{macros} und @code{macroexpand}.

Beispiele

@c ===beg===
@c g (x) ::= x / 99;
@c h (x) ::= buildq ([x], g (x - a));
@c a: 1234;
@c macroexpand1 (h (y));
@c h (y);
@c ===end===
@example
(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
@end example

@end deffn

@defvr {Globale Variable} macros
Standardwert: @code{[]}

@code{macros} ist die Liste der benutzerdefinierten Makrofunktionen. 
Der Operator @code{::=} zur Markodefinition setzt neue Makrofunktionen 
auf diese Liste und @code{kill}, @code{remove} und @code{remfunction} 
entfernen Makrofunktionen von dieser Liste.

Siehe auch @code{infolists}.

@end defvr

@deffn {Funktion} splice (@var{a})
Verzahnt die durch das Atom @var{a} benannte Liste in einen Ausdruck, 
aber nur dann, wenn @code{splice} innerhalb von @code{buildq} auftritt; 
andernfalls wird @code{splice} wie eine undefinierte Funktion behandelt. 
Tritt @var{a} innerhalb von @code{buildq} allein auf (ohne @code{splice}), 
dann wird @var{a} als Liste (und nicht verzahnt) in das Ergebnis eingesetzt. 
Das Argument von @code{splice} darf nur ein Atom sein, 
keine buchstäbliche Liste oder auch kein Ausdruck, der eine Liste 
ergibt.

Typischerweise liefert @code{splice} die Argumente für eine Funktion 
oder einen Operator.
Für eine Funktion @code{f} expandiert der Ausdruck @code{f (splice (@var{a}))} 
innerhalb von @code{buildq} zu @code{f (@var{a}[1], @var{a}[2], @var{a}[3], ...)}. 
Für einen Operator @code{o} expandiert der Ausdruck @code{"o" (splice (@var{a})}
innerhalb von @code{buildq} zu @code{"o" (@var{a}[1], @var{a}[2], @var{a}[3], ...)},
wobei @code{o} jeder Typ von Operator sein kann 
(typischerweise einer, der mehrere Argumente besitzt). 
Beachte, dass der Operator in Anführungszeichen @code{"} eingeschlossen 
sein muss.

Beispiele

@c ===beg===
@c buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
@c buildq ([x: [1, %pi]], "/" (splice (x)));
@c matchfix ("<>", "<>");
@c buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
@c ===end===
@example
(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], "/" (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix ("<>", "<>");
(%o3)                          <>
(%i4) buildq ([x: [1, %pi, z - y]], "<>" (splice (x)));
(%o4)                   <>1, %pi, z - y<>
@end example

@end deffn


@c end concepts Funktionen
@node Definitionen für Funktionsdefinitionen,  , Makros, Funktionsdefinitionen
@section Definitionen für Funktionsdefinitionen

@deffn {Funktion} apply (@var{F}, [@var{x_1}, ..., @var{x_n}])
Erzeugt einen Ausdruck @code{@var{F}(@var{arg_1}, ..., @var{arg_n})} 
und wertet ihn aus.
@code{apply} versucht nicht, zwischen Array-Funktion und gewöhnlichen Funktionen 
zu unterscheiden; 
wenn @var{F} der Name einer Array-Funktion ist, wertet @code{apply} 
@code{@var{F}(...)} aus (d.h. ein Funktionsaufruf mit runden statt 
eckigen Klammern).
@code{arrayapply} wertet in diesem Fall einen Funktionsaufruf mit 
eckigen Klammern aus.

Beispiele:

@code{apply} wertet seine Argumente aus.
In diesem Beispiel wird @code{min} auf den Wert von @code{L} angewendet.

@c ===beg===
@c L : [1, 5, -10.2, 4, 3];
@c apply (min, L);
@c ===end===
@example
(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
@end example

@code{apply} wertet die Argumente aus, sogar wenn die Funktion 
(hier @var{dispfun}) sie quotiert (Operator @code{'}).

@c ===beg===
@c F (x) := x / 1729;
@c fname : F;
@c dispfun (F);
@c dispfun (fname);
@c apply (dispfun, [fname]);
@c ===end===
@example
(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729

(%o5)                         [%t5]
@end example

@code{apply} wertet den Funktionsnamen (hier @var{demoivre}) aus.
Das einfache Hochkomma @code{'} verhindert die Auswertung.
@code{demoivre} ist der Name einer globalen Variable und ebenso eine Funktion.

@c ===beg===
@c demoivre;
@c demoivre (exp (%i * x));
@c apply (demoivre, [exp (%i * x)]);
@c apply ('demoivre, [exp (%i * x)]);
@c ===end===
@example
(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
@end example

@end deffn


@deffn {Funktion} block ([@var{v_1}, ..., @var{v_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Funktion} block (@var{expr_1}, ..., @var{expr_n})
@code{block} wertet @var{expr_1}, ..., @var{expr_n} der Reihe nach aus 
und gibt den Wert des letzten ausgewerteten Ausdrucks zurück. 
Die Abfolge kann durch die @code{go}-, @code{throw}- und @code{return}-Funktion 
geändert werden. 
Der letzte Ausdruck ist @var{expr_n}, wenn nicht @code{return} 
oder ein Ausdruck, der  @code{throw} enthält, ausgewertet wird.
Die Variablen @var{v_1}, ..., @var{v_m} werden lokal im Block deklariert 
und damit unterschieden von globalen Variablen mit demselben Namen. 
Sollen keine Variablen lokal deklariert werden, kann die Liste entfallen. 
Innerhalb des Blocks ist jede von @var{v_1}, ..., @var{v_m} verschiedene 
Variable global. 

@code{block} speichert beim Eintritt in den Block die aktuellen Werte der 
Variablen @var{v_1}, ..., @var{v_m} (falls vorhanden), und entbindet dann die 
Variablen, so dass diese sich selbst als Wert besitzen. 
Die lokalen Variablen können anschließend innerhalb des Blocks an beliebige 
Werte gebunden werden, nach Beenden des Blocks aber werden die zuvor 
gespeicherten Werte zurückgeschrieben und die innerhalb des Blocks 
zugewiesenen Werte sind verloren. 

@code{block} kann in einem anderen @code{block} auftreten.
Jedesmal wenn ein neuer @code{block} ausgewertet wird, 
werden entsprechende lokalen Variablen eingerichtet. 
Lokale Variablen erscheinen jedem eingeschlossenen Block als global. 
Ist eine Variable nichtlokal in einem Block, 
ist ihr Wert gegebenenfalls der durch einen umgebenden Block 
zuletzt zugewiesene oder andernfalls der Wert in der globalen Umgebung. 
Dieses Prinzip stimmt wohl mit dem üblichen Verständnis eines 
dynamischen Gültigkeitsbereichs ("dynamic scope") überein.

Wenn es gewünscht wird, neben @code{value} auch andere lokale Eigenschaften 
(@code{properties}) zu speichern und wiederherzustellen, wie zum Beispiel 
@code{array} (außer für vollständige Arrays),
@code{function}, @code{dependencies}, @code{atvalue}, 
@code{matchdeclare}, @code{atomgrad}, @code{constant} und @code{nonscalar}, 
sollte innerhalb eines Blocks die Funktion @code{local} mit den Namen der 
Variablen als Argumente verwendet werden.

Der Wert eines Blocks ist der Wert seines letzten Ausdrucks 
oder der Wert des Arguments der Funktion @code{return}, 
die verwendet werden kann, um ausdrücklich einen Programmblock
zu verlassen.
Die Funktion @code{go} kann in einem @code{block} verwendet werden, 
um die Programmkontrolle an eine Anweisung zu übergeben, 
die mit dem Argument von @code{go} markiert ist. 
Um eine Anweisung zu markieren, stellt man ihr ein Atom als eine
zusätzliche Anweisung in @code{block} voran. Zum Beispiel:
@code{block ([x], x:1, loop, x+1, ..., go(loop), ...)}
Das Argument von @code{go} muss der Name einer Marke ("tag") sein, die im gleichen
@code{block} steht. Man kann @code{go} nicht verwenden, um eine Marke
in einem anderen @code{block} zu erreichen als den, der dieses @code{go}
enthält.

Blocks tauchen typischerweise auf der rechten Seite einer Funktionsdefinition 
auf, können aber genauso gut an anderen Stellen verwendet werden.

@end deffn

@c REPHRASE, NEEDS EXAMPLE
@deffn {Funktion} break (@var{expr_1}, ..., @var{expr_n})
Wertet und gibt @var{expr_1}, ..., @var{expr_n} aus 
und bewirkt dann eine Maxima-Bruch-Anweisung an einem Punkt, 
an dem der Benutzer seine Umgebung untersuchen und ändern kann. 
Nach der Eingabe von @code{exit;} fährt die Rechnung wieder fort.

@end deffn

@c FOR SOME REASON throw IS IN SOME OTHER FILE. MOVE throw INTO THIS FILE.
@c NEEDS CLARIFICATION
@deffn {Funktion} catch (@var{expr_1}, ..., @var{expr_n})
Wertet die Ausdrücke @var{expr_1}, ..., @var{expr_n} nacheinander aus; 
wenn ein davon zur Auswertung eines Ausdrucks der Form @code{throw (arg)}
führt, dann ist der Wert des @code{catch} der Wert des @code{throw (arg)}, 
und kein weiterer Ausdruck wird ausgewertet.
Dieser nichtlokale Rücksprung geht durch jede Verschachtelungstiefe 
bis zum nächsten umgebenden @code{catch}.
Gibt es kein @code{catch}, das @code{throw} umgibt, wird eine 
Fehlermeldung ausgegeben.

Wenn die Auswertung der Argumente nicht zu der Auswertung eines @code{throw} 
führt, ist der Wert von @var{catch} der Wert von @code{expr_n}. 

@example
(%i1) lambda ([x], if x < 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
@end example

@c REWORD THIS PART.
Die Funktion @code{g} gibt eine Liste von Elementen der Liste @code{l} 
zurück, auf die eine Funktion @code{f} angewandt wurde, falls alle Elemente 
nichtnegativ sind, andernfalls fängt ("catches") @code{g} das 
erste negative Element von @code{l} auf und wirft ("throws") es aus.

@end deffn

@deffn {Funktion} compfile (@var{filename}, @var{f_1}, ..., @var{f_n})
Übersetzt Maxima-Funktionen @var{f_1}, ..., @var{f_n} nach Lisp 
und schreibt den übersetzten Code in die Datei @var{filename}.

Die Lisp-Übersetzungen werden weder ausgewertet, noch wird die Datei 
durch den Lisp-Compiler weiterverarbeitet.
@c SO LET'S CONSIDER GIVING THIS FUNCTION A MORE ACCURATE NAME.
@code{translate} erzeugt und wertet Lisp-Übersetzungen aus.
@code{compile_file} übersetzt von Maxima nach Lisp, und wendet dann den 
Lisp-Compiler an.


Siehe auch @code{translate}, @code{translate_file} und @code{compile_file}.

@end deffn

@c THIS VARIABLE IS OBSOLETE: ASSIGNING compgrind: true CAUSES compfile
@c TO EVENTUALLY CALL AN OBSOLETE FUNCTION SPRIN1.
@c RECOMMENDATION IS TO CUT THIS ITEM, AND CUT $compgrind FROM src/transs.lisp
@c @defvar compgrind
@c Default value: @code{false}
@c 
@c When @code{compgrind} is @code{true}, function definitions printed by
@c @code{compfile} are pretty-printed.
@c 
@c @end defvar

@deffn {Funktion} compile (@var{f_1}, ..., @var{f_n})
@deffnx {Funktion} compile (functions)
@deffnx {Funktion} compile (all)
Übersetzt Maxima-Funktionen @var{f_1}, ..., @var{f_n} nach Lisp, 
wertet die Lisp-Übersetzungen aus und ruft für jede übersetzte Funktion 
die Lisp-Funktion @code{COMPILE} auf.
@code{compile} gibt eine Liste mit den Namen der kompilierten Funktionen zurück. 

@code{compile (all)} oder @code{compile (functions)} kompiliert 
alle benutzerdefinierten Funktionen.

@code{compile} quotiert (Operator @code{'}) seine Argumente;
Der Quotierungs-Quotierungs-Operator @code{'@w{}'} verhindert die Quotierung.

@end deffn

@deffn {Funktion} define (@var{f}(@var{x_1}, ..., @var{x_n}), @var{expr})
Definiert eine Funktion namens @var{f} mit den Argumenten @var{x_1}, ..., @var{x_n} 
und dem Funktionsrumpf @var{expr}.

@code{define} quotiert (Operator @code{'}) in den meisten Fällen 
das erste Argument und wertet das zweites Argument aus, 
wenn dies nicht ausdrücklich quotiert ist. 
Wenn das erste Argument ein Ausdruck der Form 
@code{ev (@var{expr})}, @code{funmake (@var{expr})} oder @code{arraymake (@var{expr})} 
ist, wird das erste Argument ausgewertet;
dies erlaubt es, den Funktionsnamen genauso wie den Rumpf auszuwerten.

@code{define} ist vergleichbar mit dem Funktionsdefinitionsoperator @code{:=},
wenn aber @code{define} innerhalb einer Funktion auftaucht, 
verwendet die erzeugte Definition den Wert von @code{expr} zur Laufzeit und 
nicht den Wert zum Zeitpunkt der Definition der Funktion, 
die dieses @code{define} enthält.

Alle Funktionsdefinitionen finden in demselben Namensraum statt;
die Definition einer Funktion @code{f} innerhalb einer anderen 
Funktion @code{g} beschränkt nicht den Gültigkeitsbereich von 
@code{f} in Beziehung zu @code{g}.

@c MAKE THIS SAME POINT IN :=
@code{define} definiert Arrayfunktionen 
(aufgerufen mit Argumenten in eckigen Klammern @code{[ ]})
genauso wie gewöhnliche Funktionen.

Beispiele:

@example
(%i1) foo: 2^bar;
                               bar
(%o1)                         2
(%i2) g(x) := (f_1 (y) :=   foo*x*y,
               f_2 (y) := ''foo*x*y,
       define (f_3 (y),     foo*x*y),
       define (f_4 (y),   ''foo*x*y));
                                             bar
(%o2) g(x) := (f_1(y) := foo x y, f_2(y) := 2    x y, 
                                                        bar
               define(f_3(y), foo x y), define(f_4(y), 2    x y))
(%i3) functions;
(%o3)                        [g(x)]
(%i4) g(a);
                                    bar
(%o4)                  f_4(y) := a 2    y
(%i5) functions;
(%o5)        [g(x), f_1(y), f_2(y), f_3(y), f_4(y)]
(%i6) dispfun (f_1, f_2, f_3, f_4);
(%t6)                   f_1(y) := foo x y

                                  bar
(%t7)                  f_2(y) := 2    x y

                                    bar
(%t8)                  f_3(y) := a 2    y

                                    bar
(%t9)                  f_4(y) := a 2    y

(%o9)                         done
@end example
@end deffn

@c SEE NOTE BELOW ABOUT THE DOCUMENTATION STRING
@c @deffn {Funktion} define_variable (@var{name}, @var{default_value}, @var{mode}, @var{documentation})
@deffn {Funktion} define_variable (@var{name}, @var{default_value}, @var{mode})

Führt eine globale Variable in die Maxima-Umgebung ein.
@c IMPORT OF FOLLOWING STATEMENT UNCLEAR: IN WHAT WAY IS define_variable MORE USEFUL IN TRANSLATED CODE ??
@code{define_variable} ist nützlich in benutzerdefinierten Paketen,
die oft übersetzt oder kompiliert werden.

@code{define_variable} führt die folgenden Schritte durch:

@enumerate
@item
@code{mode_declare (@var{name}, @var{mode})} deklariert dem Übersetzer 
den Modus (@var{mode}) von @var{name}.
Siehe @code{mode_declare} für eine Liste der möglichen Modi.

@item
Ist die Variable ungebunden, wird @var{default_value} @var{name} zugewiesen.

@item
@code{declare (@var{name}, special)} deklariert sie als speziell (Lisp: "special"). 
@c CLARIFY THE MEANING OF SPECIAL FOR THE BENEFIT OF READERS OTHER THAN LISP PROGRAMMERS

@item
@var{name} wird einer Testfunktion zugeordnet, um sicherzustellen, 
dass @var{name} nur Werte im deklarierten Modus zugewiesen werden.
@end enumerate


@c FOLLOWING STATEMENT APPEARS TO BE OUT OF DATE.
@c EXAMINING DEFMSPEC $DEFINE_VARIABLE AND DEF%TR $DEFINE_VARIABLE IN src/trmode.lisp,
@c IT APPEARS THAT THE 4TH ARGUMENT IS NEVER REFERRED TO.
@c EXECUTING translate_file ON A MAXIMA BATCH FILE WHICH CONTAINS
@c define_variable (foo, 2222, integer, "THIS IS FOO");
@c DOES NOT PUT "THIS IS FOO" INTO THE LISP FILE NOR THE UNLISP FILE.
@c The optional 4th argument is a documentation string.  When
@c @code{translate_file} is used on a package which includes documentation
@c strings, a second file is output in addition to the Lisp file which
@c will contain the documentation strings, formatted suitably for use in
@c manuals, usage files, or (for instance) @code{describe}.

Die Eigenschaft @code{value_check} kann jeder Variablen zugewiesen werden, 
die durch @code{define_variable} mit einem von @code{any} verschiedenen Modus 
definiert wurde.
Die Eigenschaft @code{value_check} ist ein lambda-Ausdruck oder 
der Name einer Funktion mit einer Variablen, der aufgerufen wird, 
wenn versucht wird, der Variablen einen Wert zuzuweisen.
Das Argument der @code{value_check}-Funktion ist dieser beabsichtigte Wert.

@code{define_variable} wertet @code{default_value} aus 
und quotiert (Operator @code{'}) @code{name} und @code{mode}.
@code{define_variable} gibt den aktuellen Wert von @code{name} zurück, 
der @code{default_value} ist, wenn @code{name} vorher ungebunden war, 
oder andernfalls der vorherige Wert von @code{name}.

Beispiele:

@code{foo} ist eine boolesche Variable mit dem anfänglichen Wert @code{true}.
@c GENERATED FROM:
@c define_variable (foo, true, boolean);
@c foo;
@c foo: false;
@c foo: %pi;
@c foo;

@example
(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
@end example

@code{bar} ist eine ganzzahlige Variable, die prim sein soll.
@c GENERATED FROM:
@c define_variable (bar, 2, integer);
@c qput (bar, prime_test, value_check);
@c prime_test (y) := if not primep(y) then error (y, "is not prime.");
@c bar: 1439;
@c bar: 1440;
@c bar;

@example
(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then error (y, "is not prime.");
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, "is not prime.")
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 is not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
@end example

@code{baz_quux} ist eine Variable, der kein Wert zugewiesen werden kann.
Der Modus @code{any_check} ist @code{any} ähnlich, 
@code{any_check} ermöglicht jedoch den @code{value_check}-Mechanismus, 
während @code{any} dies nicht tut.
@c GENERATED FROM:
@c define_variable (baz_quux, 'baz_quux, any_check);
@c F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
@c qput (baz_quux, ''F, value_check);
@c baz_quux: 'baz_quux;
@c baz_quux: sqrt(2);
@c baz_quux;

@example
(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then error ("Cannot assign to `baz_quux'."));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then error("Cannot assign to `baz_quux'."))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
@end example

@end deffn

@deffn {Funktion} dispfun (@var{f_1}, ..., @var{f_n})
@deffnx {Funktion} dispfun (all)
Zeigt die Definitionen der benutzerdefinierten Funktionen @var{f_1}, ..., @var{f_n} an.
Jedes Argument kann der Name eines Makros (definiert durch @code{::=}) sein, 
einer gewöhnlichen Funktion (definiert durch @code{:=} oder @code{define}), 
einer Arrayfunktion (definiert durch @code{:=} oder @code{define}, 
aber mit Argumenten, die in eckigen Klammern @code{[ ]} eingeschlossen sind),
einer indizierten Funktion, (definiert durch @code{:=} oder @code{define}, 
aber mit einigen Argumenten in eckigen Klammern @code{[ ]} 
und anderen in runden Klammern @code{( )}),
einer, die durch einen bestimmten Index aus einer Familie von 
indizierten Funktionen ausgewählt wurde, 
oder einer indizierten Funktion mit einem konstanten Index.

@code{dispfun (all)} zeigt alle benutzerdefinierten Funktionen an, die 
durch die @code{functions}-, @code{arrays}-, and @code{macros}-Listen 
gegeben sind, lässt aber indizierte Funktionen mit konstanten Indizes aus.

@code{dispfun} erzeugt Zwischenmarken (@code{%t1}, @code{%t2}, etc.)
für jede angezeigte Funktion, und weist die Funktionsdefinition den Marken zu.
Im Unterschied hierzu gibt @code{fundef} die Funktionsdefinitionen zurück.

@code{dispfun} quotiert (Operator @code{'}) seine Argumente;
Der Quotierungs-Quotierungs-Operator @code{'@w{}'} verhindert die Quotierung.
@code{dispfun} gibt die Liste mit den Zwischenmarken zurück, 
die den angezeigten Funktionen entsprechen. 

Beispiele:

@c ===beg===
@c m(x, y) ::= x^(-y);
@c f(x, y) :=  x^(-y);
@c g[x, y] :=  x^(-y);
@c h[x](y) :=  x^(-y);
@c i[8](y) :=  8^(-y);
@c dispfun (m, f, g, h, h[5], h[10], i[8]);
@c ''%;
@c ===end===
@example
(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x

                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   , 
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
@end example

@end deffn

@defvr {Systemvariable} functions
Standardwert: @code{[]}

@code{functions} ist die Liste der gewöhnlichen Maxima-Funktionen 
der laufenden Sitzung.
Eine gewöhnliche Funktion ist eine Funktion, die mit Hilfe von 
@code{define} oder @code{:=} konstruiert wurde und mitsamt der 
Klammern @code{()} aufgerufen wird.
Eine Funktion kann in der Eingabezeile definiert werden 
oder in einer Maxima-Datei, die durch @code{load} oder @code{batch} 
geladen wird.

Arrayfunktionen (aufgerufen mit eckigen Klammern, i.A. @code{F[x]}) 
und indizierte Funktionen (aufgerufen mit eckigen und runden Klammern, 
i.A. @code{F[x](y)}) werden durch die globale Variable @code{arrays}, 
und nicht durch @code{functions} aufgelistet.

Lisp-Funktionen werden in keiner dieser Liste aufgeführt.

Beispiele:

@c ===beg===
@c F_1 (x) := x - 100;
@c F_2 (x, y) := x / y;
@c define (F_3 (x), sqrt (x));
@c G_1 [x] := x - 100;
@c G_2 [x, y] := x / y;
@c define (G_3 [x], sqrt (x));
@c H_1 [x] (y) := x^y;
@c functions;
@c arrays;
@c ===end===
@example
(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
@end example

@end defvr

@deffn {Funktion} fundef (@var{f})
Gibt die Definition der Funktion @var{f} zurück.

@c PROBABLY THIS WOULD BE CLEARER AS A BULLET LIST
Das Argument kann der Name eines Makros (definiert durch @code{::=}) sein, 
einer gewöhnlichen Funktion (definiert durch @code{:=} oder @code{define}), 
einer Arrayfunktion (definiert durch @code{:=} oder @code{define}, 
aber mit Argumenten, die in eckigen Klammern @code{[ ]} eingeschlossen sind),
einer indizierten Funktion, (definiert durch @code{:=} oder @code{define}, 
aber mit einigen Argumenten in eckigen Klammern @code{[ ]} 
und anderen in runden Klammern @code{( )}),
einer, die durch einen bestimmten Index aus einer Familie von 
indizierten Funktionen ausgewählt wurde, 
oder einer indizierten Funktion mit einem konstanten Index.

@code{fundef} quotiert (Operator @code{'}) seine Argumente;
Der Quotierungs-Quotierungs-Operator @code{'@w{}'} verhindert die Quotierung.

@code{fundef (@var{f})} gibt die Definition von @var{f} zurück.
Im Unterschied hierzu erzeugt @code{dispfun (@var{f})} Zwischenmarken (@code{%t1}, @code{%t2}, ...)
und weist die Definition den Marken zu.

@c PROBABLY NEED SOME EXAMPLES HERE
@end deffn

@deffn {Funktion} funmake (@var{F}, [@var{arg_1}, ..., @var{arg_n}])
Gibt einen Ausdruck @code{@var{F}(@var{arg_1}, ..., @var{arg_n})} zurück. 
Der Rückgabewert wird vereinfacht, aber nicht ausgewertet, 
so dass die Funktion @var{F} nicht aufgerufen wird, selbst wenn sie existiert.

@code{funmake} versucht nicht zwischen Arrayfunktionen und gewöhnlichen Funktionen 
zu unterscheiden; wenn @var{F} der Name einer Arrayfunktion ist, 
gibt @code{funmake} @code{@var{F}(...)} zurück 
(d.h. einen Funktionsaufruf mit runden statt eckigen Klammern).
@code{arraymake} gibt in diesem Fall einen Funktionsaufruf mit 
eckigen Klammern zurück. 

@code{funmake} wertet seine Argumente aus.

Beispiele:

@code{funmake} angewandt auf eine gewöhnliche Maxima-Funktion.

@c ===beg===
@c F (x, y) := y^2 - x^2;
@c funmake (F, [a + 1, b + 1]);
@c ''%;
@c ===end===
@example
(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
@end example

@code{funmake} angewandt auf ein Makro.

@c ===beg===
@c G (x) ::= (x - 1)/2;
@c funmake (G, [u]);
@c ''%;
@c ===end===
@example
(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
@end example

@code{funmake} angewandt auf eine indizierte Funktion.

@c ===beg===
@c H [a] (x) := (x - 1)^a;
@c funmake (H [n], [%e]);
@c ''%;
@c funmake ('(H [n]), [%e]);
@c ''%;
@c ===end===
@example
(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
@end example

@code{funmake} angewandt auf ein Symbol, dass nicht als Funktion 
irgendeiner Art definiert wurde.

@c ===beg===
@c funmake (A, [u]);
@c ''%;
@c ===end===
@example
(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
@end example

@code{funmake} wertet seine Argumente aus, aber nicht seinen Rückgabewert.

@c ===beg===
@c det(a,b,c) := b^2 -4*a*c;
@c (x : 8, y : 10, z : 12);
@c f : det;
@c funmake (f, [x, y, z]);
@c ''%;
@c ===end===
@example
(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
@end example

Maxima vereinfacht @code{funmake}s Rückgabewert.

@c ===beg===
@c funmake (sin, [%pi / 2]);
@c ===end===
@example
(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
@end example

@end deffn

@deffn {Funktion} lambda ([@var{x_1}, ..., @var{x_m}], @var{expr_1}, ..., @var{expr_n})
@deffnx {Funktion} lambda ([[@var{L}]], @var{expr_1}, ..., @var{expr_n})
@deffnx {Funktion} lambda ([@var{x_1}, ..., @var{x_m}, [@var{L}]], @var{expr_1}, ..., @var{expr_n})
Definiert und gibt einen lambda-Ausdruck (d.h. eine anonyme Funktion) zurück.
Die Funktion kann erforderliche Argumente @var{x_1}, ..., @var{x_m} besitzen,
und/oder optionale Argumente @var{L}, welche im Funktionsrumpf als Liste 
auftreten. Der Rückgabewert der Funktion ist @var{expr_n}. 
Ein lambda-Ausdruck kann einer Variablen zugewiesen werden und
wird wie eine gewöhnliche Funktion ausgewertet.
Ein lambda-Ausdruck kann in einem Zusammenhang verwendet werden,
in dem der Name einer Funktion erwartet wird.

Wenn die Funktion ausgewertet wird, werden ungebundene lokale Variablen 
@var{x_1}, ..., @var{x_m} erzeugt.
@code{lambda} kann innerhalb eines @code{block} oder einem anderen 
@code{lambda} auftreten; 
jedesmal wenn ein neuer @code{block} oder ein neues @code{lambda} ausgewertet wird, 
werden entsprechende lokalen Variablen eingerichtet. 
Lokale Variablen erscheinen jedem eingeschlossenen @code{block} 
oder @code{lambda} als global.
Ist eine Variable nicht lokal, 
ist ihr Wert gegebenenfalls der durch einen umgebenden @code{block}
oder ein umgebendes @code{lambda} 
zuletzt zugewiesene oder andernfalls der Wert in der globalen Umgebung. 
Dieses Prinzip stimmt wohl mit dem üblichen Verständnis eines 
dynamischen Gültigkeitsbereichs ("dynamic scope") überein.

Nachdem lokale Variablen eingerichtet wurden, 
werden @var{expr_1} bis @var{expr_n} der Reihe nach ausgewertet. 
Die spezielle Variable @code{%%}, die den Wert des vorangegangenen 
Ausdrucks repräsentiert, wird hierbei erkannt.
@code{throw} und @code{catch} können sich ebenso in der Liste der 
Ausdrücke befinden.

@code{return} darf nicht in einem lambda-Ausdruck erscheinen, 
der nicht durch @code{block} eingeschlossen wird,
in diesem Fall definiert @code{return} den Rückgabewert des Blocks und 
nicht den des lambda-Ausdrucks, wenn der Block nicht gerade @var{expr_n} ist. 
In ähnlicher Weise darf @code{go} nicht in einem lambda-Ausdruck erscheinen, 
der nicht durch @code{block} eingeschlossen wird.

@code{lambda} quotiert (Operator @code{'}) seine Argumente;
Der Quotierungs-Quotierungs-Operator @code{'@w{}'} verhindert die Quotierung.

Beispiele:

@itemize @bullet
@item
Ein lambda-Ausdruck kann einer Variablen zugewiesen werden und
wird wie eine gewöhnliche Funktion ausgewertet.
@end itemize
@c ===beg===
@c f: lambda ([x], x^2);
@c f(a);
@c ===end===
@example
(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
@end example
@itemize @bullet
@item
Ein lambda-Ausdruck kann in einem Zusammenhang verwendet werden,
in dem der Name einer Funktion erwartet wird.
@end itemize
@c ===beg===
@c lambda ([x], x^2) (a);
@c apply (lambda ([x], x^2), [a]);
@c map (lambda ([x], x^2), [a, b, c, d, e]);
@c ===end===
@example
(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
@end example
@itemize @bullet
@item
Argumentvariablen sind lokale Variablen.
Andere Variablen erscheinen als globale Variablen.
Globale Variablen werden zum Zeitpunkt der Auswertung des lambda-Ausdrucks 
ausgewertet, wenn nicht eine spezielle Auswertung mit Hilfe von 
z.B. @code{'@w{}'} erzwungen wird.
@end itemize
@c ===beg===
@c a: %pi$
@c b: %e$
@c g: lambda ([a], a*b);
@c b: %gamma$
@c g(1/2);
@c g2: lambda ([a], a*''b);
@c b: %e$
@c g2(1/2);
@c ===end===
@example
(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
@end example
@itemize @bullet
@item
Lambda-Ausdrücke können verschachtelt sein.
Lokale Variablen in einem äußeren lambda-Ausdruck erscheinen dem 
inneren Ausdruck als global, solange sie nicht durch lokale Variablen 
gleichen Namens maskiert werden.
@end itemize
@c ===beg===
@c h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
@c h(%pi, %gamma);
@c ===end===
@example
(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
@end example
@itemize @bullet
@item
Da @code{lambda} seine Argumente quotiert (Operator @code{'}), 
definiert unten der lambda-Ausdruck @code{i} keine 
"multipliziere mit @code{a}"-Funktion.
So eine Funktion kann via @code{buildq} definiert werden,
wie unten im lambda-Ausdruck @code{i2}.
@end itemize
@c ===beg===
@c i: lambda ([a], lambda ([x], a*x));
@c i(1/2);
@c i2: lambda([a], buildq([a: a], lambda([x], a*x)));
@c i2(1/2);
@c i2(1/2)(%pi);
@c ===end===
@example
(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
@end example
@itemize @bullet
@item
Ein lambda-Ausdruck kann eine variable Anzahl an Argumenten besitzen, 
angezeigt durch @code{[@var{L}]} als das einzige oder letzte Argument.
Die Argumente treten innerhalb des Funktionsrumpfs als Liste auf.
@end itemize
@c ===beg===
@c f : lambda ([aa, bb, [cc]], aa * cc + bb);
@c f (foo, %i, 17, 29, 256);
@c g : lambda ([[aa]], apply ("+", aa));
@c g (17, 29, x, y, z, %e);
@c ===end===
@example
(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply ("+", aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
@end example
@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Funktion} local (@var{v_1}, ..., @var{v_n})
Erklärt die Variablen @var{v_1}, ..., @var{v_n}  als lokal bezüglich 
aller Eigenschaften (@code{properties}) innerhalb der Anweisung, 
in der diese Funktion verwendet wird.

@code{local} quotiert (Operator @code{'}) seine Argumente.
@code{local} gibt @code{done} zurück.

@code{local} kann nur in @code{block} verwendet werden, 
im Rumpf einer Funktionsdefinition oder eines @code{lambda}-Ausdrucks, 
oder in der @code{ev}-Funktion, und nur eine Verwendung ist jeweils erlaubt.

@code{local} ist unabhängig von @code{context}.

@end deffn

@defvr {Optionsvariable} macroexpansion
Standardwert: @code{false}

@code{macroexpansion} entscheidet, ob die Expansion (d.h. der Rückgabewert) 
einer Makrofunktion den Aufruf der Makrofunktion selbst ersetzt. 
Eine Ersetzung kann nachfolgende Auswertungen beschleunigen, 
kostet dann aber das Speichern der Expansion.

@table @code
@item false
Die Expansion der Makrofunktion ersetzt nicht den Aufruf der Makrofunktion.
@item expand
Wenn der Aufruf der Makrofunktion das erste Mal ausgewertet wird, 
wird die Expansion gespeichert.
Bei nachfolgenden Aufrufen wird die Expansion nicht erneut berechnet; 
Seiteneffekte (wie z.B. @code{print} oder Zuweisungen an globale Variablen) 
ereignen sich nur, wenn der Makrofunktionsaufruf das erste Mal ausgewertet wird.
Die Expansion in einem Ausdruck wirkt sich nicht auf andere Ausdrücke aus, 
die denselben Makrofunktionsaufruf enthalten.
@item displace
Wenn der Aufruf der Makrofunktion das erste Mal ausgewertet wird, 
wird der Aufruf selbst durch die Expansion ersetzt, 
so dass der Ausdruck, aus dem die Makrofunktion aufgerufen wird, 
verändert wird.
Bei nachfolgenden Aufrufen wird die Expansion nicht erneut berechnet; 
Seiteneffekte ereignen sich nur, wenn der Makrofunktionsaufruf 
das erste Mal ausgewertet wird.
Die Expansion in einem Ausdruck wirkt sich nicht auf andere Ausdrücke aus, 
die denselben Makrofunktionsaufruf enthalten.
@end table

Beispiele

Wenn @code{macroexpansion} @code{false} ist, 
wird bei dem Aufruf einer Makrofunktion der aufrufende Ausdruck 
jedesmal ausgewertet und dabei nicht verändert.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
@c macroexpansion: false;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

Wenn @code{macroexpansion} @code{expand} ist,
wird die Makrofunktion nur einmal aufgerufen, 
und der aufrufende Ausdruck wird nicht geändert.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
@c macroexpansion: expand;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

Wenn @code{macroexpansion} @code{displace} ist,
wird die Makrofunktion nur einmal aufgerufen, 
und der aufrufende Ausdruck wird anschließend geändert.

@c ===beg===
@c f (x) := h (x) / g (x);
@c g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
@c h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
@c macroexpansion: displace;
@c f (a * b);
@c dispfun (f);
@c f (a * b);
@c ===end===
@example
(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print ("x + 99 is equal to", x), return (x + 99));
(%o2) g(x) ::= block(print("x + 99 is equal to", x), 
                                                  return(x + 99))
(%i3) h (x) ::= block (print ("x - 99 is equal to", x), return (x - 99));
(%o3) h(x) ::= block(print("x - 99 is equal to", x), 
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x 
x + 99 is equal to x 
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
@end example

@end defvr

@c I DO NOT OBSERVE ANY EFFECT OF mode_checkp, mode_check_errorp, mode_check_warnp 
@c WHILE TRANSLATING
@c ONLY tr_warn_mode SEEMS TO HAVE EFFECT HERE (VvN)
@defvr {Optionsvariable} mode_checkp
Standardwert: @code{true}

@c WHAT DOES THIS MEAN ??
Wenn @code{mode_checkp} @code{true} ist, überprüft @code{mode_declare} 
die Modi der gebundenen Variablen.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Optionsvariable} mode_check_errorp
Standardwert: @code{false}

@c WHAT DOES THIS MEAN ??
Wenn @code{mode_check_errorp} @code{true} ist, ruft @code{mode_declare} 
@code{error} auf.
@c NEED SOME EXAMPLES HERE.

@end defvr

@defvr {Optionsvariable} mode_check_warnp
Standardwert: @code{true}

@c WHAT DOES THIS MEAN ??
Wenn @code{mode_check_warnp} @code{true} ist, werden Modus-Fehler beschrieben.
@c NEED SOME EXAMPLES HERE.

@end defvr

@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Funktion} mode_declare (@var{y_1}, @var{mode_1}, ..., @var{y_n}, @var{mode_n})
@code{mode_declare} wird verwendet, um die Modi der Variablen und Funktionen 
für nachfolgende Übersetzungen oder Kompilationen zu deklarieren.
@code{mode_declare} wird typischerweise an den Anfang einer Funktionsdefinition 
gesetzt, an den Anfang eines Maxima-Skripts oder wird interaktiv in 
der Eingabezeile ausgeführt. 

Die Argumente von @code{mode_declare} sind Paare, bestehend aus einer 
Variablen und einem Modus, der entweder @code{boolean}, @code{fixnum}, 
@code{number}, @code{rational} oder @code{float} ist. 
Jede Variable kann auch eine Liste von Variablen sein, die dadurch alle im selben 
Modus deklariert werden.

@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Ist eine Variable ein Array, und hat jedes Element des Arrays, 
das referenziert wird, einen Wert, dann sollte eher
@example
array (yi, complete, dim1, dim2, ...)
@end example
als @code{array(yi, dim1, dim2, ...)} bei der ersten Deklaration der Größe 
des Arrays verwendet werden.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Wenn alle Elemente des Arrays im Modus @code{fixnum} (@code{float}) sind, 
sollte man @code{fixnum} (@code{float}) statt @code{complete} verwenden.
@c WHAT DOES THE FOLLOWING STATEMENT MEAN ???
Wenn ebenso jedes Element des Arrays im gleichen Modus ist, hier @code{m}, 
dann sollte

@example
mode_declare (completearray (yi), m))
@end example

für eine effiziente Übersetzung verwendet werden.

Numerischer Code, der Arrays verwendet, wird eventuell durch die 
Deklaration der erwarteten Größe des Arrays schneller laufen, wie in:

@example
mode_declare (completearray (a [10, 10]), float)
@end example

für ein 10 x 10 Array mit Gleitkommazahlen.

Man kann den Modus des Ergebnisses einer Funktion durch die Verwendung 
des Arguments @code{function (f_1, f_2, ...)} deklarieren; 
hierbei sind @code{f_1}, @code{f_2}, ... die Namen der Funktionen. 
Zum Beispiel deklariert der Ausdruck

@example
mode_declare ([function (f_1, f_2, ...)], fixnum)
@end example

dass der Wert, der von @code{f_1}, @code{f_2}, ... zurückgegeben wird,
Einfach-Wort-Integer sind.

@code{modedeclare} ist ein Synonym für @code{mode_declare}.

@end deffn

@c WHAT IS THIS ABOUT ??
@c NEEDS CLARIFICATION AND EXAMPLES
@deffn {Funktion} mode_identity (@var{arg_1}, @var{arg_2})
Ist eine spezielle Form, die zusammen mit @code{mode_declare} und
einem Makro verwendet wird, um z.B. eine Liste von Gleitkommazahlen oder 
zusammengesetzte Datenobjekte zu deklarieren. 
Das erste Argument von @code{mode_identity} ist der Name des Modus eines 
elementaren Werts, wie er auch in @code{mode_declare} angegeben wird 
(d.h. @code{float}, @code{fixnum}, @code{number}, @code{list}, oder @code{any}), 
und das zweite Argument ist ein Ausdruck, der ausgewertet und dann als Wert 
von @code{mode_identity} zurückgegeben wird.
Wenn jedoch der Rückgabewert nicht durch den deklarierten Modus gestattet ist, 
wird ein Fehler oder eine Warnung ausgegeben. 
Es kommt darauf an, dass der Modus des Ausdrucks, der durch den 
Maxima-Lisp-Übersetzer bestimmt wird, mit dem des ersten Arguments übereinstimmt, 
unabhängig davon, was im zweiten Argument vor sich geht. 
Z.B. erzeugt @code{x: 3.3; mode_identity (fixnum, x);} einen Fehler.
@code{mode_identity (flonum, x)} gibt 3.3 zurück. 
Hierfür gibt es eine Anzahl an Verwendungsmöglichkeiten, z.B., wenn man 
weiß, dass @code{first (l)} eine Zahl zurückgibt, kann man 
@code{mode_identity (number, first (l))} schreiben. Ein effizienterer Weg 
hierfür wäre jedoch die Definition einer neuen elementaren Form, 

@example
firstnumb (x) ::= buildq ([x], mode_identity (number, x));
@end example

und die Verwendung von @code{firstnumb} bei jedem Herausnehmen des 
ersten Elements aus einer Liste von Zahlen.

@end deffn

@c IS THERE ANY REASON TO SET transcompile: false ??
@c MAYBE THIS VARIABLE COULD BE PERMANENTLY SET TO true AND STRUCK FROM THE DOCUMENTATION.
@defvr {Optionsvariable} transcompile
Standardwert: @code{true}

Wenn @code{transcompile} @code{true} ist, erzeugen @code{translate} 
und @code{translate_file} Deklarationen, die den übersetzten Code 
für die Kompilation geeigneter machen.
@c BUT THE DECLARATIONS DON'T SEEM TO BE NECESSARY, SO WHAT'S THE POINT AGAIN ??

@code{compfile} setzt dauerhaft @code{transcompile: true}.

@end defvr

@deffn {Funktion} translate (@var{f_1}, ..., @var{f_n})
@deffnx {Funktion} translate (functions)
@deffnx {Funktion} translate (all)
Übersetzt die benutzerdefinierten Funktionen @var{f_1}, ..., @var{f_n} 
von Maxima nach Lisp und wertet die Lisp-Übersetzungen aus. 
Typischerweise laufen die übersetzten Funktionen schneller als die Originale.

@code{translate (all)} oder @code{translate (functions)} übersetzt alle 
benutzerdefinierten Funktionen.

Zu übersetzende Funktionen sollten, wenn möglich, zu Beginn einen Aufruf von 
@code{mode_declare} enthalten, um effizienten Code zu erzeugen. 
Zum Beispiel:

@example
f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)
@end example

@noindent

wobei die @var{x_1}, @var{x_2}, ...  die Parameter der Funktion und 
@var{v_1}, @var{v_2}, ... die lokalen Variablen sind.

Die Namen der übersetzten Funktionen werden aus der Liste 
@code{functions} entfernt, wenn @code{savedef} @code{false} ist (siehe unten), 
und dann der @code{props}-Liste hinzugefügt.

Funktionen sollten nicht übersetzt werden, bevor sie nicht vollständig entwanzt sind.

Ausdrücke werden als vereinfacht angenommen; wenn sie es nicht sind, 
wird korrekter, aber nicht optimaler Code erzeugt. 
Der Benutzer sollte deshalb nicht den Schalter @code{simp} auf @code{false} 
setzen, was die Vereinfachung der zu übersetzenden Ausdrücke verhindern würde. 

Der Schalter @code{translate}, falls @code{true}, bewirkt eine automatische 
Übersetzung der Benutzerfunktionen nach Lisp.

Beachte, dass übersetzte Funktionen möglicherweise nicht in identischer 
Weise laufen wie vor der Übersetzung, da es bestimmte Unvereinbarkeiten 
der Lisp- und Maxima-Versionen geben kann. 
Die @code{rat}-Funktion mit mehr als einem Argument und die 
@code{ratvars}-Funktion sollten prinzipiell nicht verwendet werden, 
wenn irgend eine Variable durch @code{mode_declare} als 
Canonical Rational Expression (CRE) deklariert wurde. 
Ebenso wird die Einstellung @code{prederror: false} nicht übersetzt.
@c WHAT ABOUT % AND %% ???

@code{savedef} - falls @code{true}, bewirkt, dass die Maxima-Version einer 
Benutzerfunktion erhalten bleibt, wenn die Funktion via @code{translate} 
übersetzt wurde. Dies erlaubt, dass die Definition von @code{dispfun} 
angezeigt wird und auch, dass die Funktion editiert werden kann.

@code{transrun} - falls @code{false}, bewirkt, dass die interpretierte Version 
aller Funktionen eher läuft (vorausgesetzt, es gibt sie noch) als die übersetzte. 

Die Rückgabe von @code{translate} ist eine Liste mit den Namen der 
übersetzten Funktionen.

@end deffn

@deffn {Funktion} translate_file (@var{maxima_filename})
@deffnx {Funktion} translate_file (@var{maxima_filename}, @var{lisp_filename})
Übersetzt eine Datei in Maxima-Code in eine Datei in Lisp-Code. 
@code{translate_file} gibt eine Liste mit drei Dateinamen zurück: 
Der Name der Maxima-Datei, der Name der Lisp-Datei und der Name einer 
Datei, die zusätzliche Informationen über die Übersetzung enthält.
@code{translate_file} wertet seine Argumente aus.

@code{translate_file ("foo.mac"); load("foo.LISP")} ist dasselbe wie
@code{batch ("foo.mac")}, abgesehen von gewissen Einschränkungen, 
wie zum Beispiel die Verwendung von @code{'@w{}'} und @code{%}. 
@c FIGURE OUT WHAT THE RESTRICTIONS ARE AND STATE THEM

@code{translate_file (@var{maxima_filename})} übersetzt eine 
Maxima-Datei @var{maxima_filename} in eine ähnlich lautende Lisp-Datei. 
@code{foo.mac} wir z.B. übersetzt in @code{foo.LISP}. 

Der Name der Maxima-Datei kann einen Verzeichnisnamen enthalten, 
die Lisp-Ausgabedatei wird dann in das gleiche Verzeichnis 
geschrieben, aus dem der Maxima-Input kommt. 

@code{translate_file (@var{maxima_filename}, @var{lisp_filename})} übersetzt eine 
Maxima-Datei @var{maxima_filename} in eine Lisp-Datei @var{lisp_filename}. 
@code{translate_file} ignoriert Datei-Erweiterungen in @code{lisp_filename};
die Datei-Erweiterung der Lisp-Ausgabedatei ist stets @code{LISP}.
Der Lisp-Dateiname kann einen Verzeichnisnamen enthalten, 
in diesem Fall wird die Lisp-Ausgabedatei in das angegebene Verzeichnis 
geschrieben.
@code{translate_file} schreibt auch eine Datei mit Warnmeldungen des Übersetzers 
in verschiedenen Dringlichkeitsstufen. Die Erweiterung dieser Datei ist @code{UNLISP}.
Diese Datei kann auch, obwohl manchmal schwer verständlich, wertvolle 
Informationen zum Aufspüren von Bugs im übersetzten Code enthalten.
Die @code{UNLISP}-Datei wird immer in das gleiche Verzeichnis geschrieben, 
aus dem der Maxima-Input kommt.

@code{translate_file} gibt Lisp-Code aus, der bewirkt, dass 
einige Deklarationen und Definitionen sich bereits auswirken, 
sobald der Lisp-Code kompiliert ist.
Siehe @code{compile_file} für mehr Informationen zu diesem Thema. 

@c CHECK ALL THESE AND SEE WHICH ONES ARE OBSOLETE
Siehe auch @code{tr_array_as_ref},
@c tr_bind_mode_hook EXISTS BUT IT APPEARS TO BE A GROTESQUE UNDOCUMENTED HACK
@c WE DON'T WANT TO MENTION IT
@c @code{tr_bind_mode_hook}, 
@code{tr_bound_function_applyp},
@c tr_exponent EXISTS AND WORKS AS ADVERTISED IN src/troper.lisp
@c NOT OTHERWISE DOCUMENTED; ITS EFFECT SEEMS TOO WEAK TO MENTION
@code{tr_exponent},
@code{tr_file_tty_messagesp}, 
@code{tr_float_can_branch_complex},
@code{tr_function_call_default}, 
@code{tr_numer},
@code{tr_optimize_max_loop}, 
@code{tr_semicompile},
@code{tr_state_vars}, 
@code{tr_warnings_get},
@code{tr_warn_bad_function_calls},
@code{tr_warn_fexpr}, 
@code{tr_warn_meval},
@code{tr_warn_mode},
@code{tr_warn_undeclared}, 
@code{tr_warn_undefined_variable},
und @code{tr_windy}.

@end deffn

@defvr {Optionsvariable} transrun
Standardwert: @code{true}

Wenn @code{transrun} @code{false} ist, bewirkt dies, dass eher die 
interpretierte Version einer Funktion verwendet wird (vorausgesetzt, es gibt sie noch) 
als die übersetzte.

@end defvr

@c IN WHAT CONTEXT IS tr_array_as_ref: false APPROPRIATE ??? NOT SEEING THE USEFULNESS HERE.
@c ALSO, I GUESS WE SHOULD HAVE AN ITEM FOR translate_fast_arrays, ANOTHER CONFUSING FLAG ...
@defvr {Optionsvariable} tr_array_as_ref
Standardwert: @code{true}

Wenn @code{translate_fast_arrays} @code{false} ist, 
werden Array-Referenzen in Lisp-Code, ausgegeben durch @code{translate_file}, 
durch @code{tr_array_as_ref} beeinflusst.
Wenn @code{tr_array_as_ref} @code{true} ist, 
werden Array-Namen ausgewertet, andernfalls erscheinen Array-Namen 
als wortgetreue Symbole im übersetzten Code.

@code{tr_array_as_ref} zeigt keine Wirkung, wenn @code{translate_fast_arrays} 
@code{true} ist.

@end defvr

@c WHY IS THIS FLAG NEEDED ??? UNDER WHAT CIRCUMSTANCES CAN TRANSLATION
@c OF A BOUND VARIABLE USED AS A FUNCTION GO WRONG ???
@defvr {Optionsvariable} tr_bound_function_applyp
Standardwert: @code{true}

Wenn @code{tr_bound_function_applyp} @code{true} ist, gibt Maxima 
eine Warnung aus, wenn gefunden wird, dass eine gebundene Variable 
(wie z.B. ein Funktionsargument) als Funktion verwendet wird. 
@code{tr_bound_function_applyp} beeinflusst nicht beeinflusst nicht den 
Code, der in diesen Fällen erzeugt wird.

Ein Ausdruck wie z.B. @code{g (f, x) := f (x+1)} wird eine Warnmeldung auslösen. 

@end defvr

@defvr {Optionsvariable} tr_file_tty_messagesp
Standardwert: @code{false}

Wenn @code{tr_file_tty_messagesp} @code{true} ist, 
werden Mitteilungen, die durch @code{translate_file} während der Übersetzung 
einer Datei erzeugt werden, in der Konsole und in der UNLISP-Datei ausgegeben. 
Wenn @code{false}, werden die Mitteilungen über die Übersetzung der Datei nur 
in der UNLISP-Datei ausgegeben. 

@end defvr

@c THIS FLAG APPEARS TO HAVE NO EFFECT. SHOULD CUT OUT THIS ITEM AND RELATED CODE.
@c NOTE THAT THERE IS CODE IN src/transf.lisp WHICH USES THIS FLAG BUT THE MODE
@c FLAG IS LOST SOMEWHERE ALONG THE WAY TO THE LISP OUTPUT FILE.
@defvr {Optionsvariable} tr_float_can_branch_complex
Standardwert: @code{true}

Bringt den Maxima-nach-Lisp-Übersetzer dazu, davon auszugehen, dass die Funktionen 
@code{acos}, @code{asin}, @code{asec} und @code{acsc} komplexe Resultate 
zurückgeben können.

Der scheinbare Effekt von @code{tr_float_can_branch_complex} ist das Folgende. 
Es sieht jedoch so aus, als habe dieser Schalter keine Auswirkung auf die Ausgabe des 
Übersetzers. 

Wenn er @code{true} ist, dann ist @code{acos(x)} im Modus @code{any}, 
sogar wenn @code{x} im Modus @code{float} ist (gesetzt durch @code{mode_declare}).

Wenn @code{false}, ist @code{acos(x)} genau dann im Modus @code{float}, 
wenn @code{x} ebenfalls im Modus @code{float} ist.

@end defvr

@defvr {Optionsvariable} tr_function_call_default
Standardwert: @code{general}

@code{false} bedeutet, gib auf und rufe @code{meval} auf.
@c code{expr} means assume Lisp fixed arg function. 
@c TRANSLATION NOT CLEAR. WHAT IS A Lisp fixed arg function ?? (VvN)
@code{expr} bedeutet, nimm eine Lisp-Funktion mit feststehenden Argumenten an.  
Der Standardwert @code{general} ergibt guten Code für 
@code{mexprs} und @code{mlexprs}, aber nicht für @code{macros}.
@code{general} garantiert, dass die Variablenbindungen im kompilierten Code 
korrekt sind. Im @code{general}-Modus wird bei der Übersetzung von 
@code{f(x)}, falls @code{f} eine ungebundene Variable ist, angenommen, 
dass @code{apply (f, [x])} gemeint ist, und übersetzt entsprechend, 
verbunden mit einer Warnung. 
Es gibt keinen Anlass, dies abzustellen. Die Standardeinstellung bedeutet, 
dass bei ausbleibender Warnung volle Übereinstimmung von 
übersetztem und kompiliertem Code mit dem Maxima-Interpretierer besteht.

@end defvr

@defvr {Optionsvariable} tr_numer
Standardwert: @code{false}

Wenn @code{tr_numer} @code{true} ist, wird die Eigenschaft (@code{properties}) 
@code{numer} für Atome, die diese Eigenschaft haben, z.B. @code{%pi}, verwendet.

@end defvr

@defvr {Optionsvariable} tr_optimize_max_loop
Standardwert: 100

@code{tr_optimize_max_loop} ist die maximale Anzahl der Wiederholungen, 
die der Übersetzer eine Makroexpansion oder Optimierung im 
Hinblick auf eine bestimmte Form durchführen wird.
Diese ist dazu da, um Fehler bei der Makroexpansion und um 
nichtterminierende Optimierungseigenschaften aufzufangen.

@end defvr

@defvr {Optionsvariable} tr_semicompile
Standardwert: @code{false}

Wenn @code{tr_semicompile} @code{true} ist, 
werden die von @code{translate_file} und @code{compfile} 
ausgegebenen Formen makroexpandiert, aber nicht durch den Lisp-Compiler 
in Maschinencode kompiliert.

@end defvr

@c ARE ANY OF THESE OBSOLETE ??
@defvr {Systemvariable} tr_state_vars
Standardwert:
@example
[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
@end example

Die Liste der Schalter, die die Form des übersetzten Outputs beeinflussen.
@c DOES THE GENERAL USER REALLY CARE ABOUT DEBUGGING THE TRANSLATOR ???
Diese Information ist nützlich für Systemprogrammierer, wenn sie 
versuchen den Übersetzer zu entwanzen. 
Durch den Vergleich des übersetzten Produkts mit dem, was für einen 
gegebenen Zustand produziert werden sollte, ist es möglich, 
Bugs aufzuspüren.

@end defvr

@c tr_warnings_get EXISTS AND FUNCTIONS AS ADVERTISED (SORT OF) -- RETURNS *tr-runtime-warned*
@c WHICH HAS ONLY A FEW KINDS OF WARNINGS PUSHED ONTO IT; IT'S CERTAINLY NOT COMPREHENSIVE
@c DO WE REALLY NEED THIS SLIGHTLY WORKING FUNCTION ??
@deffn {Funktion} tr_warnings_get ()
Gibt eine Liste von Warnungen aus, die durch den Übersetzer 
während der aktuellen Übersetzung erzeugt werden.

@end deffn

@defvr {Optionsvariable} tr_warn_bad_function_calls
Standardwert: @code{true}

- Gibt eine Warnung aus,  
wenn Funktionsaufrufe gemacht werden, die aufgrund unzulässiger, 
zur Übersetzungszeit erzeugter Deklarationen nicht korrekt sind. 

@end defvr

@c WHAT DOES fexpr MEAN ?? ITEM NOT CLEAR. (VvN)
@defvr {Optionsvariable} tr_warn_fexpr
Standardwert: @code{compfile}

- Gibt eine Warnung aus, 
wenn irgendwelche FEXPRs angetroffen werden. 
FEXPRs sollten normalerweise nicht in übersetztem Code ausgegeben werden, 
alle legitimen speziellen Programmformen sind übersetzt.

@end defvr

@defvr {Optionsvariable} tr_warn_meval
Standardwert: @code{compfile}

- Gibt eine Warnung aus, 
wenn die Funktion @code{meval} aufgerufen wird. 
Wenn @code{meval} aufgerufen wird, weist das auf ein Übersetzungsproblem hin.

@end defvr

@defvr {Optionsvariable} tr_warn_mode
Standardwert: @code{all}

- Gibt eine Warnung aus, 
wenn Variablen für ihren Modus unzulässige Werte zugewiesen werden. 

@end defvr

@defvr {Optionsvariable} tr_warn_undeclared
Standardwert: @code{compile}

- Entscheidet, ob eine Warnung über undeklarierte (@code{mode_declare}) Variablen 
@c TTY = console ??
in der Konsole ausgegeben werden soll.

@end defvr

@defvr {Optionsvariable} tr_warn_undefined_variable
Standardwert: @code{all}

- Gibt eine Warnung aus, 
wenn undefinierte globale Variablen gesichtet werden.

@end defvr

@c $tr_windy IS USED IN EXACTLY ONE PLACE (def%tr $kill IN src/trans1.lisp)
@c WHERE IT CAUSES A WARNING ABOUT USING kill. 
@c HOW ABOUT IF WE PERMANENTLY ENABLE THE WARNING MESSAGE
@c AND CUT OUT tr_windy FROM CODE AND DOCS.
@defvr {Option variable} tr_windy
Default value: @code{true}

- Erzeugt hilfreiche Kommentare und Programmiertipps.

@end defvr

@deffn {Funktion} compile_file (@var{filename})
@deffnx {Funktion} compile_file (@var{filename}, @var{compiled_filename})
@deffnx {Funktion} compile_file (@var{filename}, @var{compiled_filename}, @var{lisp_filename})
Übersetzt die Maxima-Datei @var{filename} nach Lisp, 
führt den Lisp-Compiler aus und lädt, 
wenn die Übersetzung und Kompilation erfolgreich war, 
den kompilierten Code in Maxima hinein.

@code{compile_file} gibt eine Liste mit den Namen von vier Dateien zurück:
Die Original-Maxima-Datei, die Lisp-Übersetzung, Bemerkungen zur Übersetzung  
und den kompilierten Code. 
Wenn die Kompilation misslang, ist @code{false} der vierte Eintrag.

Einige Deklarationen und Definitionen wirken sich aus, 
sobald der Lisp-Code kompiliert ist (ohne den kompilierten Code zu laden). 
Diese schließen Funktonen ein, die durch den Operator @code{:=} definiert sind, 
Makros, definiert durch den Operator @code{::=}, 
@code{alias}, @code{declare},
@code{define_variable},  @code{mode_declare},
und
@code{infix}, @code{matchfix},
@code{nofix}, @code{postfix}, @code{prefix},
und @code{compfile}.

Zuweisungen und Funktionsaufrufe werden nicht ausgewertet, 
bevor der kompilierte Code geladen wird. 
Insbesondere haben innerhalb einer Maxima-Datei Zuweisungen 
an die Übersetzungsschalter (@code{tr_numer}, etc.) 
keine Auswirkung auf die Übersetzung.

@c @code{compile_file} may mistake warnings for errors and
@c return @code{false} as the name of the compiled code when, in fact,
@c the compilation succeeded. This is a bug. 
@c REPORTED AS SOURCEFORGE BUG # 1103722.

@var{filename} sollte keine @code{:lisp}-Anweisungen enthalten.

@code{compile_file} wertet seine Argumente aus.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Funktion} declare_translated (@var{f_1}, @var{f_2}, ...)
Beim Übersetzen einer Datei mit Maxima-Code nach Lisp 
ist es für den Übersetzer wichtig zu wissen, 
welche Funktionen in der Datei als übersetzte oder kompilierte Funktionen 
aufgerufen werden sollen, oder welche nur Maxima-Funktionen sind, 
oder undefiniert.
An den Anfang einer Datei gesetzt, lässt diese Deklaration 
wissen, dass ein Symbol, das aktuell noch nicht den Wert einer Lisp-Funktion
hat, zur Laufzeit einen haben wird.
Der Lisp-Code @code{(MFUNCTION-CALL fn arg1 arg2 ...)} wird erzeugt, 
wenn der Übersetzer nicht weiß, ob @code{fn} den Wert einer Lisp-Funktion 
haben wird.

@end deffn

