@c -----------------------------------------------------------------------------
@c File        : Special.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Special.texi revision 1.61
@c Translation : Dr. Dieter Kaiser
@c Date        : 13.11.2010
@c Revision    : 31.03.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung f@"ur spezielle Funktionen::
* Besselfunktionen und verwandte Funktionen::
* Gammafunktionen und verwandte Funktionen::
* Exponentielle Integrale::
* Fehlerfunktionen::
* Elliptische Funktionen und Integrale::
* Hypergeometrische Funktionen::
* Funktionen und Variablen f@"ur spezielle Funktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung f@"ur spezielle Funktionen, Besselfunktionen und verwandte Funktionen, Spezielle Funktionen, Spezielle Funktionen
@section Einf@"uhrung f@"ur spezielle Funktionen
@c -----------------------------------------------------------------------------

Spezielle Funktionen haben die folgenden Notationen:

@example
bessel_j (index, expr)         Bessel function, 1st kind
bessel_y (index, expr)         Bessel function, 2nd kind
bessel_i (index, expr)         Modified Bessel function, 1st kind
bessel_k (index, expr)         Modified Bessel function, 2nd kind

hankel_1 (v,z)                 Hankel function of the 1st kind
hankel_2 (v,z)                 Hankel function of the 2nd kind
struve_h (v,z)                 Struve H function
struve_l (v,z)                 Struve L function

assoc_legendre_p[v,u] (z)      Legendre function of degree v and order u 
assoc_legendre_q[v,u] (z)      Legendre function, 2nd kind

%f[p,q] ([], [], expr)         Generalized Hypergeometric function
gamma()                        Gamma function
gammagreek(a,z)                Incomplete gamma function
gammaincomplete(a,z)           Tail of incomplete gamma function
hypergeometric(l1, l2, z)      Hypergeometric function
@c IS slommel THE "LOMMEL" FUNCTION ?? NOT OTHERWISE MENTIONED IN TEXINFO FILES
slommel
%m[u,k] (z)                    Whittaker function, 1st kind
%w[u,k] (z)                    Whittaker function, 2nd kind
erfc (z)                       Complement of the erf function

expintegral_e (v,z)            Exponential integral E
expintegral_e1 (z)             Exponential integral E1
expintegral_ei (z)             Exponential integral Ei
expintegral_li (z)             Logarithmic integral Li
expintegral_si (z)             Exponential integral Si
expintegral_ci (z)             Exponential integral Ci
expintegral_shi (z)            Exponential integral Shi
expintegral_chi (z)            Exponential integral Chi

kelliptic (z)                  Complete elliptic integral of the first 
                               kind (K)
parabolic_cylinder_d (v,z)     Parabolic cylinder D function
@end example

@c -----------------------------------------------------------------------------
@node Besselfunktionen und verwandte Funktionen, Gammafunktionen und verwandte Funktionen, Einf@"uhrung f@"ur spezielle Funktionen, Spezielle Funktionen
@need 800
@section Besselfunktionen und verwandte Funktionen
@c -----------------------------------------------------------------------------

@menu
* Besselfunktionen::
* Hankelfunktionen::
* Airyfunktionen::
* Struvefunktionen::
@end menu

@c -----------------------------------------------------------------------------
@node Besselfunktionen, Hankelfunktionen, Besselfunktionen und verwandte Funktionen, Besselfunktionen und verwandte Funktionen
@subsection Besselfunktionen
@c -----------------------------------------------------------------------------

@c --- 27.03.2011 DK -----------------------------------------------------------
@anchor{bessel_j}
@deffn {Funktion} bessel_j (@var{v}, @var{z})

Die Besselfunktion der ersten Art der Ordnung @math{v} und dem Argument
@math{z}.  @code{bessel_j} ist definiert als

@ifnottex
@example
                inf
                ====       k  - v - 2 k  v + 2 k
                \     (- 1)  2          z
                 >    --------------------------
                /        k! gamma(v + k + 1)
                ====
                k = 0
@end example
@end ifnottex
@tex
$$\sum_{k=0}^{\infty }{{{\left(-1\right)^{k}\,\left(z\over 2\right)^{v+2\,k}
 }\over{k!\,\Gamma\left(v+k+1\right)}}}$$
@end tex

Die Reihenentwicklung wird nicht f@"ur die numerische Berechnung genutzt.

Die Besselfunktion @code{bessel_j} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{bessel_j} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.

Die Besselfunktion hat die folgenden Eigenschaften, die mit
@mref{properties} angezeigt werden und auf das symbolische Rechnen Einfluss
haben:

@table @code
@item conjugate function
@code{bessel_j} hat Spiegelsymmetrie, wenn das Argument @var{z} keine negative
reelle Zahl ist.
@item complex characteristic
Maxima kennt den Realteil und den Imagin@"arteil von @code{bessel_j} f@"ur
spezielle Argumente @math{v} und @math{z}.
@item limit function
Maxima kennt spezielle Grenzwerte der Funktion @code{bessel_j}.
@item integral
Maxima kennt das Integral der Funktion @code{bessel_j} in Bezug auf das 
Argument @math{z}.
@item gradef
Maxima kennt die Ableitungen der Funktion @code{bessel_j} in Bezug auf die
Argumente @math{v} und @math{z}.
@end table

Die Vereinfachung der Besselfunktion @code{bessel_j} wird von den folgenden
Optionsvariablen kontrolliert:

@table @code
@item distribute_over
Hat die Optionsvariable @mref{distribute_over} den Wert @code{true} und ist das
Argument der Besselfunktion eine Matrix, Liste oder Gleichung wird die Funktion
auf die Elemente oder beiden Seiten der Gleichung angewendet.  Der Standardwert
ist @code{true}.
@item besselexpand
Hat die Optionsvariable @mref{besselexpand} den Wert @code{true}, werden
Besselfunktion mit einer halbzahligen Ordnung @math{v} als Sinus- und
Kosinusfunktionen entwickelt.
@item bessel_reduce
Hat die Optionsvariable @mref{bessel_reduce} den Wert @code{true}, werden 
Besselfunktionen mit einer ganzzahligen Ordnung @math{n} nach Besselfunktionen
mit der niedrigsten Ordnung @math{0} und @math{1} entwickelt.
@end table

Zus@"atzlich kennt Maxima die geraden und ungeraden Symmetrieeigenschaften der
Besselfunktionen f@"ur eine ganzzahlige Ordnung @math{v}.

Beispiele:

Numerisches Rechnen mit der Besselfunktion.  F@"ur gro@ss{}e Gleitkommazahlen
ist die numerische Berechnung nicht implementiert.

@example
(%i1) bessel_j(1,[0.5, 0.5+%i]);
(%o1) [.2422684576748739, .5124137767280905 %i
                                             + .3392601907198862]
(%i2) bessel_j(1,[0.5b0, 0.5b0+%i]);
(%o2)    [bessel_j(1, 5.0b-1), bessel_j(1, %i + 5.0b-1)]
@end example

Vereinfachungen der Besselfunktion mit den Optionsvariablen @code{besselexpand}
und @code{bessel_reduce}.

@example
(%i3) bessel_j(1/2,x), besselexpand:true;
                         sqrt(2) sin(x)
(%o3)                   -----------------
                        sqrt(%pi) sqrt(x)
(%i4) bessel_j(3,x), bessel_reduce:true;
         2 bessel_j(1, x)
      4 (---------------- - bessel_j(0, x))
                x
(%o4) ------------------------------------- - bessel_j(1, x)
                        x
@end example

Ableitungen und Integrale der Besselfunktion.

@example
(%i5) diff(bessel_j(2,x), x);
                 bessel_j(1, x) - bessel_j(3, x)
(%o5)            -------------------------------
                                2
(%i6) diff(bessel_j(v,x), x);
             bessel_j(v - 1, x) - bessel_j(v + 1, x)
(%o6)        ---------------------------------------
                                2
(%i7) integrate(bessel_j(v,x), x);
(%o7) 
                                               2
                    v   1    v   3            x    - v - 1  v + 1
    hypergeometric([- + -], [- + -, v + 1], - --) 2        x
                    2   2    2   2            4
    -------------------------------------------------------------
                         v   1
                        (- + -) gamma(v + 1)
                         2   2
(%i8) laplace(bessel_j(2,t), t, s);
                                1       2
                      (1 - sqrt(-- + 1))  s
                                 2
                                s
(%o8)                 ---------------------
                               1
                          sqrt(-- + 1)
                                2
                               s
@end example

Besselfunktionen als L@"osung einer linearen Differentialgleichung zweiter
Ordnung.

@example
(%i1) depends(y, x);
(%o1)                        [y(x)]
(%i2) declare(n, integer);
(%o2)                         done
(%i3) 'diff(y, x, 2)*x^2 + 'diff(y, x)*x + y*(x^2-n^2) = 0;
                                2
                     2    2    d y  2   dy
(%o3)            y (x  - n ) + --- x  + -- x = 0
                                 2      dx
                               dx
(%i4) ode2(%, y, x);
(%o4)      y = %k2 bessel_y(n, x) + %k1 bessel_j(n, x)
@end example
@end deffn

@c --- 27.03.2011 DK -----------------------------------------------------------
@anchor{bessel_y}
@deffn {Funktion} bessel_y (@var{v}, @var{z})

Die Besselfunktion der zweiten Art der Ordnung @math{v} und dem Argument 
@math{z}.  @code{bessel_y} ist definiert als

@ifnottex
@example
              cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
              -------------------------------------------
                             sin(%pi v)
@end example
@end ifnottex

@tex
$${{\cos \left(\pi\,v\right)\,J_{v}(z)-J_{-v}(z)}\over{
 \sin \left(\pi\,v\right)}}$$
@end tex

f@"ur den Fall, dass @math{v} keine ganze Zahl ist.  Ist @math{v} eine ganze
Zahl @math{n}, dann wird die Besselfunktion @code{bessel_y} als der Grenzwert
definiert, wenn @math{v} gegen die ganze Zahl @math{n} geht.

Die Besselfunktion @code{bessel_y} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{bessel_y} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.
@end deffn

@c --- 27.03.2011 DK -----------------------------------------------------------
@anchor{bessel_i}
@deffn {Funktion} bessel_i (@var{v}, @var{z})

Die modifizierte Besselfunktion der ersten Art der Ordnung @math{v} und dem 
Argument @math{v}.  @code{bessel_i} ist definiert als

@ifnottex
@example
                    inf
                    ====   - v - 2 k  v + 2 k
                    \     2          z
                     >    -------------------
                    /     k! gamma(v + k + 1)
                    ====
                    k = 0
@end example
@end ifnottex
@tex
$$\sum_{k=0}^{\infty } {{1\over{k!\,\Gamma
 \left(v+k+1\right)}} {\left(z\over 2\right)^{v+2\,k}}}$$
@end tex

Die Reihenentwicklung wird nicht f@"ur die numerische Berechnung genutzt.

Die Besselfunktion @code{bessel_i} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{bessel_i} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.
@end deffn

@c --- 27.03.2011 DK -----------------------------------------------------------
@anchor{bessel_k}
@deffn {Funktion} bessel_k (@var{v}, @var{z})

Die modifizierte Besselfunktion der zweiten Art der Ordnung @math{v} und dem
Argument @math{z}.  @code{bessel_k} ist definiert als

@ifnottex
@example
           %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
           -------------------------------------------------
                                  2
@end example
@end ifnottex
@tex
$${{\pi\,\csc \left(\pi\,v\right)\,\left(I_{-v}(z)-I_{v}(z)\right)}\over{2}}$$
@end tex

f@"ur den Fall, dass @math{v} keine ganze Zahl ist.  Ist @math{v} eine ganze
Zahl @math{n}, dann wird die Besselfunktion @code{bessel_k} als der Grenzwert
definiert, wenn @math{v} gegen die ganze Zahl @math{n} geht.

Die Besselfunktion @code{bessel_k} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{bessel_k} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.
@end deffn

@c --- 31.03.2011 DK -----------------------------------------------------------
@anchor{bessel_reduce}
@defvr {Optionsvariable} bessel_reduce
Standardwert: false

Hat die Optionsvariable @code{bessel_reduce} den Wert @code{true}, werden 
Besselfunktionen mit einer ganzzahligen Ordnung @math{n} nach Besselfunktionen
mit der niedrigsten Ordnung @math{0} und @math{1} entwickelt.
@end defvr

@c --- 31.03.2011 DK -----------------------------------------------------------
@anchor{besselexpand}
@defvr {Optionsvariable} besselexpand
Standardwert: @code{false}

Hat die Optionsvariable @code{besselexpand} den Wert @code{true}, werden
Besselfunktion mit einer halbzahligen Ordnung @math{v} als Sinus- und
Kosinusfunktionen entwickelt.  Die Optionsvariable @code{besselexpand}
kontrolliert auch die Entwicklung der Hankelfunktionen @mref{hankel_1} und
@mref{hankel_2} sowie der Struvefunktionen @mref{struve_h} und
@mrefdot{struve_l}

Beispiele:

@example
(%i1) besselexpand: false$
(%i2) bessel_j (3/2, z);
                                    3
(%o2)                      bessel_j(-, z)
                                    2
(%i3) besselexpand: true$
(%i4) bessel_j (3/2, z);
                                        sin(z)   cos(z)
                       sqrt(2) sqrt(z) (------ - ------)
                                           2       z
                                          z
(%o4)                  ---------------------------------
                                   sqrt(%pi)
@end example
@end defvr

@c --- 31.03.2011 DK -----------------------------------------------------------
@anchor{scaled_bessel_i}
@deffn {Funktion} scaled_bessel_i (@var{v}, @var{z}) 

Die skalierte modifizierte Besselfunktion der ersten Art der Ordnung
@math{v} und dem Argument @math{z}.  Diese ist definiert als 
@code{scaled_bessel_i(v,z) = exp(-abs(z))*bessel_i(v, z)}. 
@code{scaled_bessel_i} liefert ein numerisches Ergebnis, wenn die Argumente 
@math{v} und @math{z} Zahlen sind.  Die Funktion kann geeignet sein, wenn 
@code{bessel_i} f@"ur gro@ss{}e Argumente @math{z} numerisch berechnet werden soll.
Ganze, rationale oder gro@ss{}e Gleitkommazahlen werden in Gleitkommazahlen mit 
doppelter Genauigkeit umgewandelt.  Sind die Argumente keine Zahlen, wird ein 
vereinfachter Ausdruck mit der Funktion @mref{bessel_i} zur@"uckgegeben.

@code{scaled_bessel_i} ist eine Verbfunktion, die nicht f@"ur das symbolische
Rechnen geeignet ist.  F@"ur das symbolische Rechnen kann die Funktion
@mref{bessel_i} verwendet werden.

Beispiele:

@example
(%i1) scaled_bessel_i(1, 50);
(%o1)                  .05599312389289544
(%i2) scaled_bessel_i(1/2, 50);
(%o2)                  .05641895835477567
(%i3) scaled_bessel_i(v, x);
                                     - abs(x)
(%o3)               bessel_i(v, x) %e
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{scaled_bessel_i0}
@deffn {Funktion} scaled_bessel_i0 (@var{z}) 

Identical to @code{scaled_bessel_i(0,z)}.

Entspricht @code{scaled_bessel_i(0,z)}.  Siehe @mrefdot{scaled_bessel_i}
@end deffn

@c -----------------------------------------------------------------------------
@anchor{scaled_bessel_i1}
@deffn {Funktion} scaled_bessel_i1 (@var{z}) 

Entspricht @code{scaled_bessel_i(1,z)}.  Siehe @mrefdot{scaled_bessel_i}
@end deffn

@c -----------------------------------------------------------------------------
@node Hankelfunktionen, Airyfunktionen, Besselfunktionen, Besselfunktionen und verwandte Funktionen
@subsection Hankelfunktion
@c -----------------------------------------------------------------------------

@c --- 27.03.2011 DK -----------------------------------------------------------
@anchor{hankel_1}
@deffn {Funktion} hankel_1 (@var{v}, @var{z})

Die Hankelfunktion der ersten Art der Ordnung @math{v} und dem Argument
@math{z}. Siehe A@w{ }&@w{ }S 9.1.3.  @code{hankel_1} ist definiert als

@example
   bessel_j(v,z) + %i * bessel_y(v,z)
@end example

Die Hankelfunktion @code{hankel_1} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{hankel_1} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.

When @code{besselexpand} is @code{true}, @code{hankel_1} is expanded in terms
of elementary functions when the order @math{v} is half of an odd integer. 
See @code{besselexpand}.

Maxima knows the derivative of @code{hankel_1} wrt the argument @math{z}.

Examples:

Numerical evaluation:

@example
(%i1) hankel_1(1,0.5);
(%o1)              .2422684576748738 - 1.471472392670243 %i
(%i2) hankel_1(1,0.5+%i);
(%o2)             - .2558287994862166 %i - 0.239575601883016
@end example

A complex order @math{v} is not supported. Maxima returns a noun form:

@example
(%i3) hankel_1(%i,0.5+%i);
(%o3)                       hankel_1(%i, %i + 0.5)
@end example

Expansion of @code{hankel_1} when @code{besselexpand} is @code{true}:

@example
(%i4) hankel_1(1/2,z),besselexpand:true;
                      sqrt(2) sin(z) - sqrt(2) %i cos(z)
(%o4)                 ----------------------------------
                              sqrt(%pi) sqrt(z)
@end example

Derivative of @code{hankel_1} wrt the argument @math{z}. The derivative wrt the 
order @math{v} is not supported. Maxima returns a noun form:

@example
(%i5) diff(hankel_1(v,z),z);
                    hankel_1(v - 1, z) - hankel_1(v + 1, z)
(%o5)               ---------------------------------------
                                       2
(%i6) diff(hankel_1(v,z),v);
                             d
(%o6)                        -- (hankel_1(v, z))
                             dv
@end example
@end deffn

@c --- 27.03.2011 DK -----------------------------------------------------------
@anchor{hankel_2}
@deffn {Funktion} hankel_2 (@var{v}, @var{z})

Die Hankelfunktion der ersten Art der Ordnung @math{v} und dem Argument
@math{z}. Siehe A@w{ }&@w{ }S 9.1.4.  @code{hankel_2} ist definiert als

@example
   bessel_j(v,z) - %i * bessel_y(v,z)
@end example

Die Hankelfunktion @code{hankel_2} ist f@"ur das numerische und symbolische
Rechnen geeignet.

Maxima berechnet @code{hankel_2} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.

When @code{besselexpand} is @code{true}, @code{hankel_2} is expanded in terms
of elementary functions when the order @math{v} is half of an odd integer. 
See @code{besselexpand}.

Maxima knows the derivative of @code{hankel_2} wrt the argument @math{z}.

For examples see @code{hankel_1}.
@end deffn

@c -----------------------------------------------------------------------------
@node Airyfunktionen, Struvefunktionen, Hankelfunktionen, Besselfunktionen und verwandte Funktionen
@subsection Airyfunktionen
@c -----------------------------------------------------------------------------

The Airy functions Ai(x) and Bi(x) are defined in Abramowitz and Stegun,
@i{Handbook of Mathematical Functions}, Section 10.4. 

@code{y = Ai(x)} and @code{y = Bi(x)} are two linearly independent solutions 
of the Airy differential equation @code{diff (y(x), x, 2) - x y(x) = 0}.

If the argument @code{x} is a real or complex floating point 
number, the numerical value of the function is returned.

@deffn {Function} airy_ai (@var{x})
The Airy function Ai(x).  (A&S 10.4.2)

The derivative @code{diff (airy_ai(x), x)} is @code{airy_dai(x)}.

See also @code{airy_bi}, @code{airy_dai}, @code{airy_dbi}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{airy_dai}
@deffn {Function} airy_dai (@var{x})

The derivative of the Airy function Ai @code{airy_ai(x)}. 

See @code{airy_ai}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{airy_bi}
@deffn {Function} airy_bi (@var{x})

The Airy function Bi(x).  (A&S 10.4.3)

The derivative @code{diff (airy_bi(x), x)} is @code{airy_dbi(x)}.

See @code{airy_ai}, @code{airy_dbi}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{airy_dbi}
@deffn {Function} airy_dbi (@var{x})

The derivative of the Airy Bi function @code{airy_bi(x)}.

See @code{airy_ai} and @code{airy_bi}.
@end deffn

@c -----------------------------------------------------------------------------
@node Struvefunktionen, , Airyfunktionen, Besselfunktionen und verwandte Funktionen
@subsection Struvefunktionen
@c -----------------------------------------------------------------------------

@c --- 27.03.2011---------------------------------------------------------------
@anchor{struve_h}
@deffn {Funktion} struve_h (@var{v}, @var{z})

Die Struvefunktion H der Ordnung @math{v} und dem Argument @math{z}.  Siehe
Abramowitz und Stegun, Handbook of Mathematical Functions, Kapitel 12.  Die
Definition ist

@ifnottex
@example
            inf
            ====                  k  2 k
    z v + 1 \                (- 1)  z
   (-)       >    ----------------------------------
    2       /      2 k           3                3
            ====  2    gamma(k + -) gamma(v + k + -)
            k = 0                2                2
@end example
@end ifnottex
@tex
$$\left({{z}\over{2}}\right)^{v+1}\,\sum_{k=0}^{\infty }{{{\left(-1
 \right)^{k}\,z^{2\,k}}\over{2^{2\,k}\,\Gamma\left(k+{{3}\over{2}}
 \right)\,\Gamma\left(v+k+{{3}\over{2}}\right)}}}$$
@end tex

Die Struvefunktion @code{struve_h} ist f@"ur das numerische und symbolische
Rechnen geeignet.  Im Unterschied zu den @nref{Besselfunktionen} ist jedoch die
Implementation der Funktion @code{struve_h} weniger vollst@"andig.

Maxima berechnet @code{struve_h} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.

Hat die Optionsvariable @code{besselexpand} den Wert @code{true}, wird die
Struvefunktion @code{struve_h} mit einer halbzahligen Ordnung @math{v} als
Sinus- und Kosinusfunktionen entwickelt.

Maxima kennt die Ableitung der Struvefunktion @code{struve_h} nach dem Argument
@math{z}.

Siehe auch die Struvefunktion @mrefdot{struve_l}

Beispiele:

@example
(%i1) struve_h(1, 0.5);
(%o1)                  .05217374424234107
(%i2) struve_h(1, 0.5+%i);
(%o2)       0.233696520211436 %i - .1522134290663428
(%i3) struve_h(3/2,x), besselexpand: true;
                                           2
                  2 x sin(x) + 2 cos(x) - x  - 2
(%o3)           - ------------------------------
                                         3/2
                      sqrt(2) sqrt(%pi) x
(%i4) diff(struve_h(v, x), x);
                   v
                  x
(%o4) (------------------------- - struve_h(v + 1, x)
                  v           3
       sqrt(%pi) 2  gamma(v + -)
                              2
                                          + struve_h(v - 1, x))/2
@end example
@end deffn

@c --- 27.03.2011 DK -----------------------------------------------------------
@anchor{struve_l}
@deffn {Funktion} struve_l (@var{v}, @var{z})

Die modifizierte Struvefunktion L der Ordnung @math{v} und dem Argument
@math{z}.  Siehe Abramowitz und Stegun, Handbook of Mathematical Functions, 
Kapitel 12.  Die Definition ist

@ifnottex
@example
            inf
            ====                  2 k
    z v + 1 \                    z
   (-)       >    ----------------------------------
    2       /      2 k           3                3
            ====  2    gamma(k + -) gamma(v + k + -)
            k = 0                2                2
@end example
@end ifnottex
@tex
$$\left({{z}\over{2}}\right)^{v+1}\,\sum_{k=0}^{\infty }{{{z^{2\,k}
 }\over{2^{2\,k}\,\Gamma\left(k+{{3}\over{2}}\right)\,\Gamma\left(v+k
 +{{3}\over{2}}\right)}}}$$
@end tex

Die Struvefunktion @code{struve_l} ist f@"ur das numerische und symbolische
Rechnen geeignet.  Im Unterschied zu den @nref{Besselfunktionen} ist jedoch die
Implementation der Funktion @code{struve_l} weniger vollst@"andig.

Maxima berechnet @code{struve_l} numerisch f@"ur reelle und komplexe
Gleitkommazahlen als Argumente f@"ur @math{v} und @math{z}.  Mit der Funktion
@mref{float} oder der Optionsvariablen @mref{numer} kann die numerische
Auswertung erzwungen werden, wenn die Argumente Zahlen sind.  Die numerische
Berechnung f@"ur gro@ss{}e Gleitkommazahlen ist nicht implementiert.  In diesem
Fall gibt Maxima eine Substantivform zur@"uck.

Hat die Optionsvariable @code{besselexpand} den Wert @code{true}, wird die
Struvefunktion @code{struve_l} mit einer halbzahligen Ordnung @math{v} als
Sinus- und Kosinusfunktionen entwickelt.

Maxima kennt die Ableitung der Struvefunktion @code{struve_l} nach dem Argument
@math{z}.

Siehe auch die Struvefunktion @mrefdot{struve_h}

Beispiele:

@example
(%i1) struve_l(1, 0.5);
(%o1)                  .05394218262352267
(%i2) struve_l(1, 0.5+%i);
(%o2)       .1912720461247995 %i - .1646185598117401
(%i3) struve_l(3/2,x), besselexpand: true;
                                           2
                2 x sinh(x) - 2 cosh(x) - x  + 2
(%o3)           --------------------------------
                                        3/2
                     sqrt(2) sqrt(%pi) x
(%i4) diff(struve_l(v, x), x);
                   v
                  x
(%o4) (------------------------- + struve_l(v + 1, x)
                  v           3
       sqrt(%pi) 2  gamma(v + -)
                              2
                                          + struve_l(v - 1, x))/2
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Gammafunktionen und verwandte Funktionen, Exponentielle Integrale, Besselfunktionen und verwandte Funktionen, Spezielle Funktionen
@section Gammafunktionen und verwandte Funktionen
@c -----------------------------------------------------------------------------

The gamma function and the related beta, psi and incomplete gamma 
functions are defined in Abramowitz and Stegun,
@i{Handbook of Mathematical Functions}, Chapter 6.

@c -----------------------------------------------------------------------------
@anchor{bffac}
@deffn {Function} bffac (@var{expr}, @var{n})

Bigfloat version of the factorial (shifted gamma)
function.  The second argument is how many digits to retain and return,
it's a good idea to request a couple of extra.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{bfpsi}
@deffn {Function} bfpsi (@var{n}, @var{z}, @var{fpprec})
@deffnx {Function} bfpsi0 (@var{z}, @var{fpprec})

@code{bfpsi} is the polygamma function of real argument @var{z} and integer 
order @var{n}. @code{bfpsi0} is the digamma function. 
@code{bfpsi0 (@var{z}, @var{fpprec})} is equivalent to @code{bfpsi (0, @var{z}, 
@var{fpprec})}.

These functions return bigfloat values. @var{fpprec} is the bigfloat precision 
of the return value.

@c psi0(1) = -%gamma IS AN INTERESTING PROPERTY BUT IN THE ABSENCE OF ANY OTHER
@c DISCUSSION OF THE PROPERTIES OF THIS FUNCTION, THIS STATEMENT SEEMS OUT OF PLACE.
@c Note @code{-bfpsi0 (1, fpprec)} provides @code{%gamma} (Euler's constant) as a bigfloat.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{cbffac}
@deffn {Function} cbffac (@var{z}, @var{fpprec})

Complex bigfloat factorial.

@code{load ("bffac")} loads this function.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{gamma}
@deffn {Function} gamma (@var{z})

The basic definition of the gamma function (A&S 6.1.1) is

@example
                       inf
                      /
                      [     z - 1   - t
           gamma(z) = I    t      %e    dt
                      ]
                      /
                       0
@end example

Maxima simplifies @code{gamma} for positive integer and positive and negative 
rational numbers. For half integral values the result is a rational number times 
@code{sqrt(%pi)}. The simplification for integer values is controlled by 
@code{factlim}. For integers greater than @code{factlim} the numerical result of 
the factorial function, which is used to calculate @code{gamma}, will overflow. 
The simplification for rational numbers is controlled by @code{gammalim} to 
avoid internal overflow. See @code{factlim} and @code{gammalim}.

For negative integers @code{gamma} is not definied.

Maxima can evalute @code{gamma} numerically for real and complex values in float 
and bigfloat precision.

@code{gamma} has mirror symmetry.

When @code{gamma_expand} is @code{true}, Maxima expands @code{gamma} for 
arguments @code{z+n} and @code{z-n} where @code{n} is an integer.

Maxima knows the derivate of @code{gamma}.

Examples:

Simplification for integer, half integral, and rational numbers:

@example
(%i1) map('gamma,[1,2,3,4,5,6,7,8,9]);
(%o1)        [1, 1, 2, 6, 24, 120, 720, 5040, 40320]
(%i2) map('gamma,[1/2,3/2,5/2,7/2]);
                    sqrt(%pi)  3 sqrt(%pi)  15 sqrt(%pi)
(%o2)   [sqrt(%pi), ---------, -----------, ------------]
                        2           4            8
(%i3) map('gamma,[2/3,5/3,7/3]);
                                  2           1
                          2 gamma(-)  4 gamma(-)
                      2           3           3
(%o3)          [gamma(-), ----------, ----------]
                      3       3           9
@end example

Numerical evaluation for real and complex values:

@example
(%i4) map('gamma,[2.5,2.5b0]);
(%o4)     [1.329340388179137, 1.3293403881791370205b0]
(%i5) map('gamma,[1.0+%i,1.0b0+%i]);
(%o5) [0.498015668118356 - .1549498283018107 %i, 
          4.9801566811835604272b-1 - 1.5494982830181068513b-1 %i]
@end example

@code{gamma} has mirror symmetry:

@example
(%i6) declare(z,complex)$
(%i7) conjugate(gamma(z));
(%o7)                  gamma(conjugate(z))
@end example

Maxima expands @code{gamma(z+n)} and @code{gamma(z-n)}, when @code{gamma_expand} 
is @code{true}:

@example
(%i8) gamma_expand:true$

(%i9) [gamma(z+1),gamma(z-1),gamma(z+2)/gamma(z+1)];
                               gamma(z)
(%o9)             [z gamma(z), --------, z + 1]
                                z - 1
@end example

The deriviative of @code{gamma}:

@example
(%i10) diff(gamma(z),z);
(%o10)                  psi (z) gamma(z)
                           0
@end example

See also @mrefdot{makegamma}

The Euler-Mascheroni constant is @mrefdot{%gamma}
@end deffn

@c -----------------------------------------------------------------------------
@anchor{log_gamma}
@deffn {Function} log_gamma (@var{z})

The natural logarithm of the gamma function.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{gamma_incomplete}
@deffn {Function} gamma_incomplete (@var{a}, @var{z})

The incomplete upper gamma function A&S 6.5.2:

@tex
$$\int_{z}^{\infty }{t^{a-1}\,e^ {- t }\;dt}$$
@end tex
@ifnottex
@example
                  inf
                 /
                 [     a - 1   - t
                 I    t      %e    dt
                 ]
                 /
                  z
@end example
@end ifnottex
@end deffn

@c -----------------------------------------------------------------------------
@anchor{gamma_incomplete_regularized}
@deffn {Function} gamma_incomplete_regularized (@var{a}, @var{z})

The regularized incomplete upper gamma function A&S 6.5.1.  

@tex
$${{{\it gamma\_incomplete}\left(a , z\right)}\over{\Gamma\left(a
 \right)}}$$
@end tex
@ifnottex
@example
               gamma_incomplete(a, z)
               ----------------------
                      gamma(a)
@end example
@end ifnottex

@end deffn

@c -----------------------------------------------------------------------------
@anchor{gamma_incomplete_generalized}
@deffn {Function} gamma_incomplete_generalized (@var{a}, @var{z1}, @var{z2})

The generalized incomplete gamma function defined as

@tex
$$\int_{z1}^{z2}{t^{a-1}\,e^ {- t }\;dt}$$
@end tex
@ifnottex
@example
                  z2
                 /
                 [    a - 1   - t
                 I   t      %e    dt
                 ]
                 /
                  z1
@end example
@end ifnottex

@end deffn

@c -----------------------------------------------------------------------------
@anchor{gammalim}
@defvr {Option variable} gammalim
Default value: 1000000

@c REPHRASE
@code{gammalim} controls simplification of the gamma
function for integral and rational number arguments.  If the absolute
value of the argument is not greater than @code{gammalim}, then
simplification will occur.  Note that the @code{factlim} switch controls
simplification of the result of @code{gamma} of an integer argument as well.
@end defvr

@c NEED CROSS REFS HERE
@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{makegamma}
@deffn {Function} makegamma (@var{expr})

Transforms instances of binomial, factorial, and beta
functions in @var{expr} into gamma functions.

See also @code{makefact}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{beta}
@deffn {Function} beta (@var{a}, @var{b})

The beta function is defined as @code{gamma(a) gamma(b)/gamma(a+b)} 
(A&S 6.2.1).

Maxima simplifies the beta function for positive integers and rational 
numbers, which sum to an integer. When @code{beta_args_sum_to_integer} is 
@code{true}, Maxima simplifies also general expressions which sum to an integer. 

For @var{a} or @var{b} equal to zero the beta function is not defined.

In general the beta function is not defined for negative integers as an 
argument. The exception is for @var{a=-n}, @var{n} a positive integer 
and @var{b} a positive integer with @var{b<=n}, it is possible to define an 
analytic continuation. Maxima gives for this case a result.

When @code{beta_expand} is @code{true}, expressions like @code{beta(a+n,b)} and 
@code{beta(a-n,b)} or @code{beta(a,b+n)} and @code{beta(a,b-n)} with @code{n} 
an integer are simplified.

Maxima can evaluate the beta function for real and complex values in float and 
bigfloat precision. For numerical evaluation Maxima uses @code{log_gamma}:

@example
           - log_gamma(b + a) + log_gamma(b) + log_gamma(a)
         %e
@end example

Maxima knows that the beta function is symmetric and has mirror symmetry.

Maxima knows the derivatives of the beta function with respect to @var{a} or 
@var{b}.

To express the beta function as a ratio of gamma functions see @code{makegamma}. 

Examples:

Simplification, when one of the arguments is an integer:

@example
(%i1) [beta(2,3),beta(2,1/3),beta(2,a)];
                               1   9      1
(%o1)                         [--, -, ---------]
                               12  4  a (a + 1)
@end example

Simplification for two rational numbers as arguments which sum to an integer:

@example
(%i2) [beta(1/2,5/2),beta(1/3,2/3),beta(1/4,3/4)];
                          3 %pi   2 %pi
(%o2)                    [-----, -------, sqrt(2) %pi]
                            8    sqrt(3)
@end example

When setting @code{beta_args_sum_to_integer} to @code{true} more general 
expression are simplified, when the sum of the arguments is an integer:

@example
(%i3) beta_args_sum_to_integer:true$
(%i4) beta(a+1,-a+2);
                                %pi (a - 1) a
(%o4)                         ------------------
                              2 sin(%pi (2 - a))
@end example

The possible results, when one of the arguments is a negative integer: 

@example
(%i5) [beta(-3,1),beta(-3,2),beta(-3,3)];
                                    1  1    1
(%o5)                            [- -, -, - -]
                                    3  6    3
@end example

@code{beta(a+n,b)} or @code{beta(a-n)} with @code{n} an integer simplifies when 
@code{beta_expand} is @code{true}:

@example
(%i6) beta_expand:true$
(%i7) [beta(a+1,b),beta(a-1,b),beta(a+1,b)/beta(a,b+1)];
                    a beta(a, b)  beta(a, b) (b + a - 1)  a
(%o7)              [------------, ----------------------, -]
                       b + a              a - 1           b

@end example

Beta is not definied, when one of the arguments is zero:

@example
(%i7) beta(0,b);
beta: expected nonzero arguments; found 0, b
 -- an error.  To debug this try debugmode(true);
@end example

Numercial evaluation for real and complex arguments in float or bigfloat 
precision:

@example
(%i8) beta(2.5,2.3);
(%o8) .08694748611299981

(%i9) beta(2.5,1.4+%i);
(%o9) 0.0640144950796695 - .1502078053286415 %i

(%i10) beta(2.5b0,2.3b0);
(%o10) 8.694748611299969b-2

(%i11) beta(2.5b0,1.4b0+%i);
(%o11) 6.401449507966944b-2 - 1.502078053286415b-1 %i
@end example

Beta is symmetric and has mirror symmetry:

@example
(%i14) beta(a,b)-beta(b,a);
(%o14)                                 0
(%i15) declare(a,complex,b,complex)$
(%i16) conjugate(beta(a,b));
(%o16)                 beta(conjugate(a), conjugate(b))
@end example

The derivative of the beta function wrt @code{a}:
@example
(%i17) diff(beta(a,b),a);
(%o17)               - beta(a, b) (psi (b + a) - psi (a))
                                      0             0
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{beta_incomplete}
@deffn {Function} beta_incomplete (@var{a}, @var{b}, @var{z})

The basic definition of the incomplete beta function (A&S 6.6.1) is

@example
                       z
                      /
                      [         b - 1  a - 1
                      I  (1 - t)      t      dt
                      ]
                      /
                       0
@end example

This definition is possible for @math{realpart(a)>0} and @math{realpart(b)>0} 
and @math{abs(z)<1}. For other values the incomplete beta function can be 
defined through a generalized hypergeometric function:

@example
   gamma(a) hypergeometric_generalized([a, 1 - b], [a + 1], z) z
@end example

(See functions.wolfram.com for a complete definition of the incomplete beta 
function.)

For negative integers @math{a = -n} and positive integers @math{b=m} with 
@math{m<=n} the incomplete beta function is defined through

@example
                            m - 1           k
                            ====  (1 - m)  z
                      n - 1 \            k
                     z       >    -----------
                            /     k! (n - k)
                            ====
                            k = 0
@end example

Maxima uses this definition to simplify @code{beta_incomplete} for @var{a} a 
negative integer.

For @var{a} a positive integer, @code{beta_incomplete} simplifies for any 
argument @var{b} and @var{z} and for @var{b} a positive integer for any 
argument @var{a} and @var{z}, with the exception of @var{a} a negative integer.

For @math{z=0} and @math{realpart(a)>0}, @code{beta_incomplete} has the 
specific value zero. For @var{z=1} and @math{realpart(b)>0}, 
@code{beta_incomplete} simplifies to the beta function @code{beta(a,b)}.

Maxima evaluates @code{beta_incomplete} numerically for real and complex values 
in float or bigfloat precision. For the numerical evaluation an expansion of the 
incomplete beta function in continued fractions is used.

When @code{beta_expand} is @code{true}, Maxima expands expressions like 
@code{beta_incomplete (a+n, b, z)} and @code{beta_incomplete (a-n, b, z)} where 
@var{n} is a positive integer.

Maxima knows the derivatives of @code{beta_incomplete} with respect to the 
variables @var{a}, @var{b} and @var{z} and the integral with respect to the 
variable @var{z}.

Examples:

Simplification for @var{a} a positive integer:

@example
(%i1) beta_incomplete(2,b,z);
                                       b
                            1 - (1 - z)  (b z + 1)
(%o1)                       ----------------------
                                  b (b + 1)
@end example

Simplification for @var{b} a positive integer:

@example
(%i2) beta_incomplete(a,2,z);
                                               a
                              (a (1 - z) + 1) z
(%o2)                         ------------------
                                  a (a + 1)
@end example

Simplification for @var{a} and @var{b} a positive integer:

@example
(%i3) beta_incomplete(3,2,z);
                                               3
                              (3 (1 - z) + 1) z
(%o3)                         ------------------
                                      12
@end example

@var{a} is a negative integer and @math{b<=(-a)}, Maxima simplifies:

@example
(%i4) beta_incomplete(-3,1,z);
                                       1
(%o4)                              - ----
                                        3
                                     3 z
@end example

For the specific values @math{z=0} and @math{z=1}, Maxima simplifies:

@example
(%i5) assume(a>0,b>0)$
(%i6) beta_incomplete(a,b,0);
(%o6)                                 0
(%i7) beta_incomplete(a,b,1);
(%o7)                            beta(a, b)
@end example

Numerical evaluation in float or bigfloat precision:

@example
(%i8) beta_incomplete(0.25,0.50,0.9);
(%o8)                          4.594959440269333
(%i9)  fpprec:25$
(%i10) beta_incomplete(0.25,0.50,0.9b0);
(%o10)                    4.594959440269324086971203b0
@end example

For @math{abs(z)>1} @code{beta_incomplete} returns a complex result:

@example
(%i11) beta_incomplete(0.25,0.50,1.7);
(%o11)              5.244115108584249 - 1.45518047787844 %i
@end example

Results for more general complex arguments:

@example
(%i14) beta_incomplete(0.25+%i,1.0+%i,1.7+%i);
(%o14)             2.726960675662536 - .3831175704269199 %i
(%i15) beta_incomplete(1/2,5/4*%i,2.8+%i);
(%o15)             13.04649635168716 %i - 5.802067956270001
(%i16) 
@end example

Expansion, when @code{beta_expand} is @code{true}:

@example
(%i23) beta_incomplete(a+1,b,z),beta_expand:true;
                                                       b  a
                   a beta_incomplete(a, b, z)   (1 - z)  z
(%o23)             -------------------------- - -----------
                             b + a                 b + a

(%i24) beta_incomplete(a-1,b,z),beta_expand:true;
                                                           b  a - 1
           beta_incomplete(a, b, z) (- b - a + 1)   (1 - z)  z
(%o24)     -------------------------------------- - ---------------
                           1 - a                         1 - a
@end example
 
Derivative and integral for @code{beta_incomplete}:

@example
(%i34) diff(beta_incomplete(a, b, z), z);
                              b - 1  a - 1
(%o34)                 (1 - z)      z
(%i35) integrate(beta_incomplete(a, b, z), z);
              b  a
       (1 - z)  z
(%o35) ----------- + beta_incomplete(a, b, z) z
          b + a
                                       a beta_incomplete(a, b, z)
                                     - --------------------------
                                                 b + a
(%i36) factor(diff(%, z));
(%o36)              beta_incomplete(a, b, z)
@end example

@end deffn

@c -----------------------------------------------------------------------------
@anchor{beta_incomplete_regularized}
@deffn {Function} beta_incomplete_regularized (@var{a}, @var{b}, @var{z})

The regularized incomplete beta function A&S 6.6.2, defined as 
@example
              beta_incomplete(a, b, z)
              ------------------------
                     beta(a, b)
@end example

As for @code{beta_incomplete} this definition is not complete. See 
functions.wolfram.com for a complete definition of 
@code{beta_incomplete_regularized}.

@code{beta_incomplete_regularized} simplifies @var{a} or @var{b} a positive 
integer.

For @math{z=0} and @math{realpart(a)>0}, @code{beta_incomplete_regularized} has 
the specific value 0. For @var{z=1} and @math{realpart(b)>0}, 
@code{beta_incomplete_regularized} simplifies to 1.

Maxima can evaluate @code{beta_incomplete_regularized} for real and complex 
arguments in float and bigfloat precision.

When @code{beta_expand} is @code{true}, Maxima expands 
@code{beta_incomplete_regularized} for arguments @math{a+n} or @math{a-n}, 
where n is an integer.

Maxima knows the derivatives of @code{beta_incomplete_regularized} with respect 
to the variables @var{a}, @var{b}, and @var{z} and the integral with respect to 
the variable @var{z}.

Examples:

Simplification for @var{a} or @var{b} a positive integer:

@example
(%i1) beta_incomplete_regularized(2,b,z);
                                b
(%o1)                1 - (1 - z)  (b z + 1)
(%i2) beta_incomplete_regularized(a,2,z);
                                        a
(%o2)                  (a (1 - z) + 1) z
(%i3) beta_incomplete_regularized(3,2,z);
                                        3
(%o3)                  (3 (1 - z) + 1) z
@end example

For the specific values @math{z=0} and @math{z=1}, Maxima simplifies:

@example
(%i4) assume(a>0,b>0)$

(%i5) beta_incomplete_regularized(a,b,0);
(%o5)                           0
(%i6) beta_incomplete_regularized(a,b,1);
(%o6)                           1
@end example

Numerical evaluation for real and complex arguments in float and bigfloat 
precision:

@example
(%i7) beta_incomplete_regularized(0.12,0.43,0.9);
(%o7)                   .9114011367359802
(%i8) fpprec:32$

(%i9) beta_incomplete_regularized(0.12,0.43,0.9b0);
(%o9)         9.1140113673598075519946998779975b-1
(%i10) beta_incomplete_regularized(1+%i,3/3,1.5*%i);
(%o10)      .2865367499935405 %i - .1229959633346841
(%i11) fpprec:20$

(%i12) beta_incomplete_regularized(1+%i,3/3,1.5b0*%i);
(%o12) 2.8653674999354036142b-1 %i - 1.2299596333468400163b-1
@end example

Expansion, when @code{beta_expand} is @code{true}:

@example
(%i13) beta_incomplete_regularized(a+1,b,z);
                                                     b  a
                                              (1 - z)  z
(%o13) beta_incomplete_regularized(a, b, z) - ------------
                                              a beta(a, b)
(%i14) beta_incomplete_regularized(a-1,b,z);
(%o14) beta_incomplete_regularized(a, b, z)
                                                     b  a - 1
                                              (1 - z)  z
                                         - ----------------------
                                           beta(a, b) (b + a - 1)
@end example

The derivative and the integral wrt @var{z}:

@example
(%i15) diff(beta_incomplete_regularized(a,b,z),z);
                              b - 1  a - 1
                       (1 - z)      z
(%o15)                 -------------------
                           beta(a, b)
(%i16) integrate(beta_incomplete_regularized(a,b,z),z);
(%o16) beta_incomplete_regularized(a, b, z) z
                                                           b  a
                                                    (1 - z)  z
          a (beta_incomplete_regularized(a, b, z) - ------------)
                                                    a beta(a, b)
        - -------------------------------------------------------
                                   b + a
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{beta_incomplete_generalized}
@deffn {Function} beta_incomplete_generalized (@var{a}, @var{b}, @var{z1}, @var{z2})

The basic definition of the generalized incomplete beta function is

@example
                      z2
                     /
                     [          b - 1  a - 1
                     I   (1 - t)      t      dt
                     ]
                     /
                      z1
@end example

Maxima simplifies @code{beta_incomplete_regularized} for @var{a} and @var{b} 
a positive integer.

For @math{realpart(a)>0} and @math{z1=0} or @math{z2=0}, Maxima simplifies
@code{beta_incomplete_generalized} to @code{beta_incomplete}. For 
@math{realpart(b)>0} and @math{z1=1} or @var{z2=1}, Maxima simplifies to an 
expression with @code{beta} and @code{beta_incomplete}.

Maxima evaluates @code{beta_incomplete_regularized} for real and complex values 
in float and bigfloat precision.

When @code{beta_expand} is @code{true}, Maxima expands 
@code{beta_incomplete_generalized} for @math{a+n} and @math{a-n}, @var{n} a 
positive integer.

Maxima knows the derivative of @code{beta_incomplete_generalized} with respect 
to the variables @var{a}, @var{b}, @var{z1}, and @var{z2} and the integrals with
respect to the variables @var{z1} and @var{z2}.

Examples:

Maxima simplifies @code{beta_incomplete_generalized} for @var{a} and @var{b} a 
positive integer:

@example
(%i1) beta_incomplete_generalized(2,b,z1,z2);
                   b                      b
           (1 - z1)  (b z1 + 1) - (1 - z2)  (b z2 + 1)
(%o1)      -------------------------------------------
                            b (b + 1)
(%i2) beta_incomplete_generalized(a,2,z1,z2);
@group
                              a                      a
           (a (1 - z2) + 1) z2  - (a (1 - z1) + 1) z1
(%o2)      -------------------------------------------
                            a (a + 1)
@end group
(%i3) beta_incomplete_generalized(3,2,z1,z2);
              2      2                       2      2
      (1 - z1)  (3 z1  + 2 z1 + 1) - (1 - z2)  (3 z2  + 2 z2 + 1)
(%o3) -----------------------------------------------------------
                                  12
@end example

Simplification for specific values @math{z1=0}, @math{z2=0}, @math{z1=1}, or 
@math{z2=1}:

@example
(%i4) assume(a > 0, b > 0)$
(%i5) beta_incomplete_generalized(a,b,z1,0);
(%o5)                    - beta_incomplete(a, b, z1)

(%i6) beta_incomplete_generalized(a,b,0,z2);
(%o6)                    - beta_incomplete(a, b, z2)

(%i7) beta_incomplete_generalized(a,b,z1,1);
(%o7)              beta(a, b) - beta_incomplete(a, b, z1)

(%i8) beta_incomplete_generalized(a,b,1,z2);
(%o8)              beta_incomplete(a, b, z2) - beta(a, b)
@end example

Numerical evaluation for real arguments in float or bigfloat precision:

@example
(%i9) beta_incomplete_generalized(1/2,3/2,0.25,0.31);
(%o9)                        .09638178086368676

(%i10) fpprec:32$
(%i10) beta_incomplete_generalized(1/2,3/2,0.25,0.31b0);
(%o10)               9.6381780863686935309170054689964b-2
@end example

Numerical evaluation for complex arguments in float or bigfloat precision:

@example
(%i11) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31);
(%o11)           - .09625463003205376 %i - .003323847735353769
(%i12) fpprec:20$
(%i13) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31b0);
(%o13)     - 9.6254630032054178691b-2 %i - 3.3238477353543591914b-3
@end example

Expansion for @math{a+n} or @math{a-n}, @var{n} a positive integer, when 
@code{beta_expand} is @code{true}: 

@example
(%i14) beta_expand:true$

(%i15) beta_incomplete_generalized(a+1,b,z1,z2);

               b   a           b   a
       (1 - z1)  z1  - (1 - z2)  z2
(%o15) -----------------------------
                   b + a
                      a beta_incomplete_generalized(a, b, z1, z2)
                    + -------------------------------------------
                                         b + a
(%i16) beta_incomplete_generalized(a-1,b,z1,z2);

       beta_incomplete_generalized(a, b, z1, z2) (- b - a + 1)
(%o16) -------------------------------------------------------
                                1 - a
                                    b   a - 1           b   a - 1
                            (1 - z2)  z2      - (1 - z1)  z1
                          - -------------------------------------
                                            1 - a
@end example

Derivative wrt the variable @var{z1} and integrals wrt @var{z1} and @var{z2}:

@example
(%i17) diff(beta_incomplete_generalized(a,b,z1,z2),z1);
                               b - 1   a - 1
(%o17)               - (1 - z1)      z1
(%i18) integrate(beta_incomplete_generalized(a,b,z1,z2),z1);
(%o18) beta_incomplete_generalized(a, b, z1, z2) z1
                                  + beta_incomplete(a + 1, b, z1)
(%i19) integrate(beta_incomplete_generalized(a,b,z1,z2),z2);
(%o19) beta_incomplete_generalized(a, b, z1, z2) z2
                                  - beta_incomplete(a + 1, b, z2)
@end example

@end deffn

@c -----------------------------------------------------------------------------
@anchor{beta_expand}
@defvr {Option variable} beta_expand
Default value: false

When @code{beta_expand} is @code{true}, @code{beta(a,b)} and related 
functions are expanded for arguments like @math{a+n} or @math{a-n}, 
where @math{n} is an integer.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{beta_args_sum_to_integer}
@defvr {Option variable} beta_args_sum_to_integer
Default value: false

When @code{beta_args_sum_to_integer} is @code{true}, Maxima simplifies 
@code{beta(a,b)}, when the arguments @var{a} and @var{b} sum to an integer.
@end defvr

@c NEED INFO HERE ABOUT THE SUBSCRIPTED FORM psi[n](x)
@c I (rtoy) don't think there is a plain psi(x) function anymore.
@c @deffn {Function} psi (@var{x})
@c @deffnx {Function} psi [@var{n}](@var{x})

@c -----------------------------------------------------------------------------
@anchor{psi}
@deffn {Function} psi [@var{n}](@var{x})

The derivative of @code{log (gamma (@var{x}))} of order @code{@var{n}+1}.
Thus, @code{psi[0](@var{x})} is the first derivative,
@code{psi[1](@var{x})} is the second derivative, etc.

Maxima does not know how, in general, to compute a numerical value of
@code{psi}, but it can compute some exact values for rational args.
Several variables control what range of rational args @code{psi} will
return an exact value, if possible.  See @code{maxpsiposint},
@code{maxpsinegint}, @code{maxpsifracnum}, and @code{maxpsifracdenom}.
That is, @var{x} must lie between @code{maxpsinegint} and
@code{maxpsiposint}.  If the absolute value of the fractional part of
@var{x} is rational and has a numerator less than @code{maxpsifracnum}
and has a denominator less than @code{maxpsifracdenom}, @code{psi}
will return an exact value.

The function @code{bfpsi} in the @code{bffac} package can compute
numerical values.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{maxpsiposint}
@defvr {Option variable} maxpsiposint
Default value: 20

@code{maxpsiposint} is the largest positive value for which
@code{psi[n](x)} will try to compute an exact value.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{maxpsinegint}
@defvr {Option variable} maxpsinegint
Default value: -10

@code{maxpsinegint} is the most negative value for which
@code{psi[n](x)} will try to compute an exact value.  That is if
@var{x} is less than @code{maxnegint}, @code{psi[n](@var{x})} will not
return simplified answer, even if it could.
@end defvr

@c -----------------------------------------------------------------------------
@defvr {Option variable} maxpsifracnum
Default value: 6

Let @var{x} be a rational number less than one of the form @code{p/q}.
If @code{p} is greater than @code{maxpsifracnum}, then
@code{psi[@var{n}](@var{x})} will not try to return a simplified
value.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{maxpsifracdenom}
@defvr {Option variable} maxpsifracdenom
Default value: 6

Let @var{x} be a rational number less than one of the form @code{p/q}.
If @code{q} is greater than @code{maxpsifracdenom}, then
@code{psi[@var{n}](@var{x})} will not try to return a simplified
value.
@end defvr

@c NEED CROSS REFS HERE
@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{makefact}
@deffn {Function} makefact (@var{expr})

Transforms instances of binomial, gamma, and beta
functions in @var{expr} into factorials.

See also @code{makegamma}.
@end deffn

@c AREN'T THERE OTHER FUNCTIONS THAT DO ESSENTIALLY THE SAME THING ??

@c -----------------------------------------------------------------------------
@anchor{numfactor}
@deffn {Function} numfactor (@var{expr})

Returns the numerical factor multiplying the expression
@var{expr}, which should be a single term.

@c WHY IS content MENTIONED IN THIS CONTEXT ??
@code{content} returns the greatest common divisor (gcd) of all terms in a sum.

@example
(%i1) gamma (7/2);
                          15 sqrt(%pi)
(%o1)                     ------------
                               8
(%i2) numfactor (%);
                               15
(%o2)                          --
                               8
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Exponentielle Integrale, Fehlerfunktionen, Gammafunktionen und verwandte Funktionen, Spezielle Funktionen
@section Exponentielle Integrale
@c -----------------------------------------------------------------------------

The Exponential Integral and related funtions are defined in 
Abramowitz and Stegun,
@i{Handbook of Mathematical Functions}, Chapter 5

@c -----------------------------------------------------------------------------
@anchor{expintegral_e1}
@deffn {Function} expintegral_e1 (@var{z})

The Exponential Integral E1(z) (A&S 5.1.1)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{expintegral_ei}
@deffn {Function} expintegral_ei (@var{z})

The Exponential Integral Ei(z) (A&S 5.1.2)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{expintegral_li}
@deffn {Function} expintegral_li (@var{n},@var{z})

The Exponential Integral Li(z)  (A&S 5.1.3)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{expintegral_e}
@deffn {Function} expintegral_e (@var{n},@var{z})

The Exponential Integral En(z)  (A&S 5.1.4)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{expintegral_si}
@deffn {Function} expintegral_si (@var{z})

The Exponential Integral Si(z) (A&S 5.2.1)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{expintegral_ci}
@deffn {Function} expintegral_ci (@var{z})

The Exponential Integral Ci(z) (A&S 5.2.2)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{expintegral_shi}
@deffn {Function} expintegral_shi (@var{z})

The Exponential Integral Shi(z) (A&S 5.2.3)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{expintegral_chi}
@deffn {Function} expintegral_chi (@var{z})

The Exponential Integral Chi(z) (A&S 5.2.4)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{expintrep}
@defvr {Option variable} expintrep
Default value: false

Change the representation of the Exponential Integral to
  gamma_incomplete, expintegral_e1, expintegral_ei, 
  expintegral_li, expintegral_trig, expintegral_hyp
@end defvr

@c -----------------------------------------------------------------------------
@anchor{expintexpand}
@defvr {Option variable} expintexpand 
Default value: false

Expand the Exponential Integral E[n](z)
for half integral values in terms of Erfc or Erf and
for positive integers in terms of Ei 
@end defvr

@c -----------------------------------------------------------------------------
@node Fehlerfunktionen, Elliptische Funktionen und Integrale, Exponentielle Integrale, Spezielle Funktionen
@section Fehlerfunktionen
@c -----------------------------------------------------------------------------

The Error function and related funtions are defined in 
Abramowitz and Stegun,
@i{Handbook of Mathematical Functions}, Chapter 7

@c -----------------------------------------------------------------------------
@anchor{erf}
@deffn {Function} erf (@var{z})

The Error Function erf(z) (A&S 7.1.1)

See also flag @code{erfflag}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{erfc}
@deffn {Function} erfc (@var{z})

The Complementary Error Function erfc(z) (A&S 7.1.2)

@code{erfc(z) = 1-erf(z)}
@end deffn

@c -----------------------------------------------------------------------------
@anchor{erfi}
@deffn {Function} erfi (@var{z})

The Imaginary Error Function. 

@code{erfi(z) = -%i*erf(%i*z)}
@end deffn

@c -----------------------------------------------------------------------------
@anchor{erf_generalized}
@deffn {Function} erf_generalized (@var{z1},@var{z2})

Generalized Error function Erf(z1,z2)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{fresnel_c}
@deffn {Function} fresnel_c (@var{z})

The Fresnel Integral C(z) = integrate(cos((%pi/2)*t^2),t,0,z). (A&S 7.3.1)

The simplification fresnel_c(-x) = -fresnel_c(x) is applied when
flag @code{trigsign} is true.

The simplification fresnel_c(%i*x) =  %i*fresnel_c(x) is applied when
flag @code{%iargs} is true.

See flags @code{erf_representation} and @code{hypergeometric_representation}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{fresnel_s}
@deffn {Function} fresnel_s (@var{z})

The Fresnel Integral S(z) = integrate(sin((%pi/2)*t^2),t,0,z). (A&S 7.3.2)

The simplification fresnel_s(-x) = -fresnel_s(x) is applied when
flag @code{trigsign} is true.

The simplification fresnel_s(%i*x) =  %i*fresnel_s(x) is applied when
flag @code{%iargs} is true.

See flags @code{erf_representation} and @code{hypergeometric_representation}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{erf_representation}
@defvr {Option variable} erf_representation
Default value: false

When T erfc, erfi, erf_generalized, fresnel_s 
and fresnel_c are transformed to erf.
@end defvr

@defvr {Option variable} hypergeometric_representation
Default value: false

Enables transformation to a Hypergeometric
representation for fresnel_s and fresnel_c
@end defvr

@c -----------------------------------------------------------------------------
@node Elliptische Funktionen und Integrale, Hypergeometrische Funktionen, Fehlerfunktionen, Spezielle Funktionen
@section Elliptische Funktionen und Integrale
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Elliptische Funktionen und Integrale::
* Funktionen und Variablen f@"ur Elliptische Funktionen::
* Funktionen und Variablen f@"ur Elliptische Integrale::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Elliptische Funktionen und Integrale, Funktionen und Variablen f@"ur Elliptische Funktionen, Elliptische Funktionen und Integrale, Elliptische Funktionen und Integrale
@subsection Einf@"uhrung in Elliptische Funktionen und Integrale
@c -----------------------------------------------------------------------------

Maxima includes support for Jacobian elliptic functions and for
complete and incomplete elliptic integrals.  This includes symbolic
manipulation of these functions and numerical evaluation as well.
Definitions of these functions and many of their properties can by
found in Abramowitz and Stegun, Chapter 16--17.  As much as possible,
we use the definitions and relationships given there.

In particular, all elliptic functions and integrals use the parameter
@math{m} instead of the modulus @math{k} or the modular angle
@math{\alpha}.  This is one area where we differ from Abramowitz and
Stegun who use the modular angle for the elliptic functions.  The
following relationships are true:
@ifinfo
@math{m = k^2} and @math{k = \sin(\alpha)}
@end ifinfo
@tex
$$m = k^2$$ and $$k = \sin\alpha $$
@end tex

The elliptic functions and integrals are primarily intended to support
symbolic computation.  Therefore, most of derivatives of the functions
and integrals are known.  However, if floating-point values are given,
a floating-point result is returned.

Support for most of the other properties of elliptic functions and
integrals other than derivatives has not yet been written.

Some examples of elliptic functions:

@example
(%i1) jacobi_sn (u, m);
(%o1)                    jacobi_sn(u, m)
(%i2) jacobi_sn (u, 1);
(%o2)                        tanh(u)
(%i3) jacobi_sn (u, 0);
(%o3)                        sin(u)
(%i4) diff (jacobi_sn (u, m), u);
(%o4)            jacobi_cn(u, m) jacobi_dn(u, m)
(%i5) diff (jacobi_sn (u, m), m);
(%o5) jacobi_cn(u, m) jacobi_dn(u, m)

      elliptic_e(asin(jacobi_sn(u, m)), m)
 (u - ------------------------------------)/(2 m)
                     1 - m

            2
   jacobi_cn (u, m) jacobi_sn(u, m)
 + --------------------------------
              2 (1 - m)
@end example

Some examples of elliptic integrals:

@example
(%i1) elliptic_f (phi, m);
(%o1)                  elliptic_f(phi, m)
(%i2) elliptic_f (phi, 0);
(%o2)                          phi
(%i3) elliptic_f (phi, 1);
                               phi   %pi
(%o3)                  log(tan(--- + ---))
                                2     4
(%i4) elliptic_e (phi, 1);
(%o4)                       sin(phi)
(%i5) elliptic_e (phi, 0);
(%o5)                          phi
(%i6) elliptic_kc (1/2);
                                     1
(%o6)                    elliptic_kc(-)
                                     2
(%i7) makegamma (%);
                                 2 1
                            gamma (-)
                                   4
(%o7)                      -----------
                           4 sqrt(%pi)
(%i8) diff (elliptic_f (phi, m), phi);
                                1
(%o8)                 ---------------------
                                    2
                      sqrt(1 - m sin (phi))
(%i9) diff (elliptic_f (phi, m), m);
       elliptic_e(phi, m) - (1 - m) elliptic_f(phi, m)
(%o9) (-----------------------------------------------
                              m

                                 cos(phi) sin(phi)
                             - ---------------------)/(2 (1 - m))
                                             2
                               sqrt(1 - m sin (phi))
@end example

Support for elliptic functions and integrals was written by Raymond
Toy.  It is placed under the terms of the General Public License (GPL)
that governs the distribution of Maxima.

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Elliptische Funktionen, Funktionen und Variablen f@"ur Elliptische Integrale, Einf@"uhrung in Elliptische Funktionen und Integrale, Elliptische Funktionen und Integrale
@subsection Funktionen und Variablen f@"ur Elliptische Funktionen
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_sn (@var{u}, @var{m})
The Jacobian elliptic function @math{sn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_cn (@var{u}, @var{m})
The Jacobian elliptic function @math{cn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_dn (@var{u}, @var{m})
The Jacobian elliptic function @math{dn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_ns (@var{u}, @var{m})
The Jacobian elliptic function @math{ns(u,m) = 1/sn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_sc (@var{u}, @var{m})
The Jacobian elliptic function @math{sc(u,m) = sn(u,m)/cn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_sd (@var{u}, @var{m})
The Jacobian elliptic function @math{sd(u,m) = sn(u,m)/dn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_nc (@var{u}, @var{m})
The Jacobian elliptic function @math{nc(u,m) = 1/cn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_cs (@var{u}, @var{m})
The Jacobian elliptic function @math{cs(u,m) = cn(u,m)/sn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_cd (@var{u}, @var{m})
The Jacobian elliptic function @math{cd(u,m) = cn(u,m)/dn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_nd (@var{u}, @var{m})
The Jacobian elliptic function @math{nc(u,m) = 1/cn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_ds (@var{u}, @var{m})
The Jacobian elliptic function @math{ds(u,m) = dn(u,m)/sn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} jacobi_dc (@var{u}, @var{m})
The Jacobian elliptic function @math{dc(u,m) = dn(u,m)/cn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_sn (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{sn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_cn (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{cn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_dn (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{dn(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_ns (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{ns(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_sc (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{sc(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_sd (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{sd(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_nc (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{nc(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_cs (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{cs(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_cd (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{cd(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_nd (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{nc(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_ds (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{ds(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} inverse_jacobi_dc (@var{u}, @var{m})
The inverse of the Jacobian elliptic function @math{dc(u,m)}.
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Elliptische Integrale, , Funktionen und Variablen f@"ur Elliptische Funktionen, Elliptische Funktionen und Integrale
@subsection Funktionen und Variablen f@"ur Elliptische Integrale
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{elliptic_f}
@deffn {Function} elliptic_f (@var{phi}, @var{m})

The incomplete elliptic integral of the first kind, defined as

@ifhtml
@math{integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifhtml
@ifinfo
@math{integrate(1/sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifinfo

@tex
$$\int_0^\phi {{d\theta}\over{\sqrt{1 - m\sin^2\theta}}}$$
@end tex

See also @ref{elliptic_e} and @ref{elliptic_kc}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{elliptic_e}
@deffn {Function} elliptic_e (@var{phi}, @var{m})

The incomplete elliptic integral of the second kind, defined as

@ifhtml
@math{elliptic_e(phi, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifhtml
@ifinfo
@math{elliptic_e(phi, m) = integrate(sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifinfo
@tex
$$\int_0^\phi \sqrt{1 - m\sin^2\theta} d\theta$$
@end tex

See also @ref{elliptic_e} and @ref{elliptic_ec}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{elliptic_eu}
@deffn {Function} elliptic_eu (@var{u}, @var{m})

The incomplete elliptic integral of the second kind, defined as

@ifhtml
@math{integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2), t, 0, tau)}

where @math{tau = sn(u,m)}.
@end ifhtml
@ifinfo
@math{integrate(dn(v,m)^2,v,0,u) = integrate(sqrt(1-m*t^2)/sqrt(1-t^2), t, 0, tau)}

where @math{tau = sn(u,m)}.
@end ifinfo
@tex
$$\int_0^u {\rm dn}(v, m) dv  = \int_0^\tau \sqrt{{1-m t^2}\over{1-t^2}} dt$$

where $\tau = {\rm sn}(u, m)$.
@end tex

This is related to @math{elliptic_e} by

@ifhtml
@math{elliptic_eu(u, m) = elliptic_e(asin(sn(u,m)),m)}
@end ifhtml
@ifinfo
@math{elliptic_eu(u, m) = elliptic_e(asin(sn(u,m)),m)}
@end ifinfo
@tex
$$E(u,m) = E(\phi, m)$$

where $\phi = \sin^{-1} {\rm sn}(u, m)$.
@end tex

See also @ref{elliptic_e}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{elliptic_pi}
@deffn {Function} elliptic_pi (@var{n}, @var{phi}, @var{m})
The incomplete elliptic integral of the third kind, defined as

@ifhtml
@math{integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifhtml
@ifinfo
@math{integrate(1/(1-n*sin(x)^2)/sqrt(1 - m*sin(x)^2), x, 0, phi)}
@end ifinfo
@tex
$$\int_0^\phi {{d\theta}\over{(1-n\sin^2 \theta)\sqrt{1 - m\sin^2\theta}}}$$
@end tex

Only the derivative with respect to @math{phi} is known by Maxima.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{elliptic_kc}
@deffn {Function} elliptic_kc (@var{m})
The complete elliptic integral of the first kind, defined as

@ifhtml
@math{integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)}
@end ifhtml
@ifinfo
@math{integrate(1/sqrt(1 - m*sin(x)^2), x, 0, %pi/2)}
@end ifinfo

@tex
$$\int_0^{{\pi}\over{2}} {{d\theta}\over{\sqrt{1 - m\sin^2\theta}}}$$
@end tex
For certain values of @math{m}, the value of the integral is known in
terms of @math{Gamma} functions.  Use @code{makegamma} to evaluate them.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{elliptic_ec}
@deffn {Function} elliptic_ec (@var{m})
The complete elliptic integral of the second kind, defined as

@ifhtml
@math{integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)}
@end ifhtml
@ifinfo
@math{integrate(sqrt(1 - m*sin(x)^2), x, 0, %pi/2)}
@end ifinfo

@tex
$$\int_0^{{\pi}\over{2}} \sqrt{1 - m\sin^2\theta} d\theta$$
@end tex
For certain values of @math{m}, the value of the integral is known in
terms of @math{Gamma} functions.  Use @code{makegamma} to evaluate them.
@end deffn

@c -----------------------------------------------------------------------------
@node Hypergeometrische Funktionen, Funktionen und Variablen f@"ur spezielle Funktionen, Elliptische Funktionen und Integrale, Spezielle Funktionen
@section Hypergeometrische Funktionen
@c -----------------------------------------------------------------------------

The Hypergeometric Functions are defined in Abramowitz and Stegun,
@i{Handbook of Mathematical Functions}, Chapters 13 and 15.

Maxima has very limited knowledge of these functions.  They
can be returned from function @code{hgfred}.

@c -----------------------------------------------------------------------------
@anchor{%m}
@deffn {Function} %m [@var{k},@var{u}] (@var{z}) 

Whittaker M function
@code{M[k,u](z) = exp(-z/2)*z^(1/2+u)*M(1/2+u-k,1+2*u,z)}.  
(A&S 13.1.32)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{%w}
@deffn {Function} %w [@var{k},@var{u}] (@var{z}) 

Whittaker W function.  (A&S 13.1.33)
@end deffn

@c -----------------------------------------------------------------------------
@anchor{%f}
@deffn {Function} %f [@var{p},@var{q}] (@var{[a],[b],z}) 

The pFq(a1,a2,..ap;b1,b2,..bq;z) hypergeometric function,
where @code{a} a list of length @code{p} and 
@code{b} a list of length @code{q}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{hypergeometric}
@deffn {Function} hypergeometric ([@var{a1}, @dots{}, @var{ap}],[@var{b1}, @dots{} ,@var{bq}], x)

The hypergeometric function. Unlike Maxima's @code{%f} hypergeometric
function, the function @code{hypergeometric} is a simplifying
function; also, @code{hypergeometric} supports complex double and
big floating point evaluation. For the Gauss hypergeometric function,
that is @math{p = 2} and @math{q = 1}, floating point evaluation
outside the unit circle is supported, but in general, it is not
supported.

When the option variable @code{expand_hypergeometric} is true (default
is false) and one of the arguments @code{a1} through @code{ap} is a
negative integer (a polynomial case), @code{hypergeometric} returns an
expanded polynomial. 

Examples:

@example
 (%i1)  hypergeometric([],[],x);
 (%o1) %e^x
@end example

Polynomial cases automatically expand when @code{expand_hypergeometric} is true:

@example
 (%i2) hypergeometric([-3],[7],x);
 (%o2) hypergeometric([-3],[7],x)

 (%i3) hypergeometric([-3],[7],x), expand_hypergeometric : true;
 (%o3) -x^3/504+3*x^2/56-3*x/7+1
@end example

Both double float and big float evaluation is supported:

@example
(%i4) hypergeometric([5.1],[7.1 + %i],0.42);
(%o4)       1.346250786375334 - 0.0559061414208204 %i
(%i5) hypergeometric([5,6],[8], 5.7 - %i);
(%o5)     .007375824009774946 - .001049813688578674 %i
(%i6) hypergeometric([5,6],[8], 5.7b0 - %i), fpprec : 30;
(%o6) 7.37582400977494674506442010824b-3
                          - 1.04981368857867315858055393376b-3 %i
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{parabolic_cylinder_d}
@deffn {Function} parabolic_cylinder_d (@var{v}, @var{z}) 

The parabolic cylinder function @code{parabolic_cylinder_d(v,z)}. (A&s 19.3.1)

The Parabolic Cylinder Functions are defined in Abramowitz and Stegun,
@i{Handbook of Mathematical Functions}, Chapter 19.

Maxima has very limited knowledge of these functions.  They
can be returned from function @code{hgfred}.
@end deffn

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur spezielle Funktionen,  , Hypergeometrische Funktionen, Spezielle Funktionen
@section Funktionen und Variablen f@"ur spezielle Funktionen
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{li}
@deffn {Funktion} li [@var{s}] (@var{z})

@c Represents the polylogarithm function of order @var{s} and argument @var{z},
@c defined by the infinite series

ist der Polylogarithmus der Ordnung @var{s} und dem Argument @var{z}. Der
Polylogarithmus wird durch die folgende Reihe definiert werden:

@tex
$${\rm Li}_s \left(z\right) = \sum_{k=1}^\infty {z^k \over k^s}$$
@end tex
@ifnottex
@example
                                 inf
                                 ====   k
                                 \     z
                        Li (z) =  >    --
                          s      /      s
                                 ====  k
                                 k = 1
@end example
@end ifnottex

@c @code{li [1]} is @code{- log (1 - z)}. @code{li [2]} and @code{li [3]} are 
@c the dilogarithm and trilogarithm functions, respectively.

F@"ur @var{s=1} geht der Polylogarithmus in die gew@"ohnliche Logarithmusfunktion 
@"uber und man erh@"alt @code{-log(1-z)}. F@"ur @var{s=2} oder @var{s=3} spricht man
vom Dilogarithmus oder Trilogarithmus.

@c When the order is 1, the polylogarithm simplifies to @code{- log (1 - z)},
@c which in turn simplifies to a numerical value if @var{z} is a real or complex
@c floating point number or the @code{numer} evaluation flag is present.

Maxima vereinfacht f@"ur @var{s=1} sofort zum gew@"ohnlichen Logarithmus. 
F@"ur negative ganze Zahlen @var{s} einschlie@ss{}lich der Null vereinfacht Maxima
den Polylogarithmus zu einer rationalen Funktion.

@c When the order is 2 or 3, the polylogarithm simplifies to a numerical value
@c if @var{z} is a real floating point number or the @code{numer} evaluation 
@c flag is present.

Ist @var{s=2} oder @var{s=3} und das Argument @var{z} eine Gleitkommazahl, 
vereinfacht Maxima den Di- oder Trilogarithmus zu einer Gleitkommazahl.

Beispiele:

@example
(%i1) assume (x > 0);
(%o1)                        [x > 0]
(%i2) integrate ((log (1 - t)) / t, t, 0, x);
(%o2)                       - li (x)
                                2
(%i3) li [2] (7);
(%o3)                        li (7)
                               2
(%i4) li [2] (7), numer;
(%o4)        1.24827317833392 - 6.113257021832577 %i
(%i5) li [3] (7);
(%o5)                        li (7)
                               3
(%i6) li [2] (7), numer;
(%o6)        1.24827317833392 - 6.113257021832577 %i
(%i7) L : makelist (i / 4.0, i, 0, 8);
(%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
(%i8) map (lambda ([x], li [2] (x)), L);
(%o8) [0, .2676526384986274, .5822405249432515, 
.9784693966661848, 1.64493407, 2.190177004178597
 - .7010261407036192 %i, 2.374395264042415
 - 1.273806203464065 %i, 2.448686757245154
 - 1.758084846201883 %i, 2.467401098097648
 - 2.177586087815347 %i]
(%i9) map (lambda ([x], li [3] (x)), L);
(%o9) [0, .2584613953442624, 0.537213192678042, 
.8444258046482203, 1.2020569, 1.642866878950322
 - .07821473130035025 %i, 2.060877505514697
 - .2582419849982037 %i, 2.433418896388322
 - .4919260182322965 %i, 2.762071904015935
 - .7546938285978846 %i]
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{specint}
@deffn {Function} specint (exp(- s*@var{t}) * @var{expr}, @var{t})

Compute the Laplace transform of @var{expr} with respect to the variable @var{t}.
The integrand @var{expr} may contain special functions. 

The following special functions are handled by @code{specint}: incomplete gamma 
function, error functions (but not the error function @code{erfi}, it is easy to 
transform @code{erfi} e.g. to the error function @code{erf}), exponential 
integrals, bessel functions (including products of bessel functions), hankel 
functions, hermite and the laguerre polynomials.

Furthermore, @code{specint} can handle the hypergeometric function 
@code{%f[p,q]([],[],z)}, the whittaker function of the first kind 
@code{%m[u,k](z)} and of the second kind @code{%w[u,k](z)}.

The result may be in terms of special functions and can include unsimplified 
hypergeomtric functions.

When @code{laplace} fails to find a Laplace transform, @code{specint} is called. 
Because @code{laplace} knows more general rules for Laplace transforms, it is 
preferable to use @code{laplace} and not @code{specint}.

@code{demo(hypgeo)} displays several examples of Laplace transforms computed by 
@code{specint}.

Examples:

@example
(%i1) assume (p > 0, a > 0)$
(%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                           sqrt(%pi)
(%o2)                     ------------
                                 a 3/2
                          2 (p + -)
                                 4
(%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
              * exp(-p*t), t);
                                   - a/p
                         sqrt(a) %e
(%o3)                    ---------------
                                2
                               p
@end example

Examples for exponential integrals:

@example
(%i4) assume(s>0,a>0,s-a>0)$
(%i5) ratsimp(specint(%e^(a*t)
                      *(log(a)+expintegral_e1(a*t))*%e^(-s*t),t));
                             log(s)
(%o5)                        ------
                             s - a
(%i6) logarc:true$

(%i7) gamma_expand:true$

radcan(specint((cos(t)*expintegral_si(t)
                     -sin(t)*expintegral_ci(t))*%e^(-s*t),t));
                             log(s)
(%o8)                        ------
                              2
                             s  + 1
ratsimp(specint((2*t*log(a)+2/a*sin(a*t)
                      -2*t*expintegral_ci(a*t))*%e^(-s*t),t));
                               2    2
                          log(s  + a )
(%o9)                     ------------
                                2
                               s
@end example

Results when using the expansion of @code{gamma_incomplete} and when changing 
the representation to @code{expintegral_e1}:

@example
(%i10) assume(s>0)$
(%i11) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                            1
                            gamma_incomplete(-, k s)
                                            2
(%o11)                      ------------------------
                               sqrt(%pi) sqrt(s)

(%i12) gamma_expand:true$
(%i13) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                              erfc(sqrt(k) sqrt(s))
(%o13)                        ---------------------
                                     sqrt(s)

(%i14) expintrep:expintegral_e1$
(%i15) ratsimp(specint(1/(t+a)^2*%e^(-s*t),t));
                              a s
                        a s %e    expintegral_e1(a s) - 1
(%o15)                - ---------------------------------
                                        a
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{hgfred}
@deffn {Function} hgfred (@var{a}, @var{b}, @var{t})

Simplify the generalized hypergeometric function in terms of other,
simpler, forms.  @var{a} is a list of numerator parameters and @var{b}
is a list of the denominator parameters. 

If @code{hgfred} cannot simplify the hypergeometric function, it returns
an expression of the form @code{%f[p,q]([a], [b], x)} where @var{p} is
the number of elements in @var{a}, and @var{q} is the number of elements
in @var{b}.  This is the usual @code{pFq} generalized hypergeometric
function. 

@example
(%i1) assume(not(equal(z,0)));
(%o1)                          [notequal(z, 0)]
(%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                     v/2                               %i z
                    4    bessel_j(v, z) gamma(v + 1) %e
(%o2)               ---------------------------------------
                                       v
                                      z
(%i3) hgfred([1,1],[2],z);

                                   log(1 - z)
(%o3)                            - ----------
                                       z
(%i4) hgfred([a,a+1/2],[3/2],z^2);

                               1 - 2 a          1 - 2 a
                        (z + 1)        - (1 - z)
(%o4)                   -------------------------------
                                 2 (1 - 2 a) z

@end example

It can be beneficial to load orthopoly too as the following example
shows.  Note that @var{L} is the generalized Laguerre polynomial.

@example
(%i5) load(orthopoly)$
(%i6) hgfred([-2],[a],z);

                                    (a - 1)
                                 2 L       (z)
                                    2
(%o6)                            -------------
                                   a (a + 1)
(%i7) ev(%);

                                  2
                                 z        2 z
(%o7)                         --------- - --- + 1
                              a (a + 1)    a

@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{lambert_w}
@deffn {Function} lambert_w (@var{z})

The principal branch of Lambert's W funtion W(z), the solution of 
@code{z = W(z) * exp(W(z))}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{nzeta}
@deffn {Function} nzeta (@var{z})

The Plasma Dispersion Function 
@code{nzeta(z) = %i*sqrt(%pi)*exp(-z^2)*(1-erf(-%i*z))}
@end deffn

@c -----------------------------------------------------------------------------
@anchor{nzetar}
@deffn {Function} nzetar (@var{z})

Returns @code{realpart(nzeta(z))}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{nzetai}
@deffn {Function} nzetai (@var{z})

Returns @code{imagpart(nzeta(z))}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{%s}
@deffn {Function} %s [@var{u},@var{v}] (@var{z}) 

Lommel's little s[u,v](z) function.  
Probably Gradshteyn & Ryzhik 8.570.1.
@end deffn

@c --- End of file Special.de.texi ---------------------------------------------

