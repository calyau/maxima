@c Language: German
@c English original: Command.texi CVS 1.41

@menu
* Einführung in die Kommandozeile::
* Definitionen für die Kommandozeile::
@end menu

@node Einführung in die Kommandozeile, Definitionen für die Kommandozeile, Kommandozeile, Kommandozeile
@section Einführung in die Kommandozeile

@c NEEDS EXAMPLES
@c THIS ITEM IS VERY IMPORTANT !!
@deffn {Operator} '
Der Quotierungsoperator @code{'} (Hochkomma, "single quote operator")
verhindert die Auswertung.

Auf ein Symbol angewandt, verhindert das Hochkomma die Auswertung des Symbols.

Auf einen Funktionsaufruf angewandt, verhindert das Hochkomma die Auswertung 
des Funktionsaufrufs, obwohl die Argumente der Funktion nach wie vor ausgewertet werden
(falls deren Auswertung nicht anders verhindert wird).
Das Ergebnis ist die Substantivform des Funktionsaufrufs. 

Auf einen eingeklammerten Ausdruck angewandt, verhindert das Hochkomma die Auswertung
aller Symbole und Funktionsaufrufe in diesem Ausdruck. 
@c DUNNO IF THESE EXAMPLES ARE STILL NEEDED -- COVERED BY ITEMS UNDER "Examples"
Z.B. bedeutet @code{'(f(x))}, dass der Ausdruck @code{f(x)} nicht ausgewertet wird.
@code{'f(x)} (das Hochkomma angewandt auf @code{f} statt auf @code{f(x)}) 
bedeutet, dass die Substantivform von @code{f} angewandt auf @code{[x]} 
(im Sinne von @code{apply}) zurückgegeben wird.

Ein einzelnes Hochkomma verhindert keine Vereinfachungen.

Wenn der globale Schalter @code{noundisp} @code{true} ist, 
werden Substantive mit einem Hochkomma versehen angezeigt.
Dieser Schalter ist stets @code{true}, wenn eine Funktionsdefinition angezeigt wird.

Siehe auch den Quote-Quote-Operator @code{''} und @code{nouns}.

Beispiele:

Auf ein Symbol angewandt, verhindert das Hochkomma die Auswertung des Symbols.

@c ===beg===
@c aa: 1024;
@c aa^2;
@c 'aa^2;
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) aa^2;
(%o2)                        1048576
(%i3) 'aa^2;
                                 2
(%o3)                          aa
(%i4) ''%;
(%o4)                        1048576
@end example

Auf einen Funktionsaufruf angewandt, verhindert das Hochkomma die Auswertung 
des Funktionsaufrufs. Das Ergebnis ist die Substantivform des Funktionsaufrufs. 

@c ===beg===
@c x0: 5;
@c x1: 7;
@c integrate (x^2, x, x0, x1);
@c 'integrate (x^2, x, x0, x1);
@c %, nouns;
@c ===end===
@example
(%i1) x0: 5;
(%o1)                           5
(%i2) x1: 7;
(%o2)                           7
(%i3) integrate (x^2, x, x0, x1);
                               218
(%o3)                          ---
                                3
(%i4) 'integrate (x^2, x, x0, x1);
                             7
                            /
                            [   2
(%o4)                       I  x  dx
                            ]
                            /
                             5
(%i5) %, nouns;
                               218
(%o5)                          ---
                                3
@end example

Auf einen eingeklammerten Ausdruck angewandt, verhindert das Hochkomma die 
Auswertung aller Symbole und Funktionsaufrufe in diesem Ausdruck.


@c ===beg===
@c aa: 1024;
@c bb: 19;
@c sqrt(aa) + bb;
@c '(sqrt(aa) + bb);
@c ''%;
@c ===end===
@example
(%i1) aa: 1024;
(%o1)                         1024
(%i2) bb: 19;
(%o2)                          19
(%i3) sqrt(aa) + bb;
(%o3)                          51
(%i4) '(sqrt(aa) + bb);
(%o4)                     bb + sqrt(aa)
(%i5) ''%;
(%o5)                          51
@end example

Ein einzelnes Hochkomma verhindert keine Vereinfachungen.

@c ===beg===
@c sin (17 * %pi) + cos (17 * %pi);
@c '(sin (17 * %pi) + cos (17 * %pi));
@c ===end===
@example
(%i1) sin (17 * %pi) + cos (17 * %pi);
(%o1)                          - 1
(%i2) '(sin (17 * %pi) + cos (17 * %pi));
(%o2)                          - 1
@end example

@end deffn

@deffn {Operator} ''
Der Quote-Quote-Operator @code{'@w{}'} (zwei einzelne Hochkommata) verändert 
die Auswertung der eingegebenen Ausdrücke.

Auf einen allgemeinen Ausdruck @var{expr} angewandt, bewirkt Quote-Quote,
dass der Wert von @var{expr} für @var{expr} in den eingegebenen Ausdruck eingesetzt wird.

Angewandt auf den Operator eines Ausdrucks, ändert Quote-Quote
den Operator von einem Substantiv in ein Verb (sollte er nicht bereits ein Verb sein).

Der Quote-Quote-Operator wird durch den Eingabeparser angewandt;
er wird nicht als Teil des geparsten Eingabeausdrucks gespeichert.
Quote-Quote wird stets angewandt, sobald er geparst wird, und kann nicht quotiert werden. 
So bewirkt Quote-Quote eine Auswertung, auch wenn die Auswertung auf anderem Wege
unterdrückt wird, so zum Beispiel in Funktionsdefinitionen, Lambda-Ausdrücken
und Ausdrücken, die durch ein Hochkomma (Operator @code{'}) quotiert sind.

Quote-Quote wird von @code{batch} und @code{load} erkannt.

Siehe auch den Quotierungsoperator @code{'} und @code{nouns}.

Beispiele:

Auf einen allgemeinen Ausdruck @var{expr} angewandt, bewirkt Quote-Quote,
dass der Wert von @var{expr} für @var{expr} in den eingegebenen Ausdruck eingesetzt wird.

@c ===beg===
@c expand ((a + b)^3);
@c [_, ''_];
@c [%i1, ''%i1];
@c [aa : cc, bb : dd, cc : 17, dd : 29];
@c foo_1 (x) := aa - bb * x;
@c foo_1 (10);
@c ''%;
@c ''(foo_1 (10));
@c foo_2 (x) := ''aa - ''bb * x;
@c foo_2 (10);
@c [x0 : x1, x1 : x2, x2 : x3];
@c x0;
@c ''x0;
@c '' ''x0;
@c ===end===
@example
(%i1) expand ((a + b)^3);
                     3        2      2      3
(%o1)               b  + 3 a b  + 3 a  b + a
(%i2) [_, ''_];
                         3    3        2      2      3
(%o2)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i3) [%i1, ''%i1];
                         3    3        2      2      3
(%o3)     [expand((b + a) ), b  + 3 a b  + 3 a  b + a ]
(%i4) [aa : cc, bb : dd, cc : 17, dd : 29];
(%o4)                   [cc, dd, 17, 29]
(%i5) foo_1 (x) := aa - bb * x;
(%o5)                 foo_1(x) := aa - bb x
(%i6) foo_1 (10);
(%o6)                      cc - 10 dd
(%i7) ''%;
(%o7)                         - 273
(%i8) ''(foo_1 (10));
(%o8)                         - 273
(%i9) foo_2 (x) := ''aa - ''bb * x;
(%o9)                 foo_2(x) := cc - dd x
(%i10) foo_2 (10);
(%o10)                        - 273
(%i11) [x0 : x1, x1 : x2, x2 : x3];
(%o11)                    [x1, x2, x3]
(%i12) x0;
(%o12)                         x1
(%i13) ''x0;
(%o13)                         x2
(%i14) '' ''x0;
(%o14)                         x3
@end example

Angewandt auf den Operator eines Ausdrucks, ändert Quote-Quote
den Operator von einem Substantiv in ein Verb (sollte er nicht bereits ein Verb sein).

@c ===beg==
@c sin (1);
@c ''sin (1);
@c declare (foo, noun);
@c foo (x) := x - 1729;
@c foo (100);
@c ''foo (100);
@c ===end==
@example
(%i1) sin (1);
(%o1)                        sin(1)
(%i2) ''sin (1);
(%o2)                    0.8414709848079
(%i3) declare (foo, noun);
(%o3)                         done
(%i4) foo (x) := x - 1729;
(%o4)                 ''foo(x) := x - 1729
(%i5) foo (100);
(%o5)                       foo(100)
(%i6) ''foo (100);
(%o6)                        - 1629
@end example

Der Quote-Quote-Operator wird durch den Eingabeparser angewandt;
er wird nicht als Teil des geparsten Eingabeausdrucks gespeichert.

@c ===beg===
@c [aa : bb, cc : dd, bb : 1234, dd : 5678];
@c aa + cc;
@c display (_, op (_), args (_));
@c ''(aa + cc);
@c display (_, op (_), args (_));
@c ===end===
@example
(%i1) [aa : bb, cc : dd, bb : 1234, dd : 5678];
(%o1)                 [bb, dd, 1234, 5678]
(%i2) aa + cc;
(%o2)                        dd + bb
(%i3) display (_, op (_), args (_));
                           _ = cc + aa

                         op(cc + aa) = +

                    args(cc + aa) = [cc, aa]

(%o3)                         done
(%i4) ''(aa + cc);
(%o4)                         6912
(%i5) display (_, op (_), args (_));
                           _ = dd + bb

                         op(dd + bb) = +

                    args(dd + bb) = [dd, bb]

(%o5)                         done
@end example

Quote-Quote bewirkt eine Auswertung, auch wenn die Auswertung auf anderem Wege
unterdrückt wird, so zum Beispiel in Funktionsdefinitionen, Lambda-Ausdrücken
und Ausdrücken, die durch ein Hochkomma (Operator @code{'}) quotiert sind.

@c ===beg===
@c foo_1a (x) := ''(integrate (log (x), x));
@c foo_1b (x) := integrate (log (x), x);
@c dispfun (foo_1a, foo_1b);
@c integrate (log (x), x);
@c foo_2a (x) := ''%;
@c foo_2b (x) := %;
@c dispfun (foo_2a, foo_2b);
@c F : lambda ([u], diff (sin (u), u));
@c G : lambda ([u], ''(diff (sin (u), u)));
@c '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
@c '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
@c ===end===
@example
(%i1) foo_1a (x) := ''(integrate (log (x), x));
(%o1)               foo_1a(x) := x log(x) - x
(%i2) foo_1b (x) := integrate (log (x), x);
(%o2)           foo_1b(x) := integrate(log(x), x)
(%i3) dispfun (foo_1a, foo_1b);
(%t3)               foo_1a(x) := x log(x) - x

(%t4)           foo_1b(x) := integrate(log(x), x)

(%o4)                      [%t3, %t4]
(%i4) integrate (log (x), x);
(%o4)                     x log(x) - x
(%i5) foo_2a (x) := ''%;
(%o5)               foo_2a(x) := x log(x) - x
(%i6) foo_2b (x) := %;
(%o6)                    foo_2b(x) := %
(%i7) dispfun (foo_2a, foo_2b);
(%t7)               foo_2a(x) := x log(x) - x

(%t8)                    foo_2b(x) := %

(%o8)                      [%t7, %t8]
(%i8) F : lambda ([u], diff (sin (u), u));
(%o8)             lambda([u], diff(sin(u), u))
(%i9) G : lambda ([u], ''(diff (sin (u), u)));
(%o9)                  lambda([u], cos(u))
(%i10) '(sum (a[k], k, 1, 3) + sum (b[k], k, 1, 3));
(%o10)         sum(b , k, 1, 3) + sum(a , k, 1, 3)
                    k                  k
(%i11) '(''(sum (a[k], k, 1, 3)) + ''(sum (b[k], k, 1, 3)));
(%o11)             b  + a  + b  + a  + b  + a
                    3    3    2    2    1    1
@end example

@end deffn

@c end concepts Command Line
@node Definitionen für die Kommandozeile,  , Einführung in die Kommandozeile, Kommandozeile
@section Definitionen für die Kommandozeile

@c NEEDS WORK, ESPECIALLY EXAMPLES
@deffn {Funktion} alias (@var{new_name_1}, @var{old_name_1}, ..., @var{new_name_n}, @var{old_name_n})
stellt einen alternativen Namen für eine (Benutzer- oder System-) Funktion, Variable, Array, etc. zur Verfügung. 
Eine gerade Anzahl an Argumenten muss dabei verwendet werden. 

@end deffn

@defvr {Optionsvariable} debugmode
Standardwert: @code{false}

Wenn in Maxima ein Fehler auftritt, startet Maxima den Debugger, falls @code{debugmode} @code{true} ist. 
Der Benutzer kann dann Kommandos eingeben, um den Stapelspeicher ("call stack") zu untersuchen, 
Haltepunkte ("breakpoints") zu setzen, den Maxima-Quelltext durchzugehen, etc. 
Siehe @code{debugging} für eine Liste der Kommandos für den Debugger.
When a Maxima error occurs, Maxima will start the debugger if @code{debugmode} is @code{true}.
The user may enter commands to examine the call stack, set breakpoints, step
through Maxima code, and so on. See @code{debugging} for a list of debugger commands.

@code{debugmode} ermöglicht nicht, Lisp-Fehler abzufangen. 
@c DO WE WANT TO SAY MORE ABOUT DEBUGGING LISP ERRORS ???
@c I'M NOT CONVINCED WE WANT TO OPEN THAT CAN OF WORMS !!!

@end defvr

@c NEEDS CLARIFICATION
@c VERY IMPORTANT !!
@deffn {Funktion} ev (@var{expr}, @var{arg_1}, ..., @var{arg_n})
Wertet den Ausdruck @var{expr} in einer Umgebung, die durch die Argumente @var{arg_1}, ..., @var{arg_n} 
angegeben ist, aus. Die Argumente sind Boolesche Schalter ("Boolean flags"), Zuweisungen, 
Gleichungen und Funktionen. @code{ev} gibt das Ergebnis (einen anderen Ausdruck) 
der Auswertung zurück. 

Die Auswertung wird in den folgenden Schritten durchgeführt. 

@enumerate
@item
Zuerst wird die Umgebung über eine Abfrage der Argumente eingerichtet, welche eins oder alle der 
folgend genannten sein können.

@itemize @bullet
@item
@code{simp} bewirkt, dass @var{expr} vereinfacht wird, unabhängig von der 
Einstellung des Schalters @code{simp}, der, wenn @code{false}, Vereinfachungen verhindert.
@item
@code{noeval} unterbindet die Auswertungsphase von @code{ev} (siehe unten Schritt (4)).
Dies ist hilfreich in Verbindung mit anderen Schaltern und dadurch, dass 
@var{expr} erneut vereinfacht wird ohne dabei erneut ausgewertet zu werden.
@item
@code{nouns} bewirkt die Auswertung der Substantivformen
(typischerweise unausgewertete Funktionen wie @code{'integrate} oder @code{'diff})
in @var{expr}.
@item
@code{expand} bewirkt Expansion.
@item
@code{expand (@var{m}, @var{n})} bewirkt Expansion und setzt dabei die Werte von 
@code{maxposex} und @code{maxnegex} zu @var{m} bzw. @var{n}.
@item
@code{detout} bewirkt, dass jede in @var{expr} enthaltende inverse Matrix 
bei der Berechnung ihre Determinante eher als Vorfaktor festhält
als jeden Eintrag hierdurch zu teilen.
@item
@code{diff} bewirkt, dass jede in @var{expr} aufgeführte Differentiation ausgeführt wird.
@item
@code{derivlist (@var{x}, @var{y}, @var{z}, ...)} bewirkt, dass Differentiationen 
nur bezüglich der aufgeführten Variablen ausgeführt werden.
@item
@code{float} bewirkt, dass nichtganzzahlige rationale Zahlen in Dezimalzahlen 
umgewandelt werden.
@item
@code{numer} bewirkt, dass einige mathematische Funktionen (einschließlich 
der Exponentiation) mit numerischen Argumenten in Dezimalzahlen ausgewertet werden.
Es bewirkt, dass Variablen in @var{expr}, die Zahlenwerte erhalten haben, 
durch ihre Werte ersetzt werden.
Es schaltet auch den Schalter @code{float} an.
@item
@code{pred} bewirkt, dass Prädikate (Ausdrücke, die zu @code{true} oder @code{false} evaluieren)
ausgewertet werden.
@item
@code{eval} bewirkt eine zusätzliche Nachauswertung von @var{expr}. (Siehe unten Schritt (5).)
@code{eval} kann mehrfach aufgeführt werden. Bei jedem Vorkommen von @code{eval} wir der 
Ausdruck erneut ausgewertet.
@item
@code{A}, wobei @code{A} ein als Auswertungsschalter erklärtes Atom ist ("evaluation flag", siehe @code{evflag}),
bewirkt, dass @code{A} während der Auswertung von @var{expr} an @code{true} gebunden ist.
@item
@code{V: expression} (oder alternativ @code{V=expression}) bewirkt, dass @code{V} 
während der Auswertung von @var{expr} an den Wert von @code{expression} gebunden ist. 
Beachte, dass wenn @code{V} eine Maxima-Option ist, wird @code{expression} 
während der Auswertung von @var{expr} als Wert der Option verwendet. 
Wenn mehr als ein Argument von @code{ev} von diesem Typ ist, wird diese Bindung parallel durchgeführt. 
Wenn @code{V} nichtatomarer Ausdruck ist, wird eher eine Substitution als eine Bindung durchgeführt.
@item
@code{F}, wobei @code{F} ein als Auswertungsfunktion erklärter Funktionsname ist 
("evaluation function", siehe  @code{evfun}), bewirkt, dass @code{F} auf @var{expr} angewandt wird.
@item
Andere Funktionsnamen (z.B., @code{sum}) bewirken die Auswertung jedes Vorkommens dieser Namen 
in @var{expr}, so als wären es Verben.
@item
Zusätzlich kann eine Funktion, die in @var{expr} vorkommt (sagen wir @code{F(x)}), 
durch die Eingabe von @code{F(x) := expression} als Argument von @code{ev} 
allein für diese Auswertung von @var{expr} lokal definiert werden.
@item
Wenn ein oben nicht erwähntes Atom oder eine indizierte Variable oder ein indizierter Ausdruck 
als Argument gegeben ist, wird es ausgewertet und wenn das Ergebnis eine Gleichung oder eine 
Zuweisung ist, wird die aufgeführte Bindung oder Substitution durchgeführt. 
Ist das Ergebnis eine Liste, dann werden die Elemente der Liste als zusätzliche Argumente 
von @code{ev} angesehen. 
Dies erlaubt, eine Liste von Gleichungen zu verwenden (z.B. @code{[X=1, Y=A**2]}), oder 
eine Liste von Namen von Gleichungen (z.B. @code{[%t1, %t2]}, wobei @code{%t1} und
@code{%t2} an Gleichungen gebunden sind), wie sie beispielsweise von @code{solve} zurückgegeben wird.
@end itemize

Die Argumente von @code{ev} können in beliebiger Reihenfolge angegeben werden, mit der Ausnahme, 
dass die Substitution von Gleichungen der Reihe nach von links nach rechts durchgeführt wird,  
und dass hintereinander aufgeführte Auswertungsfunktionen entsprechend verkettet werden, 
z.B. wird @code{ev (@var{expr}, ratsimp, realpart)} zu @code{realpart (ratsimp (@var{expr}))} .

Die Schalter @code{simp}, @code{numer}, @code{float} und @code{pred} können auch lokal in einem Block 
gesetzt werden, oder global in Maxima, wodurch sie bis zur nächsten Setzung wirksam bleiben.

Ist @var{expr} ein kanonischer rationaler Ausdruck (CRE), ist der von @code{ev} zurückgegebene 
Ausdruck ebenfalls CRE, vorausgesetzt dass die Schalter @code{numer} und @code{float} beide nicht 
@code{true} sind.

@item
Während des Schritts (1) wird eine Liste der nicht indizierten Variablen erstellt, 
die auf der linken Seite von unter den Argumenten befindlichen Gleichungen auftreten oder in den Werten 
der Argumente, falls diese Werte Gleichungen sind. 
Die Variablen in dem Ausdruck @var{expr} (nicht indizierten Variablen und auch indizierte Variablen, 
die keine assoziierte Arrayfunktionen besitzen) 
werden durch ihre globalen Werte ersetzt, es sei denn, sie sind in der gerade 
genannten Liste aufgeführt. 
Normalerweise ist @var{expr} eine Marke (Label) oder @code{%} (wie in @code{%i2} in dem Beispiel unten), 
so dass in diesem Schritt einfach nur der durch die Marke benannte Ausdruck abfragt wird, 
damit @code{ev} ihn dann bearbeiten kann.

@item
Wenn in den Argumenten irgendwelche Substitutionen aufgeführt sind, werden diese nun ausgeführt.

@item
Der resultierende Ausdruck wird erneut ausgewertet (wenn nicht @code{noeval} unter den Argumente ist) 
und gemäß der Argumente vereinfacht. Beachte, dass jeder Funktionsaufruf in @var{expr} 
erst ausgeführt wird, nachdem die enthaltenden Variablen ausgewertet wurde und dass sich dadurch 
@code{ev(F(x))} wie @code{F(ev(x))} verhalten wird.

@item
Bei jedem Vorkommen von @code{eval} in den Argumenten werden die Schritte (3) und (4) wiederholt.
@end enumerate

Beispiele:

@example
(%i1) sin(x) + cos(y) + (w+1)^2 + 'diff (sin(w), w);
                                     d                    2
(%o1)              cos(y) + sin(x) + -- (sin(w)) + (w + 1)
                                     dw
(%i2) ev (%, sin, expand, diff, x=2, y=1);
                          2
(%o2)   e        cos(w) + w  + 2 w + cos(1) + 1.909297426825682
@end example

Eine alternativ Top-Level-Syntax wird durch @code{ev} bereitgestellt, bei der man einfach nur 
die Argumente ohne @code{ev()} eingeben kann. D.h. man kann einfach schreiben 

@example
@var{expr}, @var{arg_1}, ..., @var{arg_n}
@end example

Diese Kurzschreibweise ist als Teil eines anderen Ausdrucks, z.B. in Funktionen, Blöcken, etc., 
nicht gestattet.

Beachte im folgenden Beispiel den parallelen Bindungsprozess.

@example
(%i3) programmode: false;
(%o3)                                false
(%i4) x+y, x: a+y, y: 2;
(%o4)                              y + a + 2
(%i5) 2*x - 3*y = 3$
(%i6) -3*x + 2*y = -4$
(%i7) solve ([%o5, %o6]);
Solution

                                          1
(%t7)                               y = - -
                                          5

                                         6
(%t8)                                x = -
                                         5
(%o8)                            [[%t7, %t8]]
(%i8) %o6, %o8;
(%o8)                              - 4 = - 4
(%i9) x + 1/x > gamma (1/2);
                                   1
(%o9)                          x + - > sqrt(%pi)
                                   x
(%i10) %, numer, x=1/2;
(%o10)                      2.5 > 1.772453850905516
(%i11) %, pred;
(%o11)                               true
@end example

@end deffn

@defvr {Eigenschaft} evflag
Wenn ein Symbol @var{x} die Eigenschaft (@code{properties}) 
@code{evflag} ("evaluation flag", Auswertungsschalter) 
besitzt, sind die Ausdrücke @code{ev(@var{expr}, @var{x})} und @code{@var{expr}, @var{x}}
(in der interaktiven Eingabe) äquivalent zu @code{ev(@var{expr}, @var{x} = true)}. 
Das heißt, @var{x} ist während der Auswertung von @var{expr} an @code{true} gebunden. 

Der Ausdruck @code{declare(@var{x}, evflag)} verleiht der Variablen @var{x} die @code{evflag}-Eigenschaft.

Schalter, die standardmäßig die @code{evflag}-Eigenschaft besitzen: 
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evflag properties) ...)
@c NEAR LINE 2649 OF mlisp.lisp AT PRESENT (2004/11).
@code{algebraic},
@code{cauchysum},
@code{demoivre},
@code{dotscrules},
@code{%emode},
@code{%enumer},
@code{exponentialize},
@code{exptisolate},
@code{factorflag},
@code{float},
@code{halfangles},
@code{infeval},
@code{isolate_wrt_times},
@code{keepfloat},
@code{letrat},
@code{listarith},
@code{logabs},
@code{logarc},
@code{logexpand},
@code{lognegint},
@code{lognumer},
@code{m1pbranch},
@code{numer_pbranch},
@code{programmode},
@code{radexpand},
@code{ratalgdenom},
@code{ratfac},
@code{ratmx},
@code{ratsimpexpons},
@code{simp},
@code{simpsum},
@code{sumexpand} und
@code{trigexpand}.

Beispiele:

@c ===beg===
@c sin (1/2);
@c sin (1/2), float;
@c sin (1/2), float=true;
@c simp : false;
@c 1 + 1;
@c 1 + 1, simp;
@c simp : true;
@c sum (1/k^2, k, 1, inf);
@c sum (1/k^2, k, 1, inf), simpsum;
@c declare (aa, evflag);
@c if aa = true then YES else NO;
@c if aa = true then YES else NO, aa;
@c ===end===
@example
(%i1) sin (1/2);
                                 1
(%o1)                        sin(-)
                                 2
(%i2) sin (1/2), float;
(%o2)                   0.479425538604203
(%i3) sin (1/2), float=true;
(%o3)                   0.479425538604203
(%i4) simp : false;
(%o4)                         false
(%i5) 1 + 1;
(%o5)                         1 + 1
(%i6) 1 + 1, simp;
(%o6)                           2
(%i7) simp : true;
(%o7)                         true
(%i8) sum (1/k^2, k, 1, inf);
                            inf
                            ====
                            \     1
(%o8)                        >    --
                            /      2
                            ====  k
                            k = 1
(%i9) sum (1/k^2, k, 1, inf), simpsum;
                                 2
                              %pi
(%o9)                         ----
                               6
(%i10) declare (aa, evflag);
(%o10)                        done
(%i11) if aa = true then YES else NO;
(%o11)                         NO
(%i12) if aa = true then YES else NO, aa;
(%o12)                         YES
@end example

@end defvr

@defvr {Eigenschaft} evfun
Wenn eine Funktion @var{F} die Eigenschaft (@code{properties}) 
@code{evfun} ("evaluation function", Auswertungsfunktion) 
besitzt, sind die Ausdrücke @code{ev(@var{expr}, @var{F})} und @code{@var{expr}, @var{F}}
(in der interaktiven Eingabe) äquivalent zu @code{@var{F}(ev(@var{expr}))}. 

Wenn zwei oder mehr @code{evfun}-Funktionen @var{F}, @var{G}, etc. aufgeführt werden, 
werden die Funktionen in der aufgeführten Reihenfolge angewandt. 

Der Ausdruck @code{declare(@var{F}, evfun)} verleiht der Funktion @var{F} die @code{evfun}-Eigenschaft.

Funktionen, die standardmäßig die @code{evfun}-Eigenschaft besitzen: 
@c FOLLOWING LIST CONSTRUCTED FROM LIST UNDER (prog1 '(evfun properties) ...)
@c NEAR LINE 2643 IN mlisp.lisp AT PRESENT (2004/11).
@code{bfloat},
@code{factor},
@code{fullratsimp},
@code{logcontract},
@code{polarform},
@code{radcan},
@code{ratexpand},
@code{ratsimp},
@code{rectform},
@code{rootscontract},
@code{trigexpand}, and
@code{trigreduce}.

Beispiele:

@c ===beg===
@c x^3 - 1;
@c x^3 - 1, factor;
@c factor (x^3 - 1);
@c cos(4 * x) / sin(x)^4;
@c cos(4 * x) / sin(x)^4, trigexpand;
@c cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
@c ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
@c declare ([F, G], evfun);
@c (aa : bb, bb : cc, cc : dd);
@c aa;
@c aa, F;
@c F (aa);
@c F (ev (aa));
@c aa, F, G;
@c G (F (ev (aa)));
@c ===end===
@example
(%i1) x^3 - 1;
                              3
(%o1)                        x  - 1
(%i2) x^3 - 1, factor;
                                2
(%o2)                 (x - 1) (x  + x + 1)
(%i3) factor (x^3 - 1);
                                2
(%o3)                 (x - 1) (x  + x + 1)
(%i4) cos(4 * x) / sin(x)^4;
                            cos(4 x)
(%o4)                       --------
                               4
                            sin (x)
(%i5) cos(4 * x) / sin(x)^4, trigexpand;
                 4           2       2         4
              sin (x) - 6 cos (x) sin (x) + cos (x)
(%o5)         -------------------------------------
                                4
                             sin (x)
(%i6) cos(4 * x) / sin(x)^4, trigexpand, ratexpand;
                           2         4
                      6 cos (x)   cos (x)
(%o6)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i7) ratexpand (trigexpand (cos(4 * x) / sin(x)^4));
                           2         4
                      6 cos (x)   cos (x)
(%o7)               - --------- + ------- + 1
                          2          4
                       sin (x)    sin (x)
(%i8) declare ([F, G], evfun);
(%o8)                         done
(%i9) (aa : bb, bb : cc, cc : dd);
(%o9)                          dd
(%i10) aa;
(%o10)                         bb
(%i11) aa, F;
(%o11)                        F(cc)
(%i12) F (aa);
(%o12)                        F(bb)
(%i13) F (ev (aa));
(%o13)                        F(cc)
(%i14) aa, F, G;
(%o14)                      G(F(cc))
(%i15) G (F (ev (aa)));
(%o15)                      G(F(cc))
@end example

@end defvr
@c NEEDS WORK
@defvr {Optionsvariable} infeval
Erlaubt den Modus der endlosen Auswertung ("infinite evaluation"). 
@code{ev} wertet einen Ausdruck solange wiederholt aus, bis dieser sich nicht mehr ändert. 
Um zu verhindern, dass eine Variable, sagen wir @code{X}, in diesem Modus fortwährend 
ausgewertet wird, kann man einfach @code{X='X} als Argument von @code{ev} einfügen. 
Natürlich werden Ausdrücke wie @code{ev (X, X=X+1, infeval)} Endlosschleifen erzeugen. 

@end defvr

@c REVIEW FOR ACCURACY AND COMPLETENESS
@c THIS ITEM IS VERY IMPORTANT !!
@c NEEDS EXAMPLES
@deffn {Funktion} kill (@var{a_1}, ..., @var{a_n})
@deffnx {Funktion} kill (labels)
@deffnx {Funktion} kill (inlabels, outlabels, linelabels)
@deffnx {Funktion} kill (@var{n})
@deffnx {Funktion} kill ([@var{m}, @var{n}])
@deffnx {Funktion} kill (values, functions, arrays, ...)
@deffnx {Funktion} kill (all)
@deffnx {Funktion} kill (allbut (@var{a_1}, ..., @var{a_n}))

Entfernt alle Bindungen (Werte, Funktionen, Arrays oder Regeln) von den Argumenten 
@var{a_1}, ..., @var{a_n}. Ein Argument @var{a_k} kann ein Symbol oder ein einzelnes Arrayelement sein. 
Ist @var{a_k} ein einzelnes Arrayelement, entbindet @code{kill} dieses Element ohne dabei die 
anderen Elemente des Array zu beeinflussen.

Einige spezielle Argumente werden erkannt. Verschiedene Arten von Argumenten können kombiniert werden, 
z.B. @code{kill (inlabels, functions, allbut (foo, bar))}.

@code{kill (labels)} entbindet alle bis dahin erzeugten Eingabe-, Ausgabe- und Zwischenmarken 
("input, output, and intermediate expression labels").
@code{kill (inlabels)} entbindet nur die Eingabemarken, die mit dem aktuellen Wert von @code{inchar} beginnen. 
Entsprechend entbindet @code{kill (outlabels)} nur die Ausgabemarken, 
die mit dem aktuellen Wert von @code{outchar} beginnen und  
@code{kill (linelabels)} entbindet nur die Zwischenmarken, 
die mit dem aktuellen Wert von @code{linechar} beginnen.

@code{kill (@var{n})}, wobei @var{n} eine ganze Zahl ist, 
entbindet die @var{n} letzten Eingabe- und Ausgabemarken

@code{kill ([@var{m}, @var{n}])} entbindet Eingabe- und Ausgabemarken von @var{m} bis @var{n}.

@code{kill (@var{infolist})}, wobei @var{infolist} ein Eintrag aus @code{infolists} ist 
(so wie @code{values}, @code{functions} oder @code{arrays}), 
entbindet alle Einträge in @var{infolist}. Siehe auch @code{infolists}.

@code{kill (all)} entbindet sämtliche Einträge in sämtlichen Infolisten. 
@code{kill (all)} setzt keine globale Variablen auf ihre Standardwerte zurück; 
siehe @code{reset} zu diesem Punkt. 

@code{kill (allbut (@var{a_1}, ..., @var{a_n}))}
entbindet außer @var{a_1}, ..., @var{a_n} sämtliche Einträge in sämtlichen Infolisten. 
@code{kill (allbut (@var{infolist}))} entbindet alle Einträge außer denen in @var{infolist}, 
wobei @var{infolist} entweder @code{values} oder @code{functions}, @code{arrays}, etc. ist.

Der Speicherplatz, der durch eine bestimmte Bindungseigenschaft beansprucht wird, wird nicht eher  
freigegeben, bevor alle Symbole entbunden sind. Um insbesondere den Speicherplatz, 
der durch den Wert eines Symbols beansprucht wird, wieder freizugeben, wird sowohl die Ausgabemarke, 
die den gebundenen Wert zeigt, als auch das Symbol selbst entbunden.  

@code{kill} quotiert (Operator @code{'}) seine Argumente.
Der Quote-Quote-Operator @code{'@w{}'} verhindert Quotierung. 

@code{kill (@var{symbol})} entbindet @var{symbol} von sämtlichen Eigenschaften (@code{properties}). 
Im Kontrast, @code{remvalue}, @code{remfunction}, @code{remarray} und @code{remrule} entbinden 
jeweils eine spezielle Eigenschaft. 

@code{kill} gibt stets @code{done} zurück, sogar wenn das Argument keine Bindung besaß.

@end deffn

@deffn {Funktion} labels (@var{symbol})
@deffnx {Systemvariable} labels
Gibt die Liste der Eingabe-, Ausgabe- und Zwischenmarken 
("input, output, and intermediate expression labels"), die mit @var{symbol} beginnen, zurück. 
Typischerweise ist @var{symbol} der Wert von @code{inchar}, @code{outchar} oder @code{linechar}. 
Der Markenbuchstabe kann mit oder ohne Prozentzeichen angegeben werden, so ergeben 
zum Beispiel @code{i} und @code{%i} dasselbe Ergebnis. 

Wenn keine Marke mit @var{symbol} beginnt, gibt @code{labels} eine leere Liste zurück. 

Die Funktion @code{labels} quotiert (Operator @code{'}) seine Argumente.
Der Quote-Quote-Operator @code{'@w{}'} verhindert Quotierung. 
Zum Beispiel gibt @code{labels (''inchar)} die Eingabemarken zurück, die mit dem aktuellen 
Eingabemarkenbuchstaben beginnen.

Die Variable @code{labels} ist die Liste der Eingabe-, Ausgabe- und Zwischenmarken, 
einschließlich aller vorherigen Marken, falls @code{inchar}, @code{outchar} oder @code{linechar} 
neu definiert wurde. 

Standardmäßig zeigt Maxima das Ergebnis jeder Benutzereingabe an, wobei dem Ergebnis eine Ausgabemarke 
hinzugefügt wird. Die Anzeige der Ausgabe wird durch die Eingabe eines abschließenden 
@code{$} (Dollarzeichen) statt eines @code{;} (Semikolon) unterdrückt. 
Dabei wird eine Ausgabemarke erzeugt und an das Ergebnis gebunden, jedoch nicht angezeigt, 
die Marke kann aber in der gleichen Art und Weise wie bei angezeigten Ausgabemarken referenziert werden. 
Siehe auch @code{%}, @code{%%} und @code{%th}.

Zwischenmarken können durch einige Funktionen erzeugt werden. Der Schalter @code{programmode} 
bestimmt, ob @code{solve} und einige andere Funktionen Zwischenmarken erzeugen statt eine Liste 
von Ausdrücken zurückzugeben. 
Einige andere Funktionen, wie z.B. @code{ldisplay}, erzeugen stets Zwischenmarken. 

Siehe auch @code{inchar}, @code{outchar}, @code{linechar} und @code{infolists}.

@end deffn

@c EXPAND; SHOW WHAT HAPPENS WHEN linenum IS ASSIGNED A VALUE
@defvr {Systemvariable} linenum
Der Zeilenindex der aktuellen Ein- und Ausgabe. 

@end defvr

@c NEEDS WORK
@defvr {Systemvariable} myoptions
Standardwert: @code{[]}

@code{myoptions} ist die Liste aller Optionen, die durch den Benutzer neu gesetzt 
wurden, unabhängig davon, ob sie dabei wieder auf den Standardwert zurückgesetzt wurden, oder nicht. 

@end defvr

@defvr {Optionsvariable} nolabels
Standardwert: @code{false}

Wenn @code{nolabels} @code{true} ist, werden die Eingabe- und Ausgabemarken 
("label" @code{%i} bzw. @code{%o}) 
angezeigt, die Marken jedoch nicht an die Ergebnisse gebunden, 
und die Marken werden auch nicht der Liste @code{labels} hinzugefügt. 
Da in diesem Fall keine Marken an Ergebnisse gebunden sind, kann die Speicherbereinigung 
("garbage collection") den durch die Ergebnisse beanspruchten Speicher wieder frei geben. 

Andernfalls werden die Marken an die Ein- und Ausgabe gebunden und der Liste @code{labels} hinzugefügt. 

Zwischenmarken (@code{%t}) werden durch @code{nolabels} nicht beeinflusst; 
sie werden unabhängig davon, ob @code{nolabels} @code{true} ist, oder @code{false}, 
gebunden und der Liste @code{labels} hinzugefügt. 

Siehe auch @code{batch}, @code{load} und @code{labels}.

@end defvr

@c NEEDS WORK
@defvr {Optionsvariable} optionset
Standardwert: @code{false}

Wenn @code{optionset} @code{true} ist, gibt Maxima eine Meldung aus, wenn eine 
Maxima-Option neu gesetzt wird. 
Das kann nützlich sein, wenn der Benutzer Zweifel an der Schreibweise einer Option hat und sicher 
gehen möchte, dass er tatsächlich einer Optionsvariablen einen Wert zugewiesen hat.

@end defvr

@deffn {Funktion} playback ()
@deffnx {Funktion} playback (@var{n})
@deffnx {Funktion} playback ([@var{m}, @var{n}])
@deffnx {Funktion} playback ([@var{m}])
@deffnx {Funktion} playback (input)
@deffnx {Funktion} playback (slow)
@deffnx {Funktion} playback (time)
@deffnx {Funktion} playback (grind)
Zeigt Eingabe-, Ausgabe- und Zwischenausdrücke ("input, output, and intermediate expressions") 
an, ohne diese dabei neu zu berechnen. @code{playback} zeigt nur die Ausdrücke, 
die an die Marken ("label") gebunden sind; andere Ausgaben 
(so wie z.B. durch @code{print}, @code{describe} oder Fehlermeldungen erzeugten Text) 
werden nicht angezeigt.
Siehe auch @code{labels}.

@code{playback} quotiert (Operator @code{'}) seine Argumente.
Der Quote-Quote-Operator @code{'@w{}'} verhindert Quotierung. 
@code{playback} gibt stets @code{done} zurück.

@code{playback ()} (ohne Argumente) zeigt sämtliche Eingabe-, Ausgabe- und Zwischenausdrücke an, 
die bis dahin erzeugt wurden.
Ein bereits berechneter Ausgabeausdruck wird dabei auch dann angezeigt, 
wenn er durch einen Abschluss mit @code{$} unterdrückt wurde.

@code{playback (@var{n})} zeigt die letzten @var{n} Ausdrücke an. 
Jeder Eingabe-, Ausgabe- und Zwischenausdruck zählt dabei als einer.

@code{playback ([@var{m}, @var{n}])} zeigt die Eingabe-, Ausgabe- und Zwischenausdrücke 
mit den Zahlen von @var{m} bis einschließlich @var{n} an. 

@code{playback ([@var{m}])} ist äquivalent zu @code{playback ([@var{m}, @var{m}])}; 
normalerweise gibt dies ein Paar von Ein- und Ausgabeausdrücken aus. 

@code{playback (input)} zeigt sämtliche Eingabeausdrücke an, die bis dahin erzeugt wurden.

@code{playback (slow)} pausiert zwischen den Ausdrücken und wartet darauf, dass der Benutzer  
@code{enter} drückt. Dieses Verhalten ist @code{demo} ähnlich. 
@c WHAT DOES THE FOLLOWING MEAN ??? 
@code{playback (slow)} ist in Verbindung mit @code{save} oder @code{stringout} nützlich, 
wenn man bei der Erzeugung einer sekundären Speicherdatei die verwendbaren Ausdrücke herauspicken möchte. 

@code{playback (time)} zeigt für jeden Ausdruck die Berechnungszeit an.
@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} and @code{totaltime} have the same effect as @code{time}.

@code{playback (grind)} zeigt die Eingabeausdrücke in dem gleichen Format an wie
die Funktion @code{grind}. Ausgabeausdrücke werden von der Option @code{grind} nicht beeinflusst. 
Siehe @code{grind}.

Die Argumente können kombiniert werden, z.B. @code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS). CORRECT ???

@end deffn

@c NEEDS WORK ESPECIALLY EXAMPLES
@c WHOLE BUSINESS WITH PROPERTIES IS PRETTY CONFUSING, TRY TO CLEAR IT UP
@deffn {Funktion} printprops (@var{a}, @var{i})
@deffnx {Funktion} printprops ([@var{a_1}, ..., @var{a_n}], @var{i})
@deffnx {Funktion} printprops (all, @var{i})
Zeigt die zum Indikator @var{i} assoziierte Eigenschaft (@code{properties}) des Atoms @var{a} an.
@var{a} kann sowohl eine Liste von Atomen, als auch das Atom @code{all} sein, in welchem Fall 
sämtliche Atome mit der gegebenen Eigenschaft aufgeführt werden. 
Zum Beispiel  @code{printprops ([f, g], atvalue)}.  
@code{printprops} ist für Eigenschaften gedacht, 
die auf andere Weise nicht angezeigt werden können, 
z.B. für @code{atvalue}, @code{atomgrad}, @code{gradef} und @code{matchdeclare}.

Für Beispiele siehe @code{atvalue}, @code{gradef} und @code{matchdeclare}.

@end deffn

@defvr {Optionsvariable} prompt
Standardwert: @code{_}

@code{prompt} ist das Eingabeaufforderungssymbol der @code{demo}-Funktion, 
des @code{playback (slow)}-Modus und der Maxima-Bruch-Schleife (aufgerufen durch @code{break}).

@end defvr

@deffn {Funktion} quit ()
Beendet in einer Shell oder Eingabeaufforderung eine Maxima-Sitzung. 
Beachte, dass die Funktion als @code{quit();} oder @code{quit()$} eingegeben werden muss, 
nicht nur als @code{quit}. 

Um eine zu lang andauernde Berechnung zu stoppen, gib in der Shell oder Eingabeaufforderung 
@code{control-C} und in XMaxima und wxMaxima @code{control-G} ein. 
Standardmäßig wird dann wieder eine Eingabezeile bereitgestellt. 
Ist @code{*debugger-hook*} @code{nil}, öffnet @code{control-C} bzw. @code{control-G} den 
Lisp-Debugger. 
Siehe auch @code{debugging}.

@end deffn

@deffn {Funktion} remfunction (@var{f_1}, ..., @var{f_n})
@deffnx {Funktion} remfunction (all)
Entbindet die Symbole @var{f_1}, ..., @var{f_n} von ihren Funktionsdefinitionen. 
Die Argumente können die Namen von gewöhnlichen Funktionen (durch @code{:=} oder @code{define} erzeugt) 
oder Makrofunktionen (durch @code{::=} erzeugt) sein.

@code{remfunction (all)} entbindet sämtliche Funktionsdefinitionen. 

@code{remfunction} quotiert (Operator @code{'}) seine Argumente.

@code{remfunction} gibt eine Liste mit den Symbolen zurück, die von ihren Funktionsdefinitionen 
entbunden wurden. @code{false} wird statt der Symbole zurückgegeben, für die es keine Funktionsdefinition 
gibt.

@end deffn

@deffn {Funktion} reset ()
Setzt viele globale Variablen, Optionen und einige andere Variablen auf ihre Standardwerte zurück. 

@code{reset} verarbeitet die Variablen der Lisp-Liste @code{*variable-initial-values*}. 
Das Lisp-Makro @code{defmvar} setzt (unter anderem) Variablen auf diese Liste. 
Viele, aber nicht alle, globalen Variablen und Optionen sind mit Hilfe von @code{defmvar} 
definiert, andere mit @code{defmvar} definierte Variablen sind keine globalen Variablen oder Optionen. 

@end deffn

@defvr {Optionsvariable} showtime
Standardwert: @code{false}

Wenn @code{showtime} @code{true} ist, wird die Berechnungszeit und die verstrichene Zeit 
zusammen mit jedem Ausgabeausdruck angezeigt.

Die Berechnungszeit wird stets festgehalten, so dass @code{time} und @code{playback} 
die Berechnungszeit auch dann anzeigen können, wenn @code{showtime} @code{false} ist.

Siehe auch @code{timer}.

@end defvr

@c IS THIS ANY DIFFERENT FROM ASSIGNING A PROPERTY ??
@c THIS REALLY SEEMS LIKE A HACK
@deffn {Funktion} sstatus (@var{feature}, @var{package})
Setzt den Status von @var{feature} in @var{package}. 
Nachdem @code{sstatus (@var{feature}, @var{package})} ausgeführt wurde, gibt 
@code{status (@var{feature}, @var{package})} @code{true} zurück. 
Dies kann für das Schreiben eines Pakets nützlich sein, 
um über die geladenen Merkmale (@code{features}) die Übersicht zu behalten. 

@end deffn

@c NEEDS EXPANSION, EXAMPLES
@deffn {Funktion} to_lisp ()

Betritt unter Maxima das Lisp-System. @code{(to-maxima)} geht zu Maxima zurück.

@end deffn

@defvr {Systemvariable} values
Anfangswert: @code{[]}

@code{values} ist eine Liste aller gebundenen Variablen (keine Maxima-Optionen oder Schalter). 
Die Liste umfasst Symbole, die mit Hilfe von @code{:} , @code{::} oder @code{:=} gebunden wurden.

@end defvr
