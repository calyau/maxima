@c -----------------------------------------------------------------------------
@c File        : Series.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Series.texi revision 1.21
@c Translation : Dr. Dieter Kaiser
@c Date        : 05.11.2010
@c Revision    : 12.06.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Summen und Produkte::
* Einf@"uhrung in Reihen::
* Funktionen und Variablen f@"ur Reihen::
* Poisson Reihen::
* Kettenbr@"uche::
@end menu

@c -----------------------------------------------------------------------------
@node Summen und Produkte, Einf@"uhrung in Reihen, Summen Produkte und Reihen, Summen Produkte und Reihen
@section Summen und Produkte
@c -----------------------------------------------------------------------------

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{bashindices}
@deffn {Funktion} bashindices (@var{expr})

Transformiert einen Ausdruck @var{expr}, der mehrere Summen oder Produkte
enth@"alt so, dass alle Summen und Produkte einen unterschiedlichen Index haben.
Dies erleichtert zum Beispiel Substitutionen mit der Funktion
@mrefdot{changevar}  Die neuen Indizes werden mit @code{j@var{nummer}}
bezeichnet, wobei die Zahl @var{nummer} der Wert der Optionsvariablen
@mref{gensumnum} ist.

Beispiel:

@example
(%i1) sum(1/k^2,k,0,inf)+sum(1/k,k,0,inf);
                       inf       inf
                       ====      ====
                       \     1   \     1
(%o1)                   >    - +  >    --
                       /     k   /      2
                       ====      ====  k
                       k = 0     k = 0
(%i2) bashindices(%);
                     inf         inf
                     ====        ====
                     \      1    \       1
(%o2)                 >     -- +  >     ---
                     /      j2   /        2
                     ====        ====   j1
                     j2 = 0      j1 = 0
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{cauchysum}
@defvr {Optionsvariable} cauchysum
Standardwert: @code{false}

Werden zwei Reihen miteinander multipliziert und die Optionsvariablen
@mref{sumexpand} sowie @code{cauchysum} haben beide den Wert @code{true}, dann 
wird die Cauchy-Produktformel angewendet.

Beispiele:

@example
(%i1) sumexpand: false$
(%i2) cauchysum: false$
(%i3) s: sum (f(i), i, 0, inf) * sum (g(j), j, 0, inf);
                      inf         inf
                      ====        ====
                      \           \
(%o3)                ( >    f(i))  >    g(j)
                      /           /
                      ====        ====
                      i = 0       j = 0
(%i4) sumexpand: true$
(%i5) cauchysum: true$
(%i6) ''s;
                 inf     i1
                 ====   ====
                 \      \
(%o6)             >      >     g(i1 - i2) f(i2)
                 /      /
                 ====   ====
                 i1 = 0 i2 = 0
@end example
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{genindex}
@defvr {Optionsvariable} genindex
Standardwert: @code{i}

@code{genindex} enth@"alt das Zeichen f@"ur den Pr@"afix, der verwendet wird, um
einen neuen Index f@"ur eine Summe oder ein Produkt zu generieren.  Siehe auch
@mrefdot{gensumnum}
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{gensumnum}
@defvr {Optionsvariable} gensumnum
Standardwert: 0

@code{gensumnum} enth@"alt die Nummer, die an den Pr@"afix @code{genindex}
angeh@"angt wird, um den n@"achsten Index f@"ur eine Summe oder ein Produkt zu 
generieren.  Hat @code{gensumnum} den Wert @code{false}, wird der Index nur aus 
dem Zeichen @code{genindex} gebildet.  Siehe auch @mrefdot{genindex}
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{intosum}
@deffn {Funktion} intosum (@var{expr})

Multipliziert Faktoren in eine Summe herein.  Tritt der Index der Summe als ein
Faktor au@ss{}erhalb der Summe auf, wird von der Funktion @code{intosum} ein 
neuer Index gebildet.  Summen haben die Eigenschaft @mrefcomma{outative} so dass 
Faktoren bei der Vereinfachung aus der Summe herausgezogen werden.  Mit der
Funktion @code{intosum} wird diese Vereinfachung r@"uckg@"angig gemacht.

Beispiel:

@example
@group
(%i1) sum(2*x^2*n^k, k , 0, inf);
                               inf
                               ====
                             2 \      k
(%o1)                     2 x   >    n
                               /
                               ====
                               k = 0
@end group
@group
(%i2) intosum(%);
                          inf
                          ====
                          \        k  2
(%o2)                      >    2 n  x
                          /
                          ====
                          k = 0
@end group
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{lsum}
@deffn {Funktion} lsum (@var{expr}, @var{i}, @var{L})

Bildet die Summe f@"ur den Ausdruck @var{expr} zum Index @var{i} f@"ur alle 
Elemente der Liste @var{L}.  Kann das Argument @var{L} nicht zu einer Liste 
ausgewertet werden, wird eine Substantivform zur@"uckgegeben.  Siehe auch
@mrefdot{sum}

Beispiele:

@example
(%i1) lsum (x^i, i, [1, 2, 7]);
                            7    2
(%o1)                      x  + x  + x
(%i2) lsum (i^2, i, rootsof (x^3 - 1, x));
                     ====
                     \      2
(%o2)                 >    i
                     /
                     ====
                                   3
                     i in rootsof(x  - 1, x)
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{niceindices}
@deffn {Funktion} niceindices (@var{expr})

Gibt den Indizes von Summen und Produkten im Ausdruck @var{expr} einen neuen
Namen.  @code{niceindices} benennt die Indizes nacheinander mit den Namen, die
in der Liste der Optionsvariablen @mref{niceindicespref} enthalten sind.  Die 
Standardnamen sind @code{[i, j, k, l, m, n]}.  Sind nicht gen@"ugend Namen in 
der Liste vorhanden, werden weitere Indizes durch das Anh@"angen einer Nummer
gebildet.

@code{niceindices} wertet das Argument aus.

Beispiele:

@example
@group
(%i1) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                 inf    inf
                /===\   ====
                 ! !    \
(%o1)            ! !     >      f(bar i j + foo)
                 ! !    /
                bar = 1 ====
                        foo = 1
@end group
@group
(%i2) niceindices (%);
                     inf  inf
                    /===\ ====
                     ! !  \
(%o2)                ! !   >    f(i j l + k)
                     ! !  /
                    l = 1 ====
                          k = 1
@end group
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{niceindicespref}
@defvr {Optionsvariable} niceindicespref
Standardwert: @code{[i, j, k, l, m, n]}

@code{niceindicespref} ist die Liste mit den Namen, die die Funktion 
@mref{niceindices} nutzt, um die Indizes von Summen und Produkte umzubenennen.

Beispiele:

@example
(%i1) niceindicespref: [p, q, r, s, t, u]$
(%i2) product (sum (f (foo + i*j*bar), foo, 1, inf), bar, 1, inf);
                 inf    inf
                /===\   ====
                 ! !    \
(%o2)            ! !     >      f(bar i j + foo)
                 ! !    /
                bar = 1 ====
                        foo = 1
(%i3) niceindices (%);
                     inf  inf
                    /===\ ====
                     ! !  \
(%o3)                ! !   >    f(i j q + p)
                     ! !  /
                    q = 1 ====
                          p = 1
@end example
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{nusum}
@deffn {Funktion} nusum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

Wendet den Gosper-Algorithmus der unbestimmten Summation f@"ur den Ausdruck 
@var{expr} und dem Index @var{i} an.  Der Index @var{i} l@"auft von @var{i_0} 
bis @var{i_1}.  Der Ausdruck @var{expr} und das Ergebnis der Summation m@"ussen 
als Produkte von ganzzahligen Exponentiationen, Fakult@"aten, Binomialen und
rationalen Funktionen darstellbar sein.

Die Funktionen @code{nusum} und @code{unsum} wenden einige Regeln f@"ur die
Vereinfachung von Summen und Differenzen von endlichen Produkten an.  Siehe 
auch @mrefdot{unsum}

Beispiele:

@example
(%i1) nusum (n*n!, n, 0, n);

Dependent equations eliminated:  (1)
(%o1)                     (n + 1)! - 1
(%i2) nusum (n^4*4^n/binomial(2*n,n), n, 0, n);
                     4        3       2              n
      2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
(%o2) ------------------------------------------------ - ------
                    693 binomial(2 n, n)                 3 11 7
(%i3) unsum (%, n);
                              4  n
                             n  4
(%o3)                   ----------------
                        binomial(2 n, n)
@group
(%i4) unsum (prod (i^2, i, 1, n), n);
                    n - 1
                    /===\
                     ! !   2
(%o4)              ( ! !  i ) (n - 1) (n + 1)
                     ! !
                    i = 1
@end group
(%i5) nusum (%, n, 1, n);

Dependent equations eliminated:  (2 3)
                            n
                          /===\
                           ! !   2
(%o5)                      ! !  i  - 1
                           ! !
                          i = 1
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{product}
@deffn {Funktion} product (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

Bildet das Produkt des Ausdrucks @var{expr} zum Index @var{i} in den Grenzen
@var{i_0} bis @var{i_1}.  @code{product} wertet @var{expr} sowie die untere 
Grenze @var{i_0} und obere Grenze @var{i_1} aus.  Der Index @var{i} wird nicht 
ausgewertet.

Ist die Differenz der oberen und unteren Grenze eine ganze Zahl, wird @var{expr}
f@"ur jeden Wert des Index @var{i} ausgewertet.  Das Ergebnis ist ein explizites
Produkt.  Andernfalls ist der Bereich des Index unbestimmt.  Maxima wendet 
einige einfache Regeln an, um das Produkt zu vereinfachen.  Hat die 
Optionsvariable @mref{simpproduct} den Wert @code{true}, wendet Maxima weitere 
Regeln an, um Produkte zu vereinfachen.

Siehe auch @mref{nouns} und @mref{evflag} f@"ur die Auswertung von Ausdr@"ucken,
die die Substantivform eines Produktes enthalten.

Beispiele:

@example
(%i1) product (x + i*(i+1)/2, i, 1, 4);
(%o1)           (x + 1) (x + 3) (x + 6) (x + 10)
(%i2) product (i^2, i, 1, 7);
(%o2)                       25401600
(%i3) product (a[i], i, 1, 7);
(%o3)                 a  a  a  a  a  a  a
                       1  2  3  4  5  6  7
(%i4) product (a(i), i, 1, 7);
(%o4)          a(1) a(2) a(3) a(4) a(5) a(6) a(7)
(%i5) product (a(i), i, 1, n);
@group
                             n
                           /===\
                            ! !
(%o5)                       ! !  a(i)
                            ! !
                           i = 1
@end group
(%i6) product (k, k, 1, n);
                               n
                             /===\
                              ! !
(%o6)                         ! !  k
                              ! !
                             k = 1
(%i7) product (k, k, 1, n), simpproduct;
(%o7)                          n!
(%i8) product (integrate (x^k, x, 0, 1), k, 1, n);
                             n
                           /===\
                            ! !    1
(%o8)                       ! !  -----
                            ! !  k + 1
                           k = 1
(%i9) product (if k <= 5 then a^k else b^k, k, 1, 10);
                              15  40
(%o9)                        a   b
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{simpproduct}
@defvr {Optionsvariable} simpproduct
Standardwert: @code{false}

Hat @code{simpproduct} den Wert @code{true}, versucht Maxima ein Produkt weiter 
zu vereinfachen.  Die Vereinfachung kann eine geschlossene Form liefern.  Hat
@code{simpproduct} den Wert @code{false} oder wird das Produkt als
Substantivform @code{'product} definiert, werden nur einige einfache Regeln von
Maxima f@"ur die Vereinfachung angewendet.  @code{simpproduct} ist auch ein
Auswertungsschalter.  Siehe @mrefdot{evflag}

Siehe auch @mref{product} f@"ur ein Beispiel.

@c TODO: WELCHE REGELN WENDET MAXIMA IMMER AN.  ZUM BEISPIEL OUTATIVE?
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{simpsum}
@defvr {Optionsvariable} simpsum
Standardwert: @code{false}

Hat @code{simpsum} den Wert @code{true}, versucht Maxima eine Summe oder Reihe 
weiter zu vereinfachen.  Die Vereinfachung kann eine geschlossene Form liefern.
Hat @code{simpsum} den Wert @code{false} oder die Summe oder Reihe liegt als
Substantivform @code{'sum} vor, werden nur einige einfache Regeln von Maxima 
f@"ur die Vereinfachung angewendet.  @code{simpsum} ist auch ein
Auswertungsschalter.  Siehe @mrefdot{evflag}

Siehe auch @mref{sum} f@"ur ein Beispiel.

@c TODO: WELCHE REGELN WENDET MAXIMA IMMER AN.  ZUM BEISPIEL OUTATIVE?
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{sum}
@deffn {Funktion} sum (@var{expr}, @var{i}, @var{i_0}, @var{i_1})

Bildet die Summe des Ausdrucks @var{expr} zum Index @var{i} in den Grenzen
@var{i_0} bis @var{i_1}.  Die Funktion @code{sum} wertet @var{expr} sowie die 
untere Grenze @var{i_0} und obere Grenze @var{i_1} aus.  Der Index @var{i} wird 
nicht ausgewertet.

Ist die Differenz der oberen und unteren Grenze eine ganze Zahl, wird @var{expr}
f@"ur jeden Wert des Index @var{i} ausgewertet.  Das Ergebnis ist eine explizite
Summe.  Andernfalls ist der Bereich des Index unbestimmt.  Maxima wendet einige 
einfache Regeln an, um die Summe zu vereinfachen.  Hat die Optionsvariable 
@mref{simpsum} den Wert @code{true}, wendet Maxima weitere Regeln an, um Summen
zu vereinfachen.

Werden zwei unendliche Reihen miteinander multipliziert und die Optionsvariablen
@mref{sumexpand} sowie @mref{cauchysum} haben beide den Wert @code{true}, dann 
wird die Cauchy-Produktformel angewendet.

Die Optionsvariable @mref{genindex} enth@"alt das Zeichen, das der Pr@"afix 
eines automatisch generierten Index ist.  @mref{gensumnum} enth@"alt eine ganze 
Zahl, die an den Pr@"afix @code{genindex} angeh@"angt wird, um einen 
automatischen Index zu generieren.  @code{gensumnum} wird von Maxima automatisch
erh@"oht.  Hat @code{gensumnum} den Wert @code{false}, wird keine Zahl an den 
Pr@"afix angeh@"angt.

Das Paket @code{simplify_sum} enth@"alt die Funktion 
@mrefcomma{simplify_sum} mit der Summen zu einer geschlossenen Form vereinfacht
werden k@"onnen.

Es ist zu beachten, dass @code{sum} bei symbolischen Summen, die viele Terme
ergeben, langsam ist, z. B. @code{sum(x^i, i, 1, 10000)}. In solchen F@"allen
ist die Verwendung von @code{makelist} und @code{tree_reduce} signifikant
schneller, z. B. @code{tree_reduce("+", makelist(x^i, i, 1, 10000))}.

Siehe auch @mrefcomma{sumcontract}  @mrefcomma{sumexpand}@w{}
@mrefcomma{intosum} @mrefcomma{bashindices} @mrefcomma{niceindices}@w{}
@mref{cauchysum} und @mrefdot{zeilberger}

Beispiele:

@example
(%i1) sum (i^2, i, 1, 7);
(%o1)                          140
(%i2) sum (a[i], i, 1, 7);
(%o2)           a  + a  + a  + a  + a  + a  + a
                 7    6    5    4    3    2    1
(%i3) sum (a(i), i, 1, 7);
(%o3)    a(7) + a(6) + a(5) + a(4) + a(3) + a(2) + a(1)
(%i4) sum (a(i), i, 1, n);
                            n
                           ====
                           \
(%o4)                       >    a(i)
                           /
                           ====
                           i = 1
@group
(%i5) sum (2^i + i^2, i, 0, n);
                          n
                         ====
                         \       i    2
(%o5)                     >    (2  + i )
                         /
                         ====
                         i = 0
@end group
(%i6) sum (2^i + i^2, i, 0, n), simpsum;
                              3      2
                   n + 1   2 n  + 3 n  + n
(%o6)             2      + --------------- - 1
                                  6
@group
(%i7) sum (1/3^i, i, 1, inf);
                            inf
                            ====
                            \     1
(%o7)                        >    --
                            /      i
                            ====  3
                            i = 1
@end group
(%i8) sum (1/3^i, i, 1, inf), simpsum;
                                1
(%o8)                           -
                                2
(%i9) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf);
                              inf
                              ====
                              \     1
(%o9)                      30  >    --
                              /      2
                              ====  i
                              i = 1
(%i10) sum (i^2, i, 1, 4) * sum (1/i^2, i, 1, inf), simpsum;
                                  2
(%o10)                       5 %pi
(%i11) sum (integrate (x^k, x, 0, 1), k, 1, n);
                            n
                           ====
                           \       1
(%o11)                      >    -----
                           /     k + 1
                           ====
                           k = 1
(%i12) sum (if k <= 5 then a^k else b^k, k, 1, 10);
          10    9    8    7    6    5    4    3    2
(%o12)   b   + b  + b  + b  + b  + a  + a  + a  + a  + a
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{sumcontract}
@deffn {Funktion} sumcontract (@var{expr})

Fasst alle Summen in dem Ausdruck @var{expr} zusammen, die sich in ihrem oberen
und unterem Index nur um eine Konstante voneinander unterscheiden.  Das Ergebnis
ist eine Ausdruck mit einer Summe, f@"ur die Summen, die zusammengefasst werden 
k@"onnen und weiteren Termen, die hinzu addiert werden m@"ussen, um einen
@"aquivalenten Ausdruck zu erhalten.

Es kann notwendig sein zun@"achst das Kommando @code{intosum(@var{expr})} 
auszuf@"uhren.  Siehe @mrefdot{intosum}

Beispiel:

@example
(%i1) 'sum(1/l,l,1,n)+'sum(k,k,1,n+2);
@group
                         n        n + 2
                        ====      ====
                        \     1   \
(%o1)                    >    - +  >    k
                        /     l   /
                        ====      ====
                        l = 1     k = 1
@end group
(%i2) sumcontract(%);
@group
                            n
                           ====
                           \          1
(%o2)                2 n +  >    (l + -) + 3
                           /          l
                           ====
                           l = 1
@end group
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{sumexpand}
@defvr {Optionsvariable} sumexpand
Standardwert: @code{false}

Hat die Optionsvariable @code{sumexpand} den Wert @code{true}, werden Produkte
von Summen und Potenzen von Summen zu verschachtelten Summen vereinfacht.  Siehe
auch @mrefdot{cauchysum}

Beispiele:

@example
(%i1) sumexpand: true$
(%i2) sum (f (i), i, 0, m) * sum (g (j), j, 0, n);
                     m      n
                    ====   ====
                    \      \
(%o2)                >      >     f(i1) g(i2)
                    /      /
                    ====   ====
                    i1 = 0 i2 = 0
(%i3) sum (f (i), i, 0, m)^2;
                     m      m
                    ====   ====
                    \      \
(%o3)                >      >     f(i3) f(i4)
                    /      /
                    ====   ====
                    i3 = 0 i4 = 0
@end example
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{unsum}
@deffn {Funktion} unsum (@var{f}, @var{n})

Gibt die erste R@"uckw@"artsdifferenz @code{@var{f}(@var{n}) - 
@var{f}(@var{n}-1)} zur@"uck.  Siehe auch @mrefdot{nusum}

Beispiele:

@example
(%i1) g(p) := p*4^n/binomial(2*n,n);
@group
                                     n
                                  p 4
(%o1)               g(p) := ----------------
                            binomial(2 n, n)
@end group
@group
(%i2) g(n^4);
                              4  n
                             n  4
(%o2)                   ----------------
                        binomial(2 n, n)
@end group
(%i3) nusum (%, n, 0, n);
                     4        3       2              n
      2 (n + 1) (63 n  + 112 n  + 18 n  - 22 n + 3) 4      2
(%o3) ------------------------------------------------ - ------
                    693 binomial(2 n, n)                 3 11 7
(%i4) unsum (%, n);
                              4  n
                             n  4
(%o4)                   ----------------
                        binomial(2 n, n)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Reihen, Funktionen und Variablen f@"ur Reihen, Summen und Produkte, Summen Produkte und Reihen
@section Einf@"uhrung in Reihen
@c -----------------------------------------------------------------------------

Maxima kennt die Funktionen @mref{taylor} und @mrefcomma{powerseries} um die 
Reihenentwicklung von differenzierbaren Funktionen zu finden.  Maxima hat
weiterhin Funktionen wie @mrefcomma{nusum} um geschlossene Formen von Reihen zu
finden.  Operationen wie die Addition und Multiplikation arbeiten wie gewohnt
f@"ur Reihen.  Das folgende Kapitel beschreibt die Variablen und Funktionen
f@"ur eine Reihenentwicklung.

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Reihen, Poisson Reihen, Einf@"uhrung in Reihen, Summen Produkte und Reihen
@section Funktionen und Variablen f@"ur Reihen
@c -----------------------------------------------------------------------------

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{deftaylor}
@deffn {Funktion} deftaylor (@var{f_1}(@var{x_1}), @var{expr_1}, @dots{}, @var{f_n}(@var{x_n}), @var{expr_n})

F@"ur eine Funktion @var{f_i} einer Variablen @var{x_i} definiert 
@code{deftaylor} den Ausdruck @var{expr_i} als die Taylorreihe um den Nullpunkt.
@var{expr_i} ist typischerweise ein Polynom in der Variablen @var{x_i} oder eine
Summe.  @code{deftaylor} akzeptiert aber auch allgemeinere Ausdr@"ucke.

@code{powerseries(@var{f_i}(@var{x_i}), @var{x_i}, 0)} gibt die Reihe zur@"uck, 
die mit @code{deftaylor} definiert wurde.

@code{deftaylor} gibt eine Liste der Funktionen @var{f_1}, @dots{}, @var{f_n} 
zur@"uck.  @code{deftaylor} wertet die Argumente aus.

Siehe auch @mref{taylor} und @mrefdot{powerseries}

Beispiele:

@example
(%i1) deftaylor (f(x), x^2 + sum(x^i/(2^i*i!^2), i, 4, inf));
(%o1)                          [f]
(%i2) powerseries (f(x), x, 0);
@group
                      inf
                      ====      i1
                      \        x         2
(%o2)                  >     -------- + x
                      /       i1    2
                      ====   2   i1!
                      i1 = 4
@end group
(%i3) taylor (exp (sqrt (f(x))), x, 0, 4);
                      2         3          4
                     x    3073 x    12817 x
(%o3)/T/     1 + x + -- + ------- + -------- + . . .
                     2     18432     307200
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{maxtayorder}
@defvr {Optionsvariable} maxtayorder
Standardwert: @code{true}

Hat @code{maxtayorder} den Wert @code{true}, werden bei der algebraischen
Manipulation von Taylor-Reihen, von der Funktion @mref{taylor} so viele
Terme wie m@"oglich mitgef@"uhrt.
@end defvr

@c --- 27.01.2011 DK -----------------------------------------------------------
@anchor{pade}
@deffn {Funktion} pade (@var{taylor_series}, @var{numer_deg_bound}, @var{denom_deg_bound})

Gibt eine Liste aller rationalen Funktionen zur@"uck, die die angegebene
Taylor-Reihenentwicklung haben und deren Summe des Nennergrads und des
Z@"ahlergrads kleiner oder gleich des Grads der Reihenentwicklung ist.

Das Argument @var{taylor_series} ist eine Taylor-Reihe in einer Variablen.
Die Argumente @var{numer_deg_bound} und @var{denom_deg_bound} sind positive
ganze Zahlen, die eine Grenze f@"ur den Nennergrad und den Z@"ahlergrad der
rationalen Funktion angeben.

Die Taylor-Reihe kann auch eine Laurent-Reihe sein und die Grenzen f@"ur den 
Grad k@"onnen @code{inf} sein.

Siehe auch @mrefdot{taylor}

Beispiele:

@example
(%i1) taylor (1 + x + x^2 + x^3, x, 0, 3);
                              2    3
(%o1)/T/             1 + x + x  + x  + . . .
(%i2) pade (%, 1, 1);
                                 1
(%o2)                       [- -----]
                               x - 1
(%i3) t: taylor(-(83787*x^10 - 45552*x^9 - 187296*x^8
                   + 387072*x^7 + 86016*x^6 - 1507328*x^5
                   + 1966080*x^4 + 4194304*x^3 - 25165824*x^2
                   + 67108864*x - 134217728)
         /134217728, x, 0, 10);
@group
                    2    3       4       5       6        7
             x   3 x    x    15 x    23 x    21 x    189 x
(%o3)/T/ 1 - - + ---- - -- - ----- + ----- - ----- - ------
             2    16    32   1024    2048    32768   65536

                                  8         9          10
                            5853 x    2847 x    83787 x
                          + ------- + ------- - --------- + . . .
                            4194304   8388608   134217728
@end group
(%i4) pade (t, 4, 4);
(%o4)                          []
@end example

Es gibt keine rationale Funktion des Grads 4 im Z@"ahler und Nenner f@"ur die
oben angegebene Taylor-Reihenentwicklung.  Die Summe des Z@"ahlergrads und des 
Nennergrads m@"ussen mindestens gleich dem Grad der Reihenentwicklung sein.
In diesem Fall ist der Grad der Taylor-Reihenentwicklung @code{10}.

@example
(%i5) pade (t, 5, 5);
@group
                     5                4                 3
(%o5) [- (520256329 x  - 96719020632 x  - 489651410240 x

                  2
 - 1619100813312 x  - 2176885157888 x - 2386516803584)

               5                 4                  3
/(47041365435 x  + 381702613848 x  + 1360678489152 x

                  2
 + 2856700692480 x  + 3370143559680 x + 2386516803584)]
@end group
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{powerseries}
@deffn {Funktion} powerseries (@var{expr}, @var{x}, @var{a})

Gibt eine geschlossene Form f@"ur die Reihenentwicklung des Ausdrucks @var{expr}
in der Variablen @var{x} um den Punkt @var{a} zur@"uck.  Das Argument @var{a} 
kann die Werte @code{inf} oder @code{infinity} haben.  Die Reihenentwicklung 
f@"ur eine Funktion @code{f(x)} hat die allgemeine Form:
@ifnottex
@example
                  inf
                  ====
                  \               n
       f(x) =      >    b  (x - a)
                  /      n
                  ====
                  n = 0
@end example
@end ifnottex
@tex
$$f\left(x\right)=\sum_{n=0}^{\infty }{b_{n}\,\left(x-a\right)^{n}}$$
@end tex

Mit den Koeffzienten:
@ifnottex
@example
                     !
            d        !
            -- (f(x))!
            dn       !
                     !x = a
       b  = ---------------
        n         n!
@end example
@end ifnottex
@tex
$$b_{n}={{\left.{{d}\over{d\,n}}\,f\left(x\right)\right|_{x=a}}\over{n!}}$$
@end tex

Kann die Funktion @code{powerseries} keine Reihenentwicklung f@"ur den Ausdruck
@var{expr} finden, k@"onnen m@"oglicherweise mit der Funktion @mref{taylor} die
ersten Terme der Reihenentwicklung berechnet werden.

Hat die Optionsvariable @mref{verbose} den Wert @code{true}, werden Meldungen
zu den verwendeten Algorithmen von der Funktion @code{powerseries} angezeigt.

Beispiel:

@example
(%i1) verbose: true$

(%i2) powerseries (log(sin(x)/x), x, 0);
trigreduce: can't expand                            
                 log(sin(x))

trigreduce: try again after applying the rule:
                                 d
                               / -- (sin(x))
                               [ dx
                 log(sin(x)) = I ----------- dx
                               ]   sin(x)
                               /


powerseries: first simplification returned
@group
                                /
                                [
                     - log(x) + I cot(x) dx
                                ]
                                /
@end group

           inf
           ====        i1  - 1 + 2 i1             2 i1
           \      (- 1)   2           bern(2 i1) x
(%o2)       >     ------------------------------------
           /                   i1 (2 i1)!
           ====
           i1 = 1
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{psexpand}
@defvr {Option variable} psexpand
Default value: @code{false}

@c TODO: WIE FUNKTIONIERT DIE OPTIONSVARIABLE? BEISPIEL?

When @code{psexpand} is @code{true},
an extended rational function expression is displayed fully expanded.
The switch @code{ratexpand} has the same effect.

@c WE NEED TO BE EXPLICIT HERE
When @code{psexpand} is @code{false},
a multivariate expression is displayed just as in the rational function package.

@c TERMS OF WHAT ??
When @code{psexpand} is  @code{multi},
then terms with the same total degree in the variables are grouped together.
@end defvr

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{revert}
@anchor{revert2}
@deffn  {Funktion} revert (@var{expr}, @var{x})
@deffnx {Funktion} revert2 (@var{expr}, @var{x}, @var{n})

Die Funktion @code{revert} berechnet eine Taylorreihe in der Variablen @var{x}
um den Entwicklungspunkt Null, die der Taylorreihe der inversen Funktion 
entspricht, die von der Taylorreihe @var{expr} repr@"asentiert wird.  Das
Ergebnis ist ein Polynom in einer CRE-Darstellung mit dem Grad der h@"ochsten
Potenz im Ausdruck @var{expr}.

Die Funktion @code{revert2} entspricht der Funktion @code{revert} mit dem
Unterschied, dass mit dem dritten Argument @var{n} der Grad der neuen
Taylorreihe explizit angegeben werden kann.  Dieser kann kleiner oder
gr@"o@ss{}er als der Grad der Taylorreihe @var{expr} sein.

Mit dem Kommando @code{load("revert")} werden die Funktionen geladen.

Siehe auch die Funktion @mrefdot{taylor}

Beispiel:

Die Inverse der Funktion @code{exp(x) - 1} ist die Funktion @code{log(x+1)}.
Mit dem Kommando @code{revert(taylor(exp(x) - 1, x, 0, 6), x)} wird die
Taylorreihe der Inversen @code{log(x+1)} berechnet.

@example
(%i1) load ("revert")$
(%i2) t: taylor (exp(x) - 1, x, 0, 6);
                   2    3    4    5     6
                  x    x    x    x     x
(%o2)/T/      x + -- + -- + -- + --- + --- + . . .
                  2    6    24   120   720
(%i3) revert (t, x);
               6       5       4       3       2
           10 x  - 12 x  + 15 x  - 20 x  + 30 x  - 60 x
(%o3)/R/ - --------------------------------------------
                                60
(%i4) ratexpand (%);
                     6    5    4    3    2
                    x    x    x    x    x
(%o4)             - -- + -- - -- + -- - -- + x
                    6    5    4    3    2
(%i5) taylor (log(x+1), x, 0, 6);
                    2    3    4    5    6
                   x    x    x    x    x
(%o5)/T/       x - -- + -- - -- + -- - -- + . . .
                   2    3    4    5    6
(%i6) ratsimp (revert (t, x) - taylor (log(x+1), x, 0, 6));
(%o6)                           0
(%i7) revert2 (t, x, 4);
                          4    3    2
                         x    x    x
(%o7)                  - -- + -- - -- + x
                         4    3    2
@end example
@end deffn

@c --- 27.02.2011 DK -----------------------------------------------------------
@anchor{taylor}
@deffn  {Funktion} taylor (@var{expr}, @var{x}, @var{a}, @var{n})
@deffnx {Funktion} taylor (@var{expr}, [@var{x_1}, @var{x_2}, @dots{}], @var{a}, @var{n})
@deffnx {Funktion} taylor (@var{expr}, [@var{x}, @var{a}, @var{n}, 'asymp])
@deffnx {Funktion} taylor (@var{expr}, [@var{x_1}, @var{x_2}, @dots{}], [@var{a_1}, @var{a_2}, @dots{}], [@var{n_1}, @var{n_2}, @dots{}])
@deffnx {Funktion} taylor (@var{expr}, [@var{x_1}, @var{a_1}, @var{n_1}], [@var{x_2}, @var{a_2}, @var{n_2}], @dots{})

@code{taylor(@var{expr}, @var{x}, @var{a}, @var{n})} entwickelt den Ausdruck
@var{expr} in eine Taylor- oder Laurent-Reihenwicklung in der Variablen @var{x}
um den Punkt @var{a}, die die Terme bis zur Ordnung @code{(@var{x} - 
@var{a})^@var{n}} enth@"alt.

Hat der Ausdruck @var{expr} die Form @code{@var{f}(@var{x})/@var{g}(@var{x})}
und hat @code{@var{g}(@var{x})} keine Terme bis zur Ordnung @var{n}, dann 
versucht @code{taylor} den Ausdruck @code{@var{g}(@var{x})} bis zur Ordnung
@code{2 @var{n}} zu entwickeln.  Treten in der Entwicklung weiterhin keine
von Null verschiedenen Terme auf, verdoppelt @code{taylor} die Ordnung der
Entwicklung f@"ur @code{@var{g}(@var{x})} so lange, wie die Ordnung kleiner 
oder gleich @code{@var{n} 2^taylordepth} ist.  Siehe auch @mrefdot{taylordepth}

@code{taylor(@var{expr}, [@var{x_1}, @var{x_2}, ...], @var{a}, @var{n})} gibt
die Reihenentwicklung der Ordnung @var{n} in allen Variablen @var{x_1},
@var{x_2}, @dots{} um den Punkt @var{a} zur@"uck.

Die beiden folgenden @"aquivalenten Kommandos @code{taylor(@var{expr}, 
[@var{x_1}, @var{a_1}, @var{n_1}], [@var{x_2}, @var{a_2}, @var{n_2}], ...)} und 
@code{taylor(@var{expr}, [@var{x_1}, @var{x_2}, ...], [@var{a_1}, 
@var{a_2}, ...], [@var{n_1}, @var{n_2}, ...])} geben eine Reihenentwicklung 
f@"ur die Variablen @var{x_1}, @var{x_2}, @dots{} um den Punkt @code{(@var{a_1},
@var{a_2}, ...)} mit den Ordnungen @var{n_1}, @var{n_2}, @dots{} zur@"uck.

@code{taylor(@var{expr}, [@var{x}, @var{a}, @var{n}, 'asymp])} entwickelt den 
Ausdruck @var{expr} in negativen Potenzen von @code{@var{x} - @var{a}}.  Der
Term mit der gr@"o@ss{}ten Ordnung ist @code{(@var{x} - @var{a})^@var{-n}}.

Folgende Optionsvariablen kontrollieren die Berechnung einer Taylorreihe:

@table @code
@item maxtayorder
Hat @mref{maxtayorder} den Wert @code{true}, werden bei der algebraischen
Manipulation von Taylor-Reihen, von der Funktion @code{taylor} so viele
Terme wie m@"oglich mitgef@"uhrt.

@item taylordepth
Findet @code{taylor} keine von Null verschiedenen Terme in der
Reihenentwicklung, wird die Ordnung der Entwicklung solange erh@"oht wie sie
kleiner oder gleich @code{2^taylordepth} ist.

@item taylor_logexpand
Die Optionsvariable @mref{taylor_logexpand} kontrolliert die Entwicklung von
Logarithmusfunktionen, die bei der Reihenentwicklung auftreten.  Der 
Standardwert ist @code{true} und die Logarithmusfunktionen in einer 
Reihenentwicklung werden vollst@"andig entwickelt.

@item taylor_order_coefficients
Die Optionsvariable @mref{taylor_order_coefficients} kontrolliert die Anordung
von Termen in einer Reihenentwicklung.  Der Standardwert ist @code{true} und
die Anordung entspricht der kanonischen Darstellung eines Ausdrucks.

@item taylor_truncate_polynomials
Hat die Optionsvariable @mref{taylor_truncate_polynomials} den Wert
@code{false}, wird das Ergebnis der Reihenentwicklung eines Polynoms als exakt
angenommen.

@item taylor_simplifier
Die Funktion zur Vereinfachung der Koeffizienten einer Entwicklung ist in der Optionsvariablen @mref{taylor_simplifier} enthalten.  Der Standardwert ist
@code{simplify}.  Der Variablen kann eine nutzerdefinierte Funktion zugewiesen
werden.
@end table

@c TODO: UEBERSETZUNG DES FOLGENDEN FEHLT.  WIE FUNKTIONIERT PSEXPAND?

@c When @code{psexpand} is @code{true}, an extended rational function expression 
@c is displayed fully expanded. The switch @code{ratexpand} has the same effect.
@c When @code{psexpand} is @code{false}, a multivariate expression is displayed 
@c just as in the rational function package. When @code{psexpand} is 
@c @code{multi}, then terms with the same total degree in the variables are
@c grouped together.

Mit der Funktion @mref{taylorp} kann getestet werden, ob ein Ausdruck eine
Taylorreihe repr@"asentiert.  Die Funktion @mref{taylorinfo} gibt Informationen
zu einer Taylorreihe aus.  Die spezielle CRE-Form einer Taylorreihe wird mit der
Funktion @mref{taytorat} in eine Standardform gebracht. 
Mit den Funktionen @mref{revert} und @mref{revert2} kann die Taylorreihe einer
inversen Funktion berechnet werden.

Beispiele:

@example
(%i1) taylor (sqrt (sin(x) + a*x + 1), x, 0, 3);
                           2             2
             (a + 1) x   (a  + 2 a + 1) x
(%o1)/T/ 1 + --------- - -----------------
                 2               8

                                   3      2             3
                               (3 a  + 9 a  + 9 a - 1) x
                             + -------------------------- + . . .
                                           48
(%i2) %^2;
                                    3
                                   x
(%o2)/T/           1 + (a + 1) x - -- + . . .
                                   6
(%i3) taylor (sqrt (x + 1), x, 0, 5);
                       2    3      4      5
                  x   x    x    5 x    7 x
(%o3)/T/      1 + - - -- + -- - ---- + ---- + . . .
                  2   8    16   128    256
(%i4) %^2;
(%o4)/T/                  1 + x + . . .
(%i5) product ((1 + x^i)^2.5, i, 1, inf)/(1 + x^2);
                         inf
                        /===\
                         ! !    i     2.5
                         ! !  (x  + 1)
                         ! !
                        i = 1
(%o5)                   -----------------
                              2
                             x  + 1
(%i6) ev (taylor(%, x,  0, 3), keepfloat);
                               2           3
(%o6)/T/    1 + 2.5 x + 3.375 x  + 6.5625 x  + . . .
(%i7) taylor (1/log (x + 1), x, 0, 3);
                               2       3
                 1   1   x    x    19 x
(%o7)/T/         - + - - -- + -- - ----- + . . .
                 x   2   12   24    720
(%i8) taylor (cos(x) - sec(x), x, 0, 5);
@group
                                4
                           2   x
(%o8)/T/                - x  - -- + . . .
                               6
@end group
(%i9) taylor ((cos(x) - sec(x))^3, x, 0, 5);
(%o9)/T/                    0 + . . .
(%i10) taylor (1/(cos(x) - sec(x))^3, x, 0, 5);
                                               2          4
            1     1       11      347    6767 x    15377 x
(%o10)/T/ - -- + ---- + ------ - ----- - ------- - --------
             6      4        2   15120   604800    7983360
            x    2 x    120 x

                                                          + . . .
(%i11) taylor (sqrt (1 - k^2*sin(x)^2), x, 0, 6);
               2  2       4      2   4
              k  x    (3 k  - 4 k ) x
(%o11)/T/ 1 - ----- - ----------------
                2            24

                                    6       4       2   6
                               (45 k  - 60 k  + 16 k ) x
                             - -------------------------- + . . .
                                          720
(%i12) taylor ((x + 1)^n, x, 0, 4);
                      2       2     3      2         3
                    (n  - n) x    (n  - 3 n  + 2 n) x
(%o12)/T/ 1 + n x + ----------- + --------------------
                         2                 6

                               4      3       2         4
                             (n  - 6 n  + 11 n  - 6 n) x
                           + ---------------------------- + . . .
                                          24
(%i13) taylor (sin (y + x), x, 0, 3, y, 0, 3);
               3                 2
              y                 y
(%o13)/T/ y - -- + . . . + (1 - -- + . . .) x
              6                 2

                    3                       2
               y   y            2      1   y            3
          + (- - + -- + . . .) x  + (- - + -- + . . .) x  + . . .
               2   12                  6   12
(%i14) taylor (sin (y + x), [x, y], 0, 3);
@group
                     3        2      2      3
                    x  + 3 y x  + 3 y  x + y
(%o14)/T/   y + x - ------------------------- + . . .
                                6
@end group
(%i15) taylor (1/sin (y + x), x, 0, 3, y, 0, 3);
@group
          1   y              1    1               1            2
(%o15)/T/ - + - + . . . + (- -- + - + . . .) x + (-- + . . .) x
          y   6               2   6                3
                             y                    y

                                           1            3
                                      + (- -- + . . .) x  + . . .
                                            4
                                           y
@end group
(%i16) taylor (1/sin (y + x), [x, y], 0, 3);
                             3         2       2        3
            1     x + y   7 x  + 21 y x  + 21 y  x + 7 y
(%o16)/T/ ----- + ----- + ------------------------------- + . . .
          x + y     6                   360
@end example
@end deffn

@c --- 28.02.2011 DK -----------------------------------------------------------
@anchor{taylordepth}
@defvr {Optionsvariable} taylordepth
Standardwert: 3

Findet die Funktion @code{taylor} keine von Null verschiedenen Terme in der
Reihenentwicklung, wird die Ordnung der Entwicklung solange erh@"oht wie sie
kleiner oder gleich @code{2^taylordepth} ist.

Siehe auch @mrefdot{taylor}
@end defvr

@c --- 28.02.2011 DK -----------------------------------------------------------
@anchor{taylorinfo}
@deffn {Funktion} taylorinfo (@var{expr})

Gibt Informationen @"uber die Taylorreihe @var{expr} zur@"uck.  Die R@"uckgabe
ist eine Liste, die Listen mit den Namen der Variablen, den Entwicklungspunkten
und den Ordnungen der Entwicklung enthalten.

Ist @var{expr} keine Taylorreihe, ist die R@"uckgabe @code{false}.

Beispiele:

@example
(%i1) taylor ((1 - y^2)/(1 - x), x, 0, 3, [y, a, inf]);
                  2                       2
(%o1)/T/ - (y - a)  - 2 a (y - a) + (1 - a )

         2                        2
 + (1 - a  - 2 a (y - a) - (y - a) ) x

         2                        2   2
 + (1 - a  - 2 a (y - a) - (y - a) ) x

         2                        2   3
 + (1 - a  - 2 a (y - a) - (y - a) ) x  + . . .
(%i2) taylorinfo(%);
(%o2)               [[y, a, inf], [x, 0, 3]]
@end example
@end deffn

@c --- 28.02.2011 DK -----------------------------------------------------------
@anchor{taylorp}
@deffn {Funktion} taylorp (@var{expr})

Hat den R@"uckgabewert @code{true}, wenn das Argument @var{expr} eine
Taylorreihe ist.  Ansonsten ist der R@"uckgabewert @code{false}.
@end deffn

@c --- 28.02.2011 DK -----------------------------------------------------------
@anchor{taylor_logexpand}
@defvr {Optionsvariable} taylor_logexpand
Standardwert: @code{true}

@c TODO: WAS BEDEUTET DAS? KEIN BEISPIEL GEFUNDEN.

@c @code{taylor_logexpand} controls expansions of logarithms in @code{taylor} 
@c series.
@c When @code{taylor_logexpand} is @code{true}, all logarithms are expanded
@c fully so that zero-recognition problems involving logarithmic identities do
@c not disturb the expansion process.  However, this scheme is not always
@c mathematically correct since it ignores branch information.
@c When @code{taylor_logexpand} is set to @code{false}, then the only expansion
@c of logarithms that occur is that necessary to obtain a formal power series.

@code{taylor_logexpand} kontrolliert die Entwicklung von Logarithmen in einer
Taylorreihe.  Der Standardwert ist @code{true} und die Logarithmusfunktionen in
einer Reihenentwicklung werden vollst@"andig entwickelt.  Ansonsten werden
Logarithmusfunktionen so weit entwickelt, wie es notwendig ist, um eine formale
Reihenentwicklung zu erhalten.
@end defvr

@c --- 28.02.2011 DK -----------------------------------------------------------
@anchor{taylor_order_coefficients}
@defvr {Optionsvariable} taylor_order_coefficients
Standardwert: @code{true}

@c TODO: KEIN BEISPIEL GEFUNDEN.  WIE FUNKTIONIERT DAS?

@c @code{taylor_order_coefficients} controls the ordering of coefficients in a 
@c Taylor series.
@c When @code{taylor_order_coefficients} is @code{true}, coefficients of taylor 
@c series are ordered canonically.

Die Optionsvariable @code{taylor_order_coefficients} kontrolliert die Ordnung
der Koeffizienten einer Taylorreihenentwicklung.
Hat @code{taylor_order_coefficients} den Wert @code{true}, werden die
Koeffizienten kanonisch angeordnet.
@end defvr

@c --- 28.02.2011 DK -----------------------------------------------------------
@anchor{taylor_simplifier}
@defvr {Optionsvariable} taylor_simplifier
Standardwert: @code{SIMPLIFY}

@c TODO: KEIN GUTES BEISPIEL GEFUNDEN.
@c       MOEGLICHE NUTZLICHE FUNKTIONEN WIE RADCAN ODER FACTOR WERDEN ZWAR
@c       AUFGERUFEN, ABER DIE ERZIELTEN BLEIBEN IM ERGEBNIS NICHT ERHALTEN.

Die Optionsvariable @code{taylor_simplifier} enth@"alt den Namen der Funktion,
die f@"ur die Vereinfachung der Koeffizienten einer Taylorreihenentwicklung
von @mref{taylor} aufgerufen wird.  Der Standardwert ist die Lisp-Funktion
@code{SIMPLIFY}.
@end defvr

@c --- 28.02.2011 DK -----------------------------------------------------------
@anchor{taylor_truncate_polynomials}
@defvr {Optionsvariable} taylor_truncate_polynomials
Standardwert: @code{true}

@c TODO: IST DIE DOKUMENTATON KORREKT? IST DAS BEISPIEL KORREKT?
@c       DER ENGLISCHE TEXT IST NICHT VERSTAENDLICH.

@c When @code{taylor_truncate_polynomials} is @code{true}, polynomials are 
@c truncated based upon the input truncation levels.
@c Otherwise, polynomials input to @code{taylor} are considered to have infinite 
@c precison.

Hat die Optionsvariable @code{taylor_truncate_polynomials} den Wert
@code{false}, wird das Ergebnis der Reihenentwicklung eines Polynoms als exakt
angenommen.

Beispiel:

@example
(%i1) taylor(x^6+x^4+x^2,x,0,4),taylor_truncate_polynomials:true;
                          2    4
(%o1)/T/                 x  + x  + . . .
(%i2) taylor(x^6+x^4+x^2,x,0,4),taylor_truncate_polynomials:false;
                              2    4
(%o2)/T/                     x  + x
@end example
@end defvr

@c --- 28.02.2011 DK -----------------------------------------------------------
@anchor{taytorat}
@deffn {Funktion} taytorat (@var{expr})

Konvertiert den Ausdruck @var{expr} von der speziellen Darstellung einer
Taylorreihenentwicklung in eine CRE-Form.

Beispiel:

@example
(%i1) taylor(atan(x),x,0,5);
                            3    5
                           x    x
(%o1)/T/               x - -- + -- + . . .
                           3    5
(%i2) taytorat(%);
@group
                          5      3
                       3 x  - 5 x  + 15 x
(%o2)/R/               ------------------
                               15
@end group
@end example
@end deffn

@c --- 28.02.2011 DK -----------------------------------------------------------
@anchor{trunc}
@deffn {Funktion} trunc (@var{expr})

Die R@"uckgabe der Funktion @code{trunc} ist ein Ausdruck, der das Argument
@var{expr} in der Ausgabe wie eine Taylorreihenentwicklung anzeigt.  Der
Ausdruck @var{expr} wird ansonsten nicht modifiziert.

Beispiel:

@example
(%i1) expr: x^2 + x + 1;
                            2
(%o1)                      x  + x + 1
(%i2) trunc (expr);
                                2
(%o2)                  1 + x + x  + . . .
(%i3) is (expr = trunc (expr));
(%o3)                         true
@end example
@end deffn

@c --- 28.02.2011 DK -----------------------------------------------------------
@anchor{verbose}
@defvr {Optionsvariable} verbose
Standardwert: @code{false}

Hat die Optionsvariable @code{verbose} den Wert @code{true}, werden von der
Funktion @mref{powerseries} Meldungen @"uber die verwendeten Algorithmen 
ausgegeben.
@end defvr

@c -----------------------------------------------------------------------------
@node Poisson Reihen, Kettenbr@"uche, Funktionen und Variablen f@"ur Reihen, Summen Produkte und Reihen
@section Poisson Reihen
@c -----------------------------------------------------------------------------

@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{intopois}
@deffn {Function} intopois (@var{a})

Converts @var{a} into a Poisson encoding.
@end deffn

@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{outofpois}
@deffn {Function} outofpois (@var{a})

Converts @var{a} from Poisson encoding to general representation.  If @var{a} 
is not in Poisson form, @code{outofpois} carries out the conversion, i.e., 
the return value is @code{outofpois (intopois (@var{a}))}. This function is 
thus a canonical simplifier for sums of powers of sine and cosine terms of a 
particular type.
@end deffn

@c NEED MORE INFO HERE
@c NEED EXAMPLES HERE

@c -----------------------------------------------------------------------------
@anchor{poisdiff}
@deffn {Function} poisdiff (@var{a}, @var{b})

Differentiates @var{a} with respect to @var{b}. @var{b} must occur only
in the trig arguments or only in the coefficients.
@end deffn

@c LOOKING AT THE CODE IN src/pois3.lisp, THIS FCN SEEMS TO COMPUTE THE EXPONENT
@c BY MULTIPLYING IN A LOOP
@c DUNNO HOW WE WANT TO EXPLAIN THAT
@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poisexpt}
@deffn {Function} poisexpt (@var{a}, @var{b})

Functionally identical to @code{intopois (@var{a}^@var{b})}. @var{b} must be a
positive integer.
@end deffn

@c WHAT IS THIS ABOUT ??

@c -----------------------------------------------------------------------------
@anchor{poisint}
@deffn {Function} poisint (@var{a}, @var{b})

Integrates in a similarly restricted sense (to @code{poisdiff}).  Non-periodic 
terms in @var{b} are dropped if @var{b} is in the trig arguments.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{poislim}
@defvr {Option variable} poislim
Default value: 5

@code{poislim} determines the domain of the coefficients in the arguments of 
the trig functions.  The initial value of 5 corresponds to the interval 
[-2^(5-1)+1,2^(5-1)], or [-15,16], but it can be set to [-2^(n-1)+1, 2^(n-1)].
@end defvr

@c UMM, WHAT IS THIS ABOUT EXACTLY ?? EXAMPLES NEEDED

@c -----------------------------------------------------------------------------
@anchor{poismap}
@deffn {Function} poismap (@var{series}, @var{sinfn}, @var{cosfn})

will map the functions @var{sinfn} on the sine terms and @var{cosfn} on the 
cosine terms of the Poisson series given. @var{sinfn} and @var{cosfn} are 
functions of two arguments which are a coefficient and a trigonometric part 
of a term in series respectively.
@end deffn

@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poisplus}
@deffn {Function} poisplus (@var{a}, @var{b})

Is functionally identical to @code{intopois (a + b)}.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{poissimp}
@deffn {Function} poissimp (@var{a})

Converts @var{a} into a Poisson series for @var{a} in general representation.
@end deffn

@c MORE INFO NEEDED HERE

@c -----------------------------------------------------------------------------
@anchor{poisson}
@defvr {Special symbol} poisson

The symbol @code{/P/} follows the line label of Poisson series expressions.
@end defvr

@c -----------------------------------------------------------------------------
@anchor{poissubst}
@deffn {Function} poissubst (@var{a}, @var{b}, @var{c})

Substitutes @var{a} for @var{b} in @var{c}.  @var{c} is a Poisson series.

(1) Where @var{B} is a variable @var{u}, @var{v}, @var{w}, @var{x}, @var{y}, or 
@var{z}, then @var{a} must be an expression linear in those variables (e.g., 
@code{6*u + 4*v}).

(2) Where @var{b} is other than those variables, then @var{a} must also be
free of those variables, and furthermore, free of sines or cosines.

@code{poissubst (@var{a}, @var{b}, @var{c}, @var{d}, @var{n})} is a special 
type of substitution which operates on @var{a} and @var{b} as in type (1) above,
but where @var{d} is a Poisson series, expands @code{cos(@var{d})} and 
@code{sin(@var{d})} to order @var{n} so as to provide the result of substituting
@code{@var{a} + @var{d}} for @var{b} in @var{c}.  The idea is that @var{d} is an
expansion in terms of a small parameter.  For example,
@code{poissubst (u, v, cos(v), %e, 3)} yields @code{cos(u)*(1 - %e^2/2) - 
sin(u)*(%e - %e^3/6)}.
@end deffn

@c REPHRASE WITHOUT USING THE TERM "FUNCTIONALLY IDENTICAL"

@c -----------------------------------------------------------------------------
@anchor{poistimes}
@deffn {Function} poistimes (@var{a}, @var{b})

Is functionally identical to @code{intopois (@var{a}*@var{b})}.
@end deffn

@c HOW DOES THIS WORK ?? NEED MORE INFO AND EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{poistrim}
@deffn {Function} poistrim ()

is a reserved function name which (if the user has defined it) gets applied 
during Poisson multiplication.  It is a predicate function of 6 arguments which 
are the coefficients of the @var{u}, @var{v}, @dots{}, @var{z} in a term.  Terms
for which @code{poistrim} is @code{true} (for the coefficients of that term) 
are eliminated during multiplication.
@end deffn

@c -----------------------------------------------------------------------------
@anchor{printpois}
@deffn {Function} printpois (@var{a})

Prints a Poisson series in a readable format.  In common with @code{outofpois}, 
it will convert @var{a} into a Poisson encoding first, if necessary.
@end deffn

@c -----------------------------------------------------------------------------
@node Kettenbr@"uche, , Poisson Reihen, Summen Produkte und Reihen
@section Kettenbr@"uche
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{cf}
@deffn {Function} cf (@var{expr})

Converts @var{expr} into a continued fraction. @var{expr} is an expression
comprising continued fractions and square roots of integers. Operands in the 
expression may be combined with arithmetic operators. Aside from continued 
fractions and square roots, factors in the expression must be integer or 
rational numbers. Maxima does not know about operations on continued fractions 
outside of @code{cf}.

@code{cf} evaluates its arguments after binding @code{listarith} to 
@code{false}. @code{cf} returns a continued fraction, represented as a list.

A continued fraction @code{a + 1/(b + 1/(c + ...))} is represented by the list 
@code{[a, b, c, ...]}. The list elements @code{a}, @code{b}, @code{c}, @dots{}
must evaluate to integers. @var{expr} may also contain @code{sqrt (n)} where
@code{n} is an integer. In this case @code{cf} will give as many terms of the
continued fraction as the value of the variable @code{cflength} times the
period.

A continued fraction can be evaluated to a number by evaluating the arithmetic 
representation returned by @code{cfdisrep}. See also @code{cfexpand} for another 
way to evaluate a continued fraction.

See also @code{cfdisrep}, @code{cfexpand}, and @code{cflength}.

Examples:

@itemize @bullet
@item
@var{expr} is an expression comprising continued fractions and square roots of integers.

@example
(%i1) cf ([5, 3, 1]*[11, 9, 7] + [3, 7]/[4, 3, 2]);
(%o1)               [59, 17, 2, 1, 1, 1, 27]
(%i2) cf ((3/17)*[1, -2, 5]/sqrt(11) + (8/13));
(%o2)        [0, 1, 1, 1, 3, 2, 1, 4, 1, 9, 1, 9, 2]
@end example

@item
@code{cflength} controls how many periods of the continued fraction
are computed for algebraic, irrational numbers.

@example
(%i1) cflength: 1$
(%i2) cf ((1 + sqrt(5))/2);
(%o2)                    [1, 1, 1, 1, 2]
(%i3) cflength: 2$
(%i4) cf ((1 + sqrt(5))/2);
(%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
(%i5) cflength: 3$
(%i6) cf ((1 + sqrt(5))/2);
(%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]
@end example

@item
A continued fraction can be evaluated by evaluating the arithmetic representation
returned by @code{cfdisrep}.

@example
(%i1) cflength: 3$
(%i2) cfdisrep (cf (sqrt (3)))$
(%i3) ev (%, numer);
(%o3)                   1.731707317073171
@end example

@item
Maxima does not know about operations on continued fractions outside of @code{cf}.

@example
(%i1) cf ([1,1,1,1,1,2] * 3);
(%o1)                     [4, 1, 5, 2]
(%i2) cf ([1,1,1,1,1,2]) * 3;
(%o2)                  [3, 3, 3, 3, 3, 6]
@end example

@end itemize
@end deffn

@c NEEDS CLARIFICATION -- MAKE EXPLICIT HOW list IS RELATED TO a, b, c, ...
@c ALSO, CAN list CONTAIN ANYTHING OTHER THAN LITERAL INTEGERS ??

@c -----------------------------------------------------------------------------
@deffn {Function} cfdisrep (@var{list})

Constructs and returns an ordinary arithmetic expression
of the form @code{a + 1/(b + 1/(c + ...))}
from the list representation of a continued fraction @code{[a, b, c, ...]}.

@example
(%i1) cf ([1, 2, -3] + [1, -2, 1]);
(%o1)                     [1, 1, 1, 2]
(%i2) cfdisrep (%);
                                  1
(%o2)                     1 + ---------
                                    1
                              1 + -----
                                      1
                                  1 + -
                                      2
@end example
@end deffn

@c -----------------------------------------------------------------------------
@deffn {Function} cfexpand (@var{x})

Returns a matrix of the numerators and denominators of the
last (column 1) and next-to-last (column 2) convergents of the continued fraction @var{x}.

@example
(%i1) cf (rat (ev (%pi, numer)));

`rat' replaced 3.141592653589793 by 103993/33102 =3.141592653011902
(%o1)                  [3, 7, 15, 1, 292]
(%i2) cfexpand (%); 
                         [ 103993  355 ]
(%o2)                    [             ]
                         [ 33102   113 ]
(%i3) %[1,1]/%[2,1], numer;
(%o3)                   3.141592653011902
@end example
@end deffn

@c -----------------------------------------------------------------------------
@defvr {Option variable} cflength
Default value: 1

@code{cflength} controls the number of terms of the continued
fraction the function @code{cf} will give, as the value @code{cflength} times the
period.  Thus the default is to give one period.

@example
(%i1) cflength: 1$
(%i2) cf ((1 + sqrt(5))/2);
(%o2)                    [1, 1, 1, 1, 2]
(%i3) cflength: 2$
(%i4) cf ((1 + sqrt(5))/2);
(%o4)               [1, 1, 1, 1, 1, 1, 1, 2]
(%i5) cflength: 3$
(%i6) cf ((1 + sqrt(5))/2);
(%o6)           [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2]
@end example
@end defvr

@c --- End of file Series.de.texi ----------------------------------------------

