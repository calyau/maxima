@c Language: German
@c English original: Program.texi CVS 1.21

@menu
* Einführung in Steuerstrukturen::  
* Definitionen für Steuerstrukturen::  
@end menu

@node Einführung in Steuerstrukturen, Definitionen für Steuerstrukturen, Steuerstrukturen, Steuerstrukturen
@section Einführung in Steuerstrukturen

Maxima stellt verschiedene @code{do}-Schleifen für die Iteration zur Verfügung, 
und mit @code{go} auch ein etwas primitiveres Konstrukt.

@c end concepts Steuerstrukturen
@node Definitionen für Steuerstrukturen,  , Einführung in Steuerstrukturen, Steuerstrukturen
@section Definitionen für Steuerstrukturen

@deffn {Funktion} backtrace ()
@deffnx {Funktion} backtrace (@var{n})
Gibt den Stapelspeicher aus, d.h. die Funktionen,
die die gerade aktive Funktion aufgerufen haben.

Beispiele:

@itemize @bullet
@item
@code{backtrace()} gibt den gesamten Stapelspeicher aus.

@example
(%i1) h(x) := g(x/7)$
(%i2) g(x) := f(x-11)$
(%i3) f(x) := e(x^2)$
(%i4) e(x) := (backtrace(), 2*x + 13)$
(%i5) h(10);
#0: e(x=4489/49)
#1: f(x=-67/7)
#2: g(x=10/7)
#3: h(x=10)
                              9615
(%o5)                         ----
                               49
@end example
@end itemize

@itemize @bullet
@item
@code{backtrace (@var{n})} gibt einschließlich der
gerade aktiven Funktion die @var{n} letzten Funktionen aus.

@example
(%i1) h(x) := (backtrace(1), g(x/7))$
(%i2) g(x) := (backtrace(1), f(x-11))$
(%i3) f(x) := (backtrace(1), e(x^2))$
(%i4) e(x) := (backtrace(1), 2*x + 13)$
(%i5) h(10);
#0: h(x=10)
#0: g(x=10/7)
#0: f(x=-67/7)
#0: e(x=4489/49)
                              9615
(%o5)                         ----
                               49
@end example
@end itemize

@end deffn

@deffn {Spezieller Operator} do
Die Anweisung @code{do} bewirkt die Ausführung der Iteration.
Die vielfältigen Erscheinungsformen der @code{do}-Anweisung werden
folgend in mehreren Abschnitten beschrieben.
Als erstes wird die gewöhnliche Form vorgestellt,
die analog zu der ist, die man in anderen Programmiersprachen findet
(Fortran, Algol, PL/I, etc.).
Anschließend werden dann weitere Möglichkeiten genannt.

Es gibt drei Varianten, die sich nur in ihrer Endbedingung unterscheiden.  
Sie sind:

@itemize @bullet
@item
@code{for @var{variable}: @var{initial_value} step @var{increment}
      thru @var{limit} do @var{body}}
@item
@code{for @var{variable}: @var{initial_value} step @var{increment}
      while @var{condition} do @var{body}}
@item
@code{for @var{variable}: @var{initial_value} step @var{increment}
      unless @var{condition} do @var{body}}
@end itemize

@c UGH. DO WE REALLY NEED TO MENTION THIS??
(Alternativ kann @code{step} auch nach der Endbedingung angegeben werden.)

@var{initial_value}, @var{increment}, @var{limit} und @var{body} kann jeder 
Ausdruck sein. Ist @var{increment} 1, darf "@code{step 1}" auch weggelassen werden.

Bei der Ausführung der @code{do}-Anweisung wird zuerst @var{initial_value} 
der Variablen (im folgenden Kontrollvariable genannt) zugewiesen.
Dann: (1) Wenn die Kontrollvariable den Wert @var{limit} der 
@code{thru}-Spezifikation überschritten hat, oder wenn die Bedingung 
@var{condition} von @code{unless} @code{true} ist, 
oder wenn die Bedingung
@var{condition} von @code{while} @code{false} ist, endet @code{do}.
(2) @var{body} wird ausgewertet.
(3) @var{increment} wird zur Kontrollvariable addiert.
Die Schritte (1) bis (3) werden solange ausgeführt bis irgend eine 
Endbedingung erfüllt ist.

Der @code{thru}-Test ist erfüllt, wenn im Falle eines nicht-negativen 
Inkrements die Kontrollvariable größer als @var{limit} ist, oder
entsprechend bei negativem Inkrement die Kontrollvariable kleiner als 
@var{limit} ist. @var{increment} und @var{limit} können auch
nicht-numerische Ausdrücke sein, solange es möglich ist, die entsprechende 
Ungleichung auszuwerten. Wenn jedoch das Inkrement bei der Eingabe der
@code{do}-Anweisung nicht syntaktisch negativ ist, dann nimmt Maxima bei der
Ausführung der Schleife an, dass es positiv ist. Ist es das nicht, dann
kann die Schleife eventuell nicht korrekt enden.

Beachte, dass @var{increment}, @var{limit} und die Endbedingung
in jedem Schleifendurchlauf ausgewertet werden. Benötigt einer dieser Ausdrücke
viel Rechenzeit, ändert aber während des Schleifendurchlaufs nicht seinen
Wert, ist es wesentlich effizienter, diesen Wert vor der @code{do}-Schleife einer
Variablen zuzuweisen und diese dann in der @code{do}-Anweisung zu verwenden.

Der Wert, der normalerweise von einer @code{do}-Anweisung zurückgegeben
wird, ist das Atom @code{done}.
Die Funktion @code{return} kann jedoch im Inneren des Schleifenrumpfs
verwendet werden, um die Schleife vorzeitig zu verlassen und
einen beliebigen Rückgabewert festzulegen.
Beachte hierbei, dass @code{return} in einer @code{do}-Anweisung, die
innerhalb eines @code{block}-Konstrukts verwendet wird, nur @code{do}
beenden kann, nicht aber @code{block}.
Beachte auch, dass die Funktion @code{go} keinen Sprung aus einem @code{do}
in einen umgebenden @code{block} ermöglicht.

Die Kontrollvariable ist stets eine lokale Variable der @code{do}-Anweisung.
Ihr Wert kann daher den Wert einer Variablen außerhalb des @code{do} mit 
gleichem Namen nicht beeinflussen. Nach der Terminierung der Schleife ist 
die Kontrollvariable ungebunden.

@example
(%i1) for a:-3 thru 26 step 7 do display(a)$
                             a = - 3

                              a = 4

                             a = 11

                             a = 18

                             a = 25
@end example

@example
(%i1) s: 0$
(%i2) for i: 1 while i <= 10 do s: s+i;
(%o2)                         done
(%i3) s;
(%o3)                          55
@end example

Beachte, dass die Bedingung @code{while i <= 10} zu  
@code{unless i > 10}  und auch zu  @code{thru 10}  gleichwertig ist.

@example
(%i1) series: 1$
(%i2) term: exp (sin (x))$
(%i3) for p: 1 unless p > 7 do
          (term: diff (term, x)/p, 
           series: series + subst (x=0, term)*x^p)$
(%i4) series;
                  7    6     5    4    2
                 x    x     x    x    x
(%o4)            -- - --- - -- - -- + -- + x + 1
                 90   240   15   8    2
@end example

Das Beispiel zeigt 8 Terme der Taylorreihe von @code{e^sin(x)}.

@example
(%i1) poly: 0$
(%i2) for i: 1 thru 5 do
          for j: i step -1 thru 1 do
              poly: poly + i*x^j$
(%i3) poly;
                  5      4       3       2
(%o3)          5 x  + 9 x  + 12 x  + 14 x  + 15 x
(%i4) guess: -3.0$
(%i5) for i: 1 thru 10 do
          (guess: subst (guess, x, 0.5*(x + 10/x)),
           if abs (guess^2 - 10) < 0.00005 then return (guess));
(%o5)                  - 3.162280701754386
@end example

In diesem Beispiel wird die negative Quadratwurzel von 10 mit Hilfe von 10
Newton-Raphson-Iterationen berechnet. Wäre die Konvergenzbedingung nicht
erfüllt, hätte die Schleife nur @code{done} zurückgegeben.

Anstatt stets eine bestimmte Einheit zur Kontrollvariable zu addieren,
möchte man vielleicht die Kontrollvariable in jedem Schleifendurchlauf
auf eine andere Art und Weise verändern.
In diesem Fall kann man @code{next @var{expression}} anstelle von
@code{step @var{increment}} verwenden.
Die Kontrollvariable wird dadurch nach jedem Schleifendurchlauf auf den 
aktuellen Wert von @var{expression} gesetzt.

@example
(%i6) for count: 2 next 3*count thru 20 do display (count)$
                            count = 2

                            count = 6

                           count = 18
@end example

@c UGH. DO WE REALLY NEED TO MENTION THIS??
Als Alternative zu @code{for @var{variable}: @var{value} ...do...}
kann die Syntax @code{for @var{variable} from @var{value} ...do...} 
verwendet werden.
Dies ermöglicht, dass @code{from @var{value}} auch hinter
@code{step @var{increment}} oder @code{next @var{expression}}
oder der Endbedingung platziert werden kann. Wenn @code{from @var{value}}
weggelassen wurde, wird 1 als Startwert verwendet.

Manchmal wird man auch eine Iteration durchführen wollen, in der die
Kontrollvariable gar nicht im Schleifenrumpf verwendet wird. 
Dann genügt es, nur die Endbedingung anzugeben. Auf die Initialisierung 
und die Angabe des Inkrements wird wie in dem folgenden Beispiel 
verzichtet. Hier wird die Quadratwurzel von 5 mit einem mit einem 
relativ schlechten Schätzwert berechnet.

@example
(%i1) x: 1000$
(%i2) thru 20 do x: 0.5*(x + 5.0/x)$
(%i3) x;
(%o3)                   2.23606797749979
(%i4) sqrt(5), numer;
(%o4)                   2.23606797749979
@end example

Wenn gewünscht, kann auch auf die Endbedingung verzichtet werden.
@code{do @var{body}} genügt.
Der Schleifenrumpf wird dann endlos wiederholt ausgewertet.
In diesem Fall sollte die Funktion @code{return} verwendet werden, 
um die @code{do}-Schleife zu beenden.

@example
(%i1) newton (f, x):= ([y, df, dfx], df: diff (f ('x), 'x),
          do (y: ev(df), x: x - f(x)/y, 
              if abs (f (x)) < 5e-6 then return (x)))$
(%i2) sqr (x) := x^2 - 5.0$
(%i3) newton (sqr, 1000);
(%o3)                   2.236068027062195
@end example

@c DUNNO IF WE NEED THIS LEVEL OF DETAIL; THIS ARTICLE IS GETTING PRETTY LONG
(Beachte, dass in diesem Beispiel mit @code{return} zwar nur die
@code{do}-Schleife beendet wird, da aber @code{do} die letzte Anweisung
in @code{block} ist, wird der letzte aktuelle Wert von @code{x} dann
sowohl von @code{do} als auch von der Funktion @code{newton}
zurückgegeben.)

Maxima verfügt noch über eine andere Form der @code{do}-Anweisung.
Die Syntax ist:

@example
for @var{variable} in @var{list} @var{end_tests} do @var{body}
@end example

Die Elemente der Liste können beliebige Ausdrücke sein. Diese werden
in jeder Iteration der Schleife sukzessive der Kontrollvariablen zugewiesen.
Die optionale Endbedingung @var{end_tests} kann verwendet werden,
um die Ausführung der @code{do}-Anweisung zu beenden.
Andernfalls terminiert die Schleife, wenn die Liste erschöpft ist oder wenn
im Schleifenrumpf @code{return} ausgeführt wurde.
(Tatsächlich kann @var{list} jeder Ausdruck sein, der kein Atom ist.
Seine Teile werden dann sukzessive verwendet.)

@example
(%i1)  for f in [log, rho, atan] do ldisp(f(1))$
(%t1)                                  0
(%t2)                                rho(1)
                                     %pi
(%t3)                                 ---
                                      4
(%i4) ev(%t3,numer);
(%o4)                             0.78539816
@end example

@end deffn

@deffn {Funktion} errcatch (@var{expr_1}, ..., @var{expr_n})
Wertet @var{expr_1}, ..., @var{expr_n} nacheinander aus und
gibt @code{[@var{expr_n}]} (eine Liste) zurück,
wenn kein Fehler auftritt. Sollte bei der Auswertung irgend eines Arguments
ein Fehler auftreten, verhindert @code{errcatch} die Meldung des Fehlers
und gibt ohne die Auswertung eines weiteren Arguments die leere Liste @code{[]} zurück.

@code{errcatch} ist nützlich in @code{batch}-Dateien,
in denen man einen Fehler vermutet, der dann @code{batch} beenden würde,
sollte der Fehler nicht aufgefangen werden.

@end deffn

@deffn {Funktion} error (@var{expr_1}, ..., @var{expr_n})
@deffnx {System variable} error
Wertet und gibt @var{expr_1}, ..., @var{expr_n} aus,
und bewirkt dann einen Fehlerrücksprung in den Maxima Top Level oder in
das nächste umgebende @code{errcatch}.

Die Variable @code{error} ist eine Liste, die den Fehler beschreibt.
Das erste Element von @code{error} ist ein Formatierungsstring,
der alle Strings unter den @var{expr_1}, ..., @var{expr_n} enthält,
und die restlichen Elemente sind die Werte der Nicht-String-Argumente.

@code{errormsg()} gibt dann @code{error} formatiert aus.
Im Endeffekt ist dies dann eine erneute Ausgabe der letzten Fehlermeldung.

@end deffn

@deffn {Funktion} errormsg ()
Gibt erneut die letzte Fehlermeldung aus.
Die Variable @code{error} enthält die Meldung,
und @code{errormsg} gibt sie formatiert aus.

@end deffn

@c REPHRASE
@deffn {Spezieller Operator} for
Wird bei Iterationen verwendet. Siehe @code{do} zur Beschreibung
der Iteration in Maxima.

@end deffn

@deffn {Funktion} go (@var{tag})
Wird in einem @code{block} verwendet, um die Programmkontrolle
an eine Anweisung zu übergeben, die mit dem Argument von @code{go}
markiert ist. Um eine Anweisung zu markieren, stellt man ihr ein Atom als eine
zusätzliche Anweisung in @code{block} voran. Zum Beispiel:

@example
block ([x], x:1, loop, x+1, ..., go(loop), ...)
@end example

Das Argument von @code{go} muss der Name einer Marke sein, die im gleichen
@code{block} steht. Man kann @code{go} nicht verwenden, um eine Marke
in einem anderen @code{block} zu erreichen als den, der dieses @code{go}
enthält.

@end deffn

@c NEEDS CLARIFICATION, EXPANSION, EXAMPLES
@c THIS ITEM IS IMPORTANT
@deffn {Spezieller Operator} if
@code{if} wird für die bedingte Anweisung verwendet.
Die Syntax ist:

@example
if <condition> then <expr_1> else <expr_2>
@end example

Der Wert einer @code{if}-Anweisung ist @var{expr_1} wenn die Bedingung
@var{condition} @code{true} ist, und @var{expr_2} im Falle von
@code{false}.
@var{expr_1} und @var{expr_2} sind beliebige Maxima Ausdrücke
(einschließlich ineinander geschachtelter @code{if}-Anweisungen), 
und @var{condition} ist ein Ausdruck, der zu @code{true} oder @code{false}
ausgewertet wird und mit Hilfe der folgenden vergleichenden und 
logischen Operatoren zusammengesetzt ist:

@c - SEEMS LIKE THIS TABLE WANTS TO BE IN A DISCUSSION OF PREDICATE FUNCTIONS; PRESENT LOCATION IS OK I GUESS
@c - REFORMAT THIS TABLE USING TEXINFO MARKUP (MAYBE)
@example
Operation              Symbol      Typ
 
kleiner als            <           vergleichend infix
kleiner oder gleich    <=          vergleichend infix
gleich (syntaktisch)   =           vergleichend infix
Negation von =         #           vergleichend infix
gleich (Wert)          equal       vergleichend Funktion
Negation von equal     notequal    vergleichend Funktion
größer oder gleich     >=          vergleichend infix
größer                 >           vergleichend infix
und                    and         logisch infix
oder                   or          logisch infix
nicht                  not         logisch präfix
@end example

@end deffn

@c NEEDS CLARIFICATION
@c THIS ITEM IS IMPORTANT
@deffn {Funktion} map (@var{f}, @var{expr_1}, ..., @var{expr_n})
Gibt einen Ausdruck zurück, dessen Hauptoperator derselbe ist wie
in den Ausdrücken @var{expr_1}, ..., @var{expr_n},
dessen Teile aber das Ergebnis der Anwendung von @var{f} auf die einander
entsprechenden Teile der Ausdrücke sind.
@var{f} ist entweder der Name einer Funktion mit @math{n} Argumenten
oder eine @code{lambda}-Form  mit @math{n} Argumenten.

Wird die Optionsvariable @code{maperror} auf @code{false} gesetzt,
bewirkt dies, dass die map-Funktionen (1) in dem Fall, dass die
Ausdrücke @var{expr_i} nicht alle die gleiche Länge besitzen, nach
dem Erreichen des Endes des kürzesten @var{expr_i} endet und (2)
in dem Fall, dass die @var{expr_i} nicht alle vom gleichen Objekttyp sind,
die Funktion @var{f} auf die Liste [@var{expr_1}, @var{expr_2}, ...]
anwendet (im Sinne von @code{apply}).
Ist @code{maperror} auf @code{true} gesetzt (Standardeinstellung),
wird in den genannten Fällen eine Fehlermeldung ausgegeben.

Einer der Verwendungszwecke von @code{map} ist, eine Funktion
(z.B. @code{partfrac}) auf jeden Term eines recht großen Ausdrucks
anzuwenden, falls es nicht möglich ist, die Funktion auf den gesamten Ausdruck
anzuwenden, bedingt durch ein Erschöpfen des Speicherplatzes während der
Auswertung.

@c IN THESE EXAMPLES, SPELL OUT WHAT IS THE MAIN OPERATOR 
@c AND SHOW HOW THE RESULT FOLLOWS FROM THE DESCRIPTION STATED IN THE FIRST PARAGRAPH
@example
(%i1) map(f,x+a*y+b*z);
(%o1)                        f(b z) + f(a y) + f(x)
(%i2) map(lambda([u],partfrac(u,x)),x+1/(x^3+4*x^2+5*x+2));
                           1       1        1
(%o2)                     ----- - ----- + -------- + x
                         x + 2   x + 1          2
                                         (x + 1)
(%i3) map(ratsimp, x/(x^2+x)+(y^2+y)/y);
                                      1
(%o3)                            y + ----- + 1
                                    x + 1
(%i4) map("=",[a,b],[-0.5,3]);
(%o4)                          [a = - 0.5, b = 3]


@end example
@end deffn

@deffn {Funktion} mapatom (@var{expr})
Gibt @code{true} zurück, genau dann wenn @var{expr}
von den map-Funktionen als Atom angesehen wird. "Mapatome" sind Atome,
Zahlen (einschließlich der rationalen Zahlen) und indizierte Variablen.
@c WHAT ARE "THE MAPPING ROUTINES", AND WHY DO THEY HAVE A SPECIALIZED NOTION OF ATOMS ??
@c "MAPPING ROUTINES" HERE TRANSLATED AS "MAP FUNCTIONS" - VvN

@end deffn

@c NEEDS CLARIFICATION
@defvr {Option variable} maperror
Standardeinstellung: @code{true}

Wird @code{maperror} auf @code{false} gesetzt,
bewirkt dies, dass alle map-Funktionen, zum Beispiel

@example
map (f, expr_1, expr_2, ...))
@end example

(1) in dem Fall, dass die
Ausdrücke @var{expr_i} nicht alle die gleiche Länge besitzen, nach
dem Erreichen des Endes des kürzesten @var{expr_i} endet und (2)
in dem Fall, dass die @var{expr_i} nicht alle vom gleichen Objekttyp sind,
die Funktion @var{f} auf die Liste [@var{expr_1}, @var{expr_2}, ...]
anwendet (im Sinne von @code{apply}).

Ist @code{maperror} auf @code{true} gesetzt,
wird in den genannten Fällen eine Fehlermeldung ausgegeben.

@end defvr

@c NEEDS CLARIFICATION
@deffn {Funktion} maplist (@var{f}, @var{expr_1}, ..., @var{expr_n})
Gibt eine Liste von Anwendungen von @var{f} auf die einander
entsprechenden Teile der Ausdrücke @var{expr_1}, ..., @var{expr_n}
zurück. @var{f} ist der Name einer Funktion oder eines Lambda-Ausdrucks.

@code{maplist} ist zu unterscheiden von
@code{map (@var{f}, @var{expr_1}, ..., @var{expr_n})},
welches einen Ausdruck mit demselben Hauptoperator, den die @var{expr_i}
besitzen, zurück gibt. (Ausnahmen bilden Vereinfachungen und der Fall,
dass @code{map} @code{apply} anwendet.)

@end deffn

@c NEEDS CLARIFICATION
@defvr {Option variable} prederror
Standardwert: @code{true}

Ist @code{prederror} @code{true}, wird, wann immer das Prädikat
einer @code{if}-Anweisung oder einer @code{is}-Funktion nicht zu
@code{true} oder @code{false} ausgewertet werden kann,
eine Fehlermeldung ausgegeben.

Ist @code{prederror} @code{false}, wird statt dessen @code{unknown}
zurückgegeben.
Der Modus @code{prederror: false} wird nicht in übersetztem Code
unterstützt. @code{maybe} wird dagegen in übersetztem Code
unterstützt.

Siehe auch @code{is} und @code{maybe}.

@end defvr

@deffn {Funktion} return (value)
Kann verwendet werden, um ausdrücklich einen Programmblock
mit ihrem Argument als Rückgabewert zu verlassen.
Siehe @code{block} für mehr Informationen.

@end deffn

@c NEEDS CLARIFICATION
@deffn {Funktion} scanmap (@var{f}, @var{expr})
@deffnx {Funktion} scanmap (@var{f}, @var{expr}, bottomup)
Wendet @var{f} nach einer Top-down-Methode rekursiv auf @var{expr}
an. Dies ist besonders nützlich, wenn eine vollständige Faktorisierung 
gewünscht wird, zum Beispiel:

@example
(%i1) exp:(a^2+2*a+1)*y + x^2$
(%i2) scanmap(factor,exp);
                                    2      2
(%o2)                         (a + 1)  y + x
@end example

Beachte, in welcher Weise @code{scanmap} die gegebene Funktion @code{factor}
auf die Bestandteile von @var{expr} anwendet.
Wird @code{scanmap} eine andere Form von @var{expr} übergeben, kann
das Resultat ein anderes sein.
So ist @code{%o2} nicht wiederhergestellt, wenn @code{scanmap} auf
die ausmultiplizierte Form von @var{exp} angewendet wird:

@example
(%i3) scanmap(factor,expand(exp));
                           2                  2
(%o3)                      a  y + 2 a y + y + x
@end example

Hier ist ein anderes Beispiel für die Art und Weise, in der @code{scanmap}
rekursiv eine gegebene Funktion auf alle Teilausdrücke anwendet,
einschließlich der Exponenten:

@example
(%i4) expr : u*v^(a*x+b) + c$
(%i5) scanmap('f, expr);
                    f(f(f(a) f(x)) + f(b))
(%o5) f(f(f(u) f(f(v)                      )) + f(c))
@end example

@code{scanmap (@var{f}, @var{expr}, bottomup)} wendet @var{f}
auf @var{expr} nach einer Bottom-up-Methode an.
Z.B. für ein undefiniertes @code{f},

@example
scanmap(f,a*x+b) ->
   f(a*x+b) -> f(f(a*x)+f(b)) -> f(f(f(a)*f(x))+f(b))
scanmap(f,a*x+b,bottomup) -> f(a)*f(x)+f(b)
    -> f(f(a)*f(x))+f(b) ->
     f(f(f(a)*f(x))+f(b))
@end example

In diesem Fall erhält man auf beiden Wegen dasselbe Ergebnis.

@end deffn

@deffn {Funktion} throw (@var{expr})
Wertet @var{expr} aus und wirft den Wert des letzten @code{catch} aus.
@code{throw} wird zusammen mit @code{catch} als Mechanismus
für einen nichtlokalen Rücksprung verwendet.

@end deffn

@deffn {Funktion} outermap (@var{f}, @var{a_1}, ..., @var{a_n})
Wendet die Funktion @var{f} auf jedes Element des äußeren
Produkts @var{a_1} kreuz @var{a_2} ... kreuz @var{a_n} an.

@var{f} ist der Name einer Funktion von @math{n} Argumenten
oder ein Lambda-Ausdruck von @math{n} Argumenten.
Jedes Argument @var{a_k} kann eine Liste oder eine geschachtelte Liste,
eine Matrix oder jede andere Art von Ausdruck sein.

Der Rückgabewert von @code{outermap} ist eine geschachtelte Struktur.
Sei @var{x} der Rückgabewert.
Dann hat @var{x} dieselbe Struktur wie das erste Listen-, geschachtelte 
Listen- oder Matrix-Argument,
@code{@var{x}[i_1]...[i_m]} hat dieselbe Struktur wie das zweite Listen-, 
geschachtelte Listen- oder Matrix-Argument,
@code{@var{x}[i_1]...[i_m][j_1]...[j_n]}  hat dieselbe Struktur wie das 
dritte Listen-, geschachtelte Listen- oder Matrix-Argument, u.s.w.,
wobei @var{m}, @var{n}, ... die Anzahl der Indizes ist, die jeweils
benötigt werden, um auf die Elemente des jeweiligen Arguments zugreifen zu können
(Eins für eine Liste, zwei für eine Matrix und eins oder mehr für eine
geschachtelte Liste).
Argumente, die keine Listen oder Matrizen sind, haben auf die Struktur des
Rückgabewertes keinen Einfluss.

Beachte, dass sich der Effekt von @code{outermap} von einer Anwendung von
@var{f} auf jedes Element des vom @code{cartesian_product}
zurückgegebenen äußeren Produkts unterscheidet.
@code{outermap} hält die Struktur der Argumente im Rückgabewert aufrecht,
während @code{cartesian_product} dies nicht tut.

@code{outermap} wertet seine Argumente aus.

Siehe auch @code{map}, @code{maplist}, und @code{apply}.
@c CROSS REF OTHER FUNCTIONS HERE ??

Beispiele:

Elementare Beispiele von @code{outermap}.
Um die Kombination der Argumente klar zeigen zu können, bleibt @code{F}
undefiniert.

@c ===beg===
@c outermap (F, [a, b, c], [1, 2, 3]);
@c outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
@c outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
@c outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
@c outermap ("+", [a, b, c], [1, 2, 3]);
@c ===end===
@example
(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) outermap (F, matrix ([a, b], [c, d]), matrix ([1, 2], [3, 4]));
         [ [ F(a, 1)  F(a, 2) ]  [ F(b, 1)  F(b, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(a, 3)  F(a, 4) ]  [ F(b, 3)  F(b, 4) ] ]
(%o2)    [                                            ]
         [ [ F(c, 1)  F(c, 2) ]  [ F(d, 1)  F(d, 2) ] ]
         [ [                  ]  [                  ] ]
         [ [ F(c, 3)  F(c, 4) ]  [ F(d, 3)  F(d, 4) ] ]
(%i3) outermap (F, [a, b], x, matrix ([1, 2], [3, 4]));
       [ F(a, x, 1)  F(a, x, 2) ]  [ F(b, x, 1)  F(b, x, 2) ]
(%o3) [[                        ], [                        ]]
       [ F(a, x, 3)  F(a, x, 4) ]  [ F(b, x, 3)  F(b, x, 4) ]
(%i4) outermap (F, [a, b], matrix ([1, 2]), matrix ([x], [y]));
       [ [ F(a, 1, x) ]  [ F(a, 2, x) ] ]
(%o4) [[ [            ]  [            ] ], 
       [ [ F(a, 1, y) ]  [ F(a, 2, y) ] ]
                              [ [ F(b, 1, x) ]  [ F(b, 2, x) ] ]
                              [ [            ]  [            ] ]]
                              [ [ F(b, 1, y) ]  [ F(b, 2, y) ] ]
(%i5) outermap ("+", [a, b, c], [1, 2, 3]);
(%o5) [[a + 1, a + 2, a + 3], [b + 1, b + 2, b + 3], 
                                           [c + 1, c + 2, c + 3]]
@end example

Eine nähere Betrachtung der Rückgabewerte von @code{outermap}.
Das erste, zweite und dritte Argument sind eine Matrix, eine Liste bzw. eine Matrix.
Der Rückgabewert ist eine Matrix. Jedes Element dieser Matrix ist eine Liste,
und jedes Element jeder Liste ist eine Matrix.

@c ===beg===
@c arg_1 :  matrix ([a, b], [c, d]);
@c arg_2 : [11, 22];
@c arg_3 : matrix ([xx, yy]);
@c xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, arg_2, arg_3);
@c xx_1 : xx_0 [1][1];
@c xx_2 : xx_0 [1][1] [1];
@c xx_3 : xx_0 [1][1] [1] [1][1];
@c [op (arg_1), op (arg_2), op (arg_3)];
@c [op (xx_0), op (xx_1), op (xx_2)];
@c ===end===
@example
(%i1) arg_1 :  matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) arg_2 : [11, 22];
(%o2)                       [11, 22]
(%i3) arg_3 : matrix ([xx, yy]);
(%o3)                      [ xx  yy ]
(%i4) xx_0 : outermap (lambda ([x, y, z], x / y + z), arg_1, arg_2, arg_3);
               [  [      a        a  ]  [      a        a  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
(%o4)  Col 1 = [                                              ]
               [  [      c        c  ]  [      c        c  ]  ]
               [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
               [  [      11       11 ]  [      22       22 ]  ]
                 [  [      b        b  ]  [      b        b  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
         Col 2 = [                                              ]
                 [  [      d        d  ]  [      d        d  ]  ]
                 [ [[ xx + --  yy + -- ], [ xx + --  yy + -- ]] ]
                 [  [      11       11 ]  [      22       22 ]  ]
(%i5) xx_1 : xx_0 [1][1];
           [      a        a  ]  [      a        a  ]
(%o5)     [[ xx + --  yy + -- ], [ xx + --  yy + -- ]]
           [      11       11 ]  [      22       22 ]
(%i6) xx_2 : xx_0 [1][1] [1];
                      [      a        a  ]
(%o6)                 [ xx + --  yy + -- ]
                      [      11       11 ]
(%i7) xx_3 : xx_0 [1][1] [1] [1][1];
                                  a
(%o7)                        xx + --
                                  11
(%i8) [op (arg_1), op (arg_2), op (arg_3)];
(%o8)                  [matrix, [, matrix]
(%i9) [op (xx_0), op (xx_1), op (xx_2)];
(%o9)                  [matrix, [, matrix]
@end example

@code{outermap} hält die Struktur der Argumente im Rückgabewert aufrecht, 
während @code{cartesian_product} dies nicht tut.

@c ===beg===
@c outermap (F, [a, b, c], [1, 2, 3]);
@c setify (flatten (%));
@c map (lambda ([L], apply (F, L)), cartesian_product ({a, b, c}, {1, 2, 3}));
@c is (equal (%, %th (2)));
@c ===end===
@example
(%i1) outermap (F, [a, b, c], [1, 2, 3]);
(%o1) [[F(a, 1), F(a, 2), F(a, 3)], [F(b, 1), F(b, 2), F(b, 3)], 
                                     [F(c, 1), F(c, 2), F(c, 3)]]
(%i2) setify (flatten (%));
(%o2) @{F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)@}
(%i3) map (lambda ([L], apply (F, L)), cartesian_product (@{a, b, c@}, @{1, 2, 3@}));
(%o3) @{F(a, 1), F(a, 2), F(a, 3), F(b, 1), F(b, 2), F(b, 3), 
                                       F(c, 1), F(c, 2), F(c, 3)@}
(%i4) is (equal (%, %th (2)));
(%o4)                         true
@end example

@end deffn
