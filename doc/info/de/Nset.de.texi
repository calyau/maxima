@c -----------------------------------------------------------------------------
@c File        : Nset.de.texi
@c License     : GNU General Public License (GPL)
@c Language    : German
@c Original    : Nset.texi revision 14.03.2011
@c Translation : Dr. Dieter Kaiser
@c Date        : 14.11.2010
@c Revision    : 25.04.2011
@c 
@c This file is part of Maxima -- GPL CAS based on DOE-MACSYMA
@c -----------------------------------------------------------------------------

@menu
* Einf@"uhrung in Mengen::
* Funktionen und Variablen f@"ur Mengen::
@end menu

@c -----------------------------------------------------------------------------
@node Einf@"uhrung in Mengen, Funktionen und Variablen f@"ur Mengen, Mengen, Mengen
@section Einf@"uhrung in Mengen
@c -----------------------------------------------------------------------------

@c Maxima provides set functions, such as intersection and 
@c union, for finite sets that are defined by explicit enumeration.
@c Maxima treats 
@c lists and sets as distinct objects.  This feature makes it possible to
@c work with sets that have members that are either lists or sets.

Maxima hat Funktionen wie den Schnitt und die Vereinigung von endlichen Mengen,
die durch eine explizite Aufz@"ahlung definiert sind.  Listen und Mengen sind in
Maxima unterschiedliche Objekte.  Daher k@"onnen Listen, aber auch Mengen,
selbst Elemente von Mengen sein.  Siehe auch @ref{Listen}.

@c In addition to functions for finite sets, Maxima provides some
@c functions related to combinatorics; these include the Stirling
@c numbers of the first and second kind, the Bell numbers, multinomial
@c coefficients, partitions of nonnegative integers, and a few others.
@c Maxima also defines a Kronecker delta function.

Neben Funktionen f@"ur endliche Mengen, hat Maxima auch Funktionen der
Kombinatorik.  Darunter die Stirling-Zahlen der ersten und zweiten Art, die
Bellschen Zahlen, Multinomialverteilungen, Partitionsfunktionen oder die
Kronecker-Delta-Funktion.

@c -----------------------------------------------------------------------------
@subsection Anwendung

@c To construct a set with members @code{a_1, ..., a_n}, write
@c @code{set(a_1, ..., a_n)} or @code{@{a_1, ..., a_n@}};
@c to construct the empty set, write @code{set()} or @code{@{@}}.
@c In input, @code{set(...)} and @code{@{ ... @}} are equivalent.
@c Sets are always displayed with curly braces.

@c If a member is listed more than
@c once, simplification eliminates the redundant member.

Mit @code{set(a_1, ..., a_n} oder @code{@{a_1, ..., a_n@}} wird eine Menge
mit den Elementen @code{a_1, ..., a_n} konstruiert.  Die leere Menge
wird mit @code{set()} oder  @code{@{@}} angegeben.  In der Eingabe sind
@code{set(...)} und @code{@{ ... @}} @"aquivalent.  Mengen werden immer mit
geschweiften Klammern angezeigt.  Wird ein Element mehrmals angegeben, werden
die mehrfachen Elemente aus der Menge entfernt.

@noindent
Beispiele:

@example
(%i1) set();
(%o1)                          @{@}
(%i2) set(a, b, a);
(%o2)                        @{a, b@}
(%i3) set(a, set(b));
(%o3)                       @{a, @{b@}@}
(%i4) set(a, [b]);
(%o4)                       @{a, [b]@}
(%i5) @{@};
(%o5)                          @{@}
(%i6) @{a, b, a@};
(%o6)                        @{a, b@}
(%i7) @{a, @{b@}@};
(%o7)                       @{a, @{b@}@}
(%i8) @{a, [b]@};
(%o8)                       @{a, [b]@}
@end example

@c Two would-be elements @var{x} and @var{y} are redundant
@c (i.e., considered the same for the purpose of set construction)
@c if and only if @code{is(@var{x} = @var{y})} yields @code{true}.
   @c THAT IS BECAUSE THE SET SIMPLIFICATION CODE CALLS THE LISP FUNCTION LIKE,
   @c AND SO DOES THE CODE TO EVALUATE IS (X = Y).
@c Note that @code{is(equal(@var{x}, @var{y}))} can yield @code{true}
@c while @code{is(@var{x} = @var{y})} yields @code{false};
@c in that case the elements @var{x} and @var{y} are considered distinct.

Zwei Elemente @var{x} und @var{y} werden als gleich angesehen, wenn
@code{is(@var{x} = @var{y})} das Ergebnis @code{true} hat.  Es ist zu beachten,
dass @code{is(equal(@var{x}, @var{y}))} das Ergebnis @code{true} haben kann,
jedoch der Ausdruck @code{is(@var{x} = @var{y})} das Ergebnis @code{false}
liefert.  In diesem Fall werden die Elemente als verschieden betrachtet.

@example
(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
@group
                              b   a
(%o2)                         - + -
                              c   c
@end group
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) @{x, y, z@};
                          b + a  b   a
(%o9)                    @{-----, - + -@}
                            c    c   c
@end example

@c To construct a set from the elements of a list, use @code{setify}.

Mit der Funktion @mref{setify} kann eine Menge aus einer Liste konstruiert
werden.

@example
(%i1) setify ([b, a]);
(%o1)                        @{a, b@}
@end example

@c Set members @code{x} and @code{y} are equal provided @code{is(x = y)} 
@c evaluates to @code{true}. Thus @code{rat(x)} and @code{x} are equal as set
@c members; consequently, 

Die Elemente @code{x} und @code{y} einer Menge sind gleich, wenn der Ausdruck
@code{is(x = y)} das Ergebnis @code{true} hat.  Daher werden zum Beispiel
@code{rat(x)} und @code{x} als gleich betrachtet.

@example
(%i1) @{x, rat(x)@};
(%o1)                          @{x@}
@end example

@c Further, since @code{is((x - 1)*(x + 1) = x^2 - 1)} evaluates to
@c @code{false}, @code{(x - 1)*(x + 1)} and @code{x^2 - 1} are distinct set
@c members; thus

Da der Ausdruck @code{is((x - 1)*(x + 1) = x^2 - 1)} das Ergebnis @code{false}
hat, werden @code{(x - 1)*(x + 1)} und @code{x^2 - 1} als verschiedene Elemente
angenommen.

@example
(%i1) @{(x - 1)*(x + 1), x^2 - 1@};
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
@end example

@c To reduce this set to a singleton set, apply @code{rat} to each set member:

Um die Menge im letzten Beispiel auf ein Element zu reduzieren, kann die
Funktion @mref{rat} auf die Elemente der Menge angewendet werden.

@example
(%i1) @{(x - 1)*(x + 1), x^2 - 1@};
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
(%i2) map (rat, %);
                              2
(%o2)/R/                    @{x  - 1@}
@end example

@c To remove redundancies from other sets, you may need to use other
@c simplification functions. Here is an example that uses @code{trigsimp}:

Um redundante Elemente von Mengen zu entfernen, k@"onnen Funktionen f@"ur die
Vereinfachung von Ausdr@"ucken angewendet werden.  In diesem Beispiel wird
die Funktion @mref{trigsimp} auf die Elemente der Menge angewendet.

@example
(%i1) @{1, cos(x)^2 + sin(x)^2@};
                            2         2
(%o1)                @{1, sin (x) + cos (x)@}
(%i2) map (trigsimp, %);
(%o2)                          @{1@}
@end example

@c A set is simplified when its members are non-redundant and
@c sorted. The current version of the set functions uses the Maxima function
@c @code{orderlessp} to order sets; however, @i{future versions of
@c the set functions might use a different ordering function}.

@c Some operations on sets, such as substitution, automatically force a
@c re-simplification; for example,

Hat eine Menge redundante Elemente, wird sie vereinfacht und sortiert.  Die
Ordnung der Elemente wird von der Funktion @mref{orderlessp} bestimmt.  Einige
Operationen auf Mengen, wie zum Beispiel Substitutionen erzwingen die
Vereinfachung von Mengen.

@example
(%i1) s: @{a, b, c@}$
(%i2) subst (c=a, s);
(%o2)                        @{a, b@}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          @{x@}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        @{0, 1@}
@end example

@c Maxima treats lists and sets as distinct objects;
@c functions such as @code{union} and @code{intersection} complain
@c if any argument is not a set. If you need to apply a set
@c function to a list, use the @code{setify} function to convert it
@c to a set. Thus

Maxima behandelt Listen und Mengen als verschiedene Objekte.  Funktionen wie
@mref{union} oder @mref{intersection} geben eine Fehlermeldung, wenn die
Argumente keine Mengen sind.  Um eine Funktion f@"ur Mengen auf eine Liste
anzuwenden, kann diese mit der Funktion @mref{setify} in eine Menge
umgewandelt werden.

@example
(%i1) union ([1, 2], @{a, b@});
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), @{a, b@});
(%o2)                     @{1, 2, a, b@}
@end example

@c To extract all set elements of a set @code{s} that satisfy a predicate
@c @code{f}, use @code{subset(s, f)}.  (A @i{predicate} is a
@c boolean-valued function.) For example, to find the equations
@c in a given set that do not depend on a variable @code{z}, use

Mit der Funktion @mref{subset} kann eine Teilmenge ermittelt werden, deren
Elemente f@"ur eine Aussagefunktion das Ergebnis @code{true} haben.  Um die
Gleichungen einer Menge zu finden, die nicht von der Variablen @code{z}
abh@"angen, wird im Folgenden die Aussagefunktion @mref{freeof} verwendet.

@example
(%i1) subset (@{x + y + z, x - y + 4, x + y - 5@},
                                    lambda ([e], freeof (z, e)));
(%o1)               @{- y + x + 4, y + x - 5@}
@end example

@c The section @ref{Funktionen und Variablen f@"ur Mengen} has a complete list
@c of the set functions in Maxima.

In @ref{Funktionen und Variablen f@"ur Mengen} sind die Funktionen dokumentiert,
die Maxima f@"ur Mengen kennt.

@c -----------------------------------------------------------------------------
@subsection Iteration @"uber Mengen

@c There two ways to to iterate over set members.  One way is the use
@c @code{map}; for example:

Es gibt zwei M@"oglichkeiten, @"uber die Elemente einer Menge zu iterieren.
Im ersten Fall wird die Funktion @mref{map} genutzt.

@example
(%i1) map (f, @{a, b, c@});
(%o1)                  @{f(a), f(b), f(c)@}
@end example

@c The other way is to use @code{for @var{x} in @var{s} do}

Eine weitere M@"oglichkeit, ist eine @mref{for}-Schleife einzusetzen.

@example
(%i1) s: @{a, b, c@};
(%o1)                       @{a, b, c@}
(%i2) for si in s do print (concat (si, 1));
a1 
b1 
c1 
(%o2)                         done
@end example

@c The Maxima functions @code{first} and @code{rest} work
@c correctly on sets. Applied to a set, @code{first} returns the first
@c displayed element of a set; which element that is may be
@c implementation-dependent. If @code{s} is a set, then 
@c @code{rest(s)} is equivalent to @code{disjoin(first(s), s)}.
@c Currently, there are other Maxima functions that work correctly
@c on sets.  In future versions of the set functions,
@c @code{first} and @code{rest} may function differently or not at all.

Die Funktionen @mref{first} und @mref{rest} funktionieren auch f@"ur Mengen.
Wird die Funktion @code{first} auf eine Menge angewendet, ist das Ergebnis
das erste Element, wie es in der Anzeige erscheint.  Ist @code{s} eine Menge,
dann ist der Ausdruck @code{rest(s)} @"aquivalent zu
@code{disjoin(first(s), s)}.  Siehe die Funktion @mrefdot{disjoin}

@c -----------------------------------------------------------------------------
@subsection Programmfehler

@c TODO: DIE FOLGENDEN PROGRAMMFEHLER TRETEN NICHT MEHR AUF

@c The set functions use the Maxima function @code{orderlessp} to 
@c order set members and the (Lisp-level) function @code{like} to test for set
@c member equality.  Both of these functions have known bugs
@c that may manifest if you attempt to use
@c sets with members that are lists or matrices that contain expressions
@c in canonical rational expression (CRE) form.  An example is

@c @example
@c (%i1) @{[x], [rat (x)]@};
@c Maxima encountered a Lisp error:
@c 
@c The value #:X1440 is not of type LIST.
@c 
@c Automatically continuing.
@c To reenable the Lisp debugger set *debugger-hook* to nil.
@c @end example

@c This expression causes Maxima to halt with an error (the error message
@c depends on which version of Lisp your Maxima uses).  Another
@c example is

@c @example
@c (%i1) setify ([[rat(a)], [rat(b)]]);
@c Maxima encountered a Lisp error:
@c 
@c The value #:A1440 is not of type LIST.
@c 
@c Automatically continuing.
@c To reenable the Lisp debugger set *debugger-hook* to nil.
@c @end example

@c These bugs are caused by bugs in @code{orderlessp} and @code{like}; they
@c are not caused by bugs in the set functions.  To illustrate, try the
@c expressions

@c @example
@c (%i1) orderlessp ([rat(a)], [rat(b)]);
@c Maxima encountered a Lisp error:
@c 
@c The value #:B1441 is not of type LIST.
@c 
@c Automatically continuing.
@c To reenable the Lisp debugger set *debugger-hook* to nil.
@c (%i2) is ([rat(a)] = [rat(a)]);
@c (%o2)                         false
@c @end example

@c Until these bugs are fixed, do not construct sets with members that
@c are lists or matrices containing expressions in CRE form; a set with a 
@c member in CRE form, however, shouldn't be a problem:

@c @example
@c (%i1) @{x, rat (x)@};
@c (%o1)                          @{x@}
@c @end example

@c Maxima's @code{orderlessp} has another bug that can cause problems
@c with set functions, namely that the ordering predicate @code{orderlessp} is
@c not transitive.  The simplest known example that shows this is

@c @example
@c (%i1) q: x^2$
@c (%i2) r: (x + 1)^2$
@c (%i3) s: x*(x + 2)$
@c (%i4) orderlessp (q, r);
@c (%o4)                         true
@c (%i5) orderlessp (r, s);
@c (%o5)                         true
@c (%i6) orderlessp (q, s);
@c (%o6)                         false
@c @end example

@c This bug can cause trouble with all set functions as well as with
@c Maxima functions in general. It is probable, but not certain, that 
@c this bug can be avoided
@c if all set members are either in CRE form or have been simplified
@c using @code{ratsimp}.

   @c WHAT EXACTLY IS THE EFFECT OF ordergreat AND orderless ON THE SET FUNCTIONS ??
@c Maxima's @code{orderless} and @code{ordergreat} mechanisms are 
@c incompatible with the set functions.  If you need to use either
@c @code{orderless} or @code{ordergreat}, call those functions before
@c constructing any sets, and do not call @code{unorder}.

Die M@"oglichkeit mit den Funktionen @mref{orderless} und @mref{ordergreat}
eine neue Ordnung f@"ur Variablen zu definieren, ist nicht kompatibel mit den
Funktionen f@"ur Mengen.  Wird eine der Funktionen @code{orderless} oder
@code{ordergreat} ben@"otigt, sollten diese vor der Konstruktion der ersten
Menge ausgef@"uhrt werden.  Die Funktion @mref{unorder} sollte nicht
ausgef@"uhrt werden.

@c APPARENTLY THIS NEXT BIT REFERS TO BUG REPORT 798571
@c EXAMPLE WITH kron_delta (1/sqrt(2), sqrt(2)/2); NOW WORKS AS EXPECTED
@c COMMENT OUT PENDING CONSTRUCTION OF ANOTHER EXAMPLE WHICH TRIGGERS THE BUG
@c 
@c Maxima's sign function has a bug that may cause the Kronecker
@c delta function to misbehave; for example:
@c 
@c @c ===beg===
@c @c kron_delta (1/sqrt(2), sqrt(2)/2);
@c @c ===end===
@c @example
@c (%i1) kron_delta (1/sqrt(2), sqrt(2)/2);
@c (%o1)                           0
@c @end example
@c 
@c The correct value is 1; the bug is related to the @code{sign} bug
@c 
@c @c ===beg===
@c @c sign (1/sqrt(2) - sqrt(2)/2);
@c @c ===end===
@c @example
@c (%i1) sign (1/sqrt(2) - sqrt(2)/2);
@c (%o1)                          pos
@c @end example

@c If you find something that you think might be a set function bug, please
@c report it to the Maxima bug database.  See @code{bug_report}.

Programmfehler im Zusammenhang mit den Funktionen f@"ur Mengen k@"onnen
berichtet werden.  Siehe @ref{Programmfehler}.

@c -----------------------------------------------------------------------------
@subsection Autoren

@c Stavros Macrakis of Cambridge, Massachusetts and Barton Willis of the
@c University of Nebraska at Kearney (UNK) wrote the Maxima set functions and
@c their documentation.

Stavros Macrakis aus Cambridge, Massachusetts und Barton Willis von der
Universit@"at Nebraska in Kearney (UNK) haben die Funktionen und die
Dokumentation f@"ur Mengen geschrieben.

@c -----------------------------------------------------------------------------
@node Funktionen und Variablen f@"ur Mengen,  , Einf@"uhrung in Mengen, Mengen
@section Funktionen und Variablen f@"ur Mengen
@c -----------------------------------------------------------------------------

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{adjoin}
@deffn {Funktion} adjoin (@var{x}, @var{a})

@c Returns the union of the set @var{a} with @code{@{@var{x}@}}.

Vereinigt die Menge @var{a} mit @code{@{@var{x}@}} und gibt die vereinigte
Menge als Ergebnis zur@"uck.

@c @code{adjoin} complains if @var{a} is not a literal set.

@code{adjoin} gibt eine Fehlermeldung, wenn das Argument @var{a} keine Menge
ist.

@c @code{adjoin(@var{x}, @var{a})} and @code{union(set(@var{x}), @var{a})}
@c are equivalent; however, @code{adjoin} may be somewhat faster than
@c @code{union}.

@code{adjoin(@var{x}, @var{a})} und @code{union(set(@var{x}), @var{a})} sind
@"aquivalent.  Die Funktion @code{adjoin} kann etwas schneller als die Funktion
@mref{union} sein.

Siehe auch die Funktion @mrefdot{disjoin}

Beispiele:

@example
(%i1) adjoin (c, @{a, b@});
(%o1)                       @{a, b, c@}
(%i2) adjoin (a, @{a, b@});
(%o2)                        @{a, b@}
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{belln}
@deffn {Funktion} belln (@var{n})

@c Represents the @math{n}-th Bell number.
@c @code{belln(n)} is the number of partitions of a set with @var{n} members.

Repr@"asentiert die @math{n}-te Bellsche Zahl.

@c For nonnegative integers @var{n},
@c @code{belln(@var{n})} simplifies to the @math{n}-th Bell number.
@c @code{belln} does not simplify for any other arguments.

Ist das Argument @var{n} eine nicht-negative ganze Zahl, vereinfacht
@code{belln(@var{n})} zu der @math{n}-ten Bellschen Zahl.  F@"ur andere
Argumente vereinfacht die Funktion @code{belln} nicht.

@c @code{belln} distributes over equations, lists, matrices, and sets.

Ist das Argument der Funktion @code{belln} eine Liste, Menge, Matrix oder
eine Gleichung, wird die Funktion auf die Elemente oder beide Seiten der
Gleichung angewendet.

@need 600
Beispiele:

@c @code{belln} applied to nonnegative integers.

Anwendung der Funktion @code{belln} auf nicht-negative ganze Zahlen.

@example
(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions (@{@})) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions (@{1, 2, 3, 4, 5, 6@})) =
                       belln (6));
(%o3)                         true
@end example

@c @code{belln} applied to arguments which are not nonnegative integers.

Anwendung der Funktion @code{belln} auf andere Argumente als nicht-negative
ganze Zahlen.

@example
(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{cardinality}
@deffn {Funktion} cardinality (@var{a})

@c Returns the number of distinct elements of the set @var{a}.

Gibt die M@"achtigkeit (Kardinalit@"at) einer Menge zur@"uck.  F@"ur endliche
Mengen ist die M@"achtigkeit die Anzahl der Elemente der Menge.

@c @code{cardinality} ignores redundant elements
@c even when simplification is disabled.

@code{cardinality} ignoriert redundante Elemente einer Menge auch dann, wenn die
Vereinfachung abgeschaltet ist.

Beispiele:

@example
(%i1) cardinality (@{@});
(%o1)                           0
(%i2) cardinality (@{a, a, b, c@});
(%o2)                           3
(%i3) simp : false;
(%o3)                         false
(%i4) cardinality (@{a, a, b, c@});
(%o4)                           3
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{cartesian_product}
@deffn {Funktion} cartesian_product (@var{b_1}, @dots{}, @var{b_n})

@c Returns a set of lists of the form @code{[@var{x_1}, ..., @var{x_n}]}, where
@c @var{x_1}, ..., @var{x_n} are elements of the sets @var{b_1}, ..., @var{b_n},
@c respectively.

Gibt das kartesische Produkt der Mengen @var{b_1}, @dots{}, @var{b_n} zur@"uck.
Das kartesische Produkt ist die Menge der geordneten Paare.

Die R@"uckgabe ist eine Menge mit Listen der Form @code{[@var{x_1}, ..., 
@var{x_n}]}, wobei @var{x_1}, @dots{}, @var{x_n} die Elemente der Mengen
@var{b_1}, @dots{}, @var{b_n} sind.

@c @code{cartesian_product} complains if any argument is not a literal set.

Die Funktion @code{cartesian_product} gibt eine Fehlermeldung, wenn eines
der Argumente keine Menge ist.

Beispiele:

@example
(%i1) cartesian_product (@{0, 1@});
(%o1)                      @{[0], [1]@}
(%i2) cartesian_product (@{0, 1@}, @{0, 1@});
(%o2)           @{[0, 0], [0, 1], [1, 0], [1, 1]@}
(%i3) cartesian_product (@{x@}, @{y@}, @{z@});
(%o3)                      @{[x, y, z]@}
(%i4) cartesian_product (@{x@}, @{-1, 0, 1@});
(%o4)              @{[x, - 1], [x, 0], [x, 1]@}
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{disjoin}
@deffn {Funktion} disjoin (@var{x}, @var{a})

@c Returns the set @var{a} without the member @var{x}.
@c If @var{x} is not a member of @var{a}, return @var{a} unchanged.

Entfernt das Element @var{x} aus der Menge @var{a} und gibt das Ergebnis
zur@"uck.

@c @code{disjoin} complains if @var{a} is not a literal set.

@code{disjoin} gibt eine Fehlermeldung, wenn das Argument @var{a} keine Menge
ist.

@c @code{disjoin(@var{x}, @var{a})}, @code{delete(@var{x}, @var{a})}, and
@c @code{setdifference(@var{a}, set(@var{x}))} are all equivalent.
@c Of these, @code{disjoin} is generally faster than the others.

Die Ausdr@"ucke @code{disjoin(@var{x}, @var{a})}, @code{delete(@var{x},
@var{a})} und @code{setdifference(@var{a}, set(@var{x}))} sind @"aquivalent.
Von diesen M@"oglichkeiten ist im Allgemeinen die Funktion @code{disjoin} am 
schnellsten.

Siehe auch die Funktion @mref{adjoin} sowie die Funktionen @mref{delete} und
@mrefdot{setdifference}

Beispiele:

@example
(%i1) disjoin (a, @{a, b, c, d@});
(%o1)                       @{b, c, d@}
(%i2) disjoin (a + b, @{5, z, a + b, %pi@});
(%o2)                      @{5, %pi, z@}
(%i3) disjoin (a - b, @{5, z, a + b, %pi@});
(%o3)                  @{5, %pi, b + a, z@}
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{disjointp}
@deffn {Funktion} disjointp (@var{a}, @var{b})

@c Returns @code{true} if and only if the sets @var{a} and @var{b} are disjoint.

@code{disjointp} hat das Ergebnis @code{true}, wenn die Mengen @var{a} und
@var{b} disjunkt sind.  Zwei Mengen sind disjunkt, wenn sie kein gemeinsames
Element besitzen.

@c @code{disjointp} complains if either @var{a} or @var{b} is not a literal set.

@code{disjointp} gibt eine Fehlermeldung, wenn eines der Argumente keine
Menge ist.

Beispiele:

@example
(%i1) disjointp (@{a, b, c@}, @{1, 2, 3@});
(%o1)                         true
(%i2) disjointp (@{a, b, 3@}, @{1, 2, 3@});
(%o2)                         false
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{divisors}
@deffn {Funktion} divisors (@var{n})

@c Represents the set of divisors of @var{n}.

Repr@"asentiert die Menge der Teiler der Zahl @var{n}.

@c @code{divisors(@var{n})} simplifies to a set of integers
@c when @var{n} is a nonzero integer.
@c The set of divisors includes the members 1 and @var{n}.
@c The divisors of a negative integer are the divisors of its absolute value.

Ist das Argument @var{n} eine von Null verschiedene ganze Zahl, vereinfacht
@code{divisors(@var{n})} zu einer Menge mit ganzen Zahlen, die Teiler des
Argumentes @var{n} sind.  Ist das Argument @var{n} eine negative Zahl wird
der Betrag des Argumentes genommen.  Das Ergebnis enth@"alt die Elemente
@var{1} und @var{n}.

@c @code{divisors} distributes over equations, lists, matrices, and sets.

Ist das Argument der Funktion @code{divisors} eine Liste, Menge, Matrix oder
eine Gleichung, wird die Funktion auf die Elemente oder beide Seiten der
Gleichung angewendet.

Beispiele:

@c We can verify that 28 is a perfect number:
@c the sum of its divisors (except for itself) is 28.

Das Beispiel zeigt, dass 28 eine perfekte Zahl ist, die gleich die Summe
ihrer Teiler au@ss{}er sich selbst ist.

@example
(%i1) s: divisors(28);
(%o1)                 @{1, 2, 4, 7, 14, 28@}
(%i2) lreduce ("+", args(s)) - 28;
(%o2)                          28
@end example

@c @code{divisors} is a simplifying function.
@c Substituting 8 for @code{a} in @code{divisors(a)}
@c yields the divisors without reevaluating @code{divisors(8)}.

@code{divisors} ist eine vereinfachende Funktion.  In diesem Beispiel braucht
daher der Ausdruck nach der Substitution nicht erneut ausgewertet werden.

@example
(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     @{1, 2, 4, 8@}
@end example

@c @code{divisors} distributes over equations, lists, matrices, and sets.

Anwendung der Funktion @code{divisors} auf Gleichungen, Listen, Matrizen oder
Mengen.

@example
(%i1) divisors (a = b);
(%o1)               divisors(a) = divisors(b)
(%i2) divisors ([a, b, c]);
(%o2)        [divisors(a), divisors(b), divisors(c)]
(%i3) divisors (matrix ([a, b], [c, d]));
                  [ divisors(a)  divisors(b) ]
(%o3)             [                          ]
                  [ divisors(c)  divisors(d) ]
(%i4) divisors (@{a, b, c@});
(%o4)        @{divisors(a), divisors(b), divisors(c)@}
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{elementp}
@deffn {Funktion} elementp (@var{x}, @var{a})

@c Returns @code{true} if and only if @var{x} is a member of the
@c set @var{a}.

Gibt @code{true} zur@"uck, wenn das Argument @var{x} Element der Menge @var{a}
ist.

@c @code{elementp} complains if @var{a} is not a literal set.

@code{elementp} gibt eine Fehlermeldung, wenn das Argument @var{a} keine
Menge ist.

Beispiele:

@example
(%i1) elementp (sin(1), @{sin(1), sin(2), sin(3)@});
(%o1)                         true
(%i2) elementp (sin(1), @{cos(1), cos(2), cos(3)@});
(%o2)                         false
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{emptyp}
@deffn {Funktion} emptyp (@var{a})

@c Return @code{true} if and only if @var{a} is the empty set or
@c the empty list.

Gibt @code{true} zur@"uck, wenn das Argument @var{a} die leere Menge oder eine
leere Liste ist.

Beispiele:

@example
(%i1) map (emptyp, [@{@}, []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, @{@{@}@}, %pi]);
(%o2)                 [false, false, false]
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{equiv_classes}
@deffn {Funktion} equiv_classes (@var{s}, @var{F})

@c Returns a set of the equivalence classes of the set @var{s} with respect
@c to the equivalence relation @var{F}.

Gibt die Menge der @"Aquivalenzklassen der Menge @var{s} f@"ur die
@"Aquivalenzrelation @code{F} zur@"uck.

@c @var{F} is a function of two variables defined on the Cartesian product of
@c @var{s} with @var{s}.
@c The return value of @var{F} is either @code{true} or @code{false},
@c or an expression @var{expr} such that @code{is(@var{expr})} is either
@c @code{true} or @code{false}.

Die @"Aquivalenzrelation @code{F} ist eine Funktion mit zwei Argumenten
definiert auf dem Kartesischen Produkt der Menge @var{s} mit @var{s}.  Die
R@"uckgabe der Funktion @code{F} ist @code{true} oder @code{false} oder ein
Ausdruck @var{expr}, so dass @code{is(@var{expr})} das Ergebnis @code{true}
oder @code{false} hat.

@c When @var{F} is not an equivalence relation,
@c @code{equiv_classes} accepts it without complaint,
@c but the result is generally incorrect in that case.

Ist @var{F} keine @"Aquivalenzrelation, wird die Funktion von
@code{equiv_classes} ohne Fehlermeldung akzeptiert.  Das Ergebnis ist jedoch
im Allgemeinen nicht korrekt.

@c EXCESSIVE DETAIL HERE.  PROBABLY JUST CUT THIS
@c @var{F} may be a relational operator (built-in or user-defined),
@c an ordinary Maxima function, a Lisp function, a lambda expression,
@c a macro, or a subscripted function.

Beispiele:

@c The equivalence relation is a lambda expression which returns @code{true} or
@c @code{false}.

Die @"Aquivalenzrelation ist ein Lambda-Ausdruck mit den Ergebnissen
@code{true} oder @code{false}.

@example
(%i1) equiv_classes (@{1, 1.0, 2, 2.0, 3, 3.0@},
                        lambda ([x, y], is (equal (x, y))));
(%o1)            @{@{1, 1.0@}, @{2, 2.0@}, @{3, 3.0@}@}
@end example

@c The equivalence relation is the name of a relational function
@c which @code{is} evaluates to @code{true} or @code{false}.

Die @"Aquivalenzrelation ist der Name einer relationalen Funktion, die von
@code{is} zu @code{true} oder @code{false} ausgewertet werden.

@example
(%i1) equiv_classes (@{1, 1.0, 2, 2.0, 3, 3.0@}, equal);
(%o1)            @{@{1, 1.0@}, @{2, 2.0@}, @{3, 3.0@}@}
@end example

@c The equivalence classes are numbers which differ by a multiple of 3.

Die @"Aquivalenzklassen sind Mengen mit Zahlen, die sich um ein Vielfaches von
3 voneinander unterscheiden.

@example
(%i1) equiv_classes (@{1, 2, 3, 4, 5, 6, 7@},
                     lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              @{@{1, 4, 7@}, @{2, 5@}, @{3, 6@}@}
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{every}
@deffn  {Funktion} every (@var{f}, @var{s})
@deffnx {Funktion} every (@var{f}, @var{L_1}, @dots{}, @var{L_n})

@c Returns @code{true} if the predicate @var{f} is @code{true} for all given
@c arguments.

Gibt das Ergebnis @code{true} zur@"uck, wenn die Aussage @code{f} das Ergebnis
@code{true} f@"ur alle Elemente der Menge @var{s} hat.

@c Given one set as the second argument, @code{every(@var{f}, @var{s})} returns
@c @code{true} if @code{is(@var{f}(@var{a_i}))} returns @code{true} for all
@c @var{a_i} in @var{s}.  @code{every} may or may not evaluate @var{f} for all
@c @var{a_i} in @var{s}.  Since sets are unordered, @code{every} may evaluate
@c @code{@var{f}(@var{a_i})} in any order.

Ist das zweite Argument eine Menge, dann gibt @code{every(@var{f}, @var{s})}
den Wert @code{true} zur@"uck, wenn @code{is(@var{f}(@var{a_i}))} das Ergebnis
@code{true} f@"ur alle Elemente @var{a_i} der Menge @var{s} hat.  @code{every}
wertet @var{f} nicht notwendigerweise f√ºr alle Elemente @var{a_i} aus, wenn das
Ergebnis bereits feststeht.  Da Mengen nicht geordnet sind, kann die Funktion
@code{every} die Ausdr@"ucke @code{@var{f}(@var{a_i})} in irgendeiner
Reihenfolge auswerten.

@c Given one or more lists as arguments,
@c @code{every(@var{f}, @var{L_1}, ..., @var{L_n})} returns @code{true}
@c if @code{is(@var{f}(@var{x_1}, ..., @var{x_n}))} returns @code{true} 
@c for all @var{x_1}, ..., @var{x_n} in @var{L_1}, ..., @var{L_n}, respectively.
@c @code{every} may or may not evaluate 
@c @var{f} for every combination @var{x_1}, ..., @var{x_n}.
@c @code{every} evaluates lists in the order of increasing index.

Sind die Argumente eine oder mehrere Listen, dann gibt
@code{every(@var{f}, @var{L_1}, ..., @var{L_n})} den Wert @code{true} zur@"uck,
wenn @code{is(@var{f}(@var{x_1}, ..., @var{x_n}))} das Ergebnis @code{true}
f@"ur alle @var{x_1}, @dots{}, @var{x_n} der Listen @var{L_1}, @dots{},
@var{L_n} hat.  @code{every} wertet @var{f} wird nicht notwendigerweise f@"ur 
alle Kombinationen @var{x_1}, ..., @var{x_n} aus, wenn das Ergebnis bereits
feststeht.  @code{every} wertet die Listen in der Reihenfolge des steigenden
Index aus.

@c Given an empty set @code{@{@}} or empty lists @code{[]} as arguments,
@c @code{every} returns @code{false}.

Ist die leere Menge oder leere Liste ein Argument der Funktion @code{every},
dann ist das Ergebnis immer @code{false}.

@c When the global flag @code{maperror} is @code{true}, all lists 
@c @var{L_1}, ..., @var{L_n} must have equal lengths.
@c When @code{maperror} is @code{false}, list arguments are
@c effectively truncated to the length of the shortest list.

Hat die Optionsvariable @mref{maperror} den Wert @code{true}, m@"ussen alle
Listen @var{L_1}, @dots{}, @var{L_n} die gleiche L@"ange haben.  Hat die
Optionsvariable @code{maperror} den Wert @code{false}, werden die Listen auf
die L@"ange der k@"urzesten Liste abgeschnitten.

@c Return values of the predicate @var{f} which evaluate (via @code{is}) to
@c something other than @code{true} or @code{false} are governed by the global
@c flag @code{prederror}.
@c When @code{prederror} is @code{true},
@c such values are treated as @code{false},
@c and the return value from @code{every} is @code{false}.
@c When @code{prederror} is @code{false},
@c such values are treated as @code{unknown},
@c and the return value from @code{every} is @code{unknown}.

Kann die Aussagefunktion @var{f} von der Funktion @code{is} nicht zu @code{true}
oder @code{false} ausgewertet werden, h@"angt das Ergebnis von der
Optionsvariablen @mref{prederror} ab.  Hat die Optionsvariable @code{prederror}
den Wert @code{true}, werden solche Werte als @code{false} behandelt und die
Funktion @code{every} hat das Ergebnis @code{false}.  Hat @code{prederror}
den Wert @code{false}, werden solche Werte als @code{unknown} behandelt und die
Funktion @code{every} hat das Ergebnis @code{unknown}.

Beispiele:

@c @code{every} applied to a single set.
@c The predicate is a function of one argument.

@code{every} angewendet auf eine Menge.  Die Aussagefunktion hat ein Argument.

@example
(%i1) every (integerp, @{1, 2, 3, 4, 5, 6@});
(%o1)                         true
(%i2) every (atom, @{1, 2, sin(3), 4, 5 + y, 6@});
(%o2)                         false
@end example

@c @code{every} applied to two lists.
@c The predicate is a function of two arguments.

@code{every} angewendet auf zwei Listen.  Die Aussagefunktion hat zwei
Argumente entsprechend der Anzahl der Listen.

@example
(%i1) every ("=", [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) every ("#", [a, b, c], [a, b, c]);
(%o2)                         false
@end example

@c Return values of the predicate @var{f} which evaluate
@c to something other than @code{true} or @code{false}
@c are governed by the global flag @code{prederror}.

Kann die Aussagefunktion @var{f} nicht zu @code{true} oder @code{false}
ausgewertet werden, h@"angt das Ergebnis von @code{every} von der 
Optionsvariablen @code{prederror} ab.

@example
(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                   [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) prederror : true;
(%o4)                         true
(%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
(%o5)                         false
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{extremal_subset}
@deffn  {Funktion} extremal_subset (@var{s}, @var{f}, max)
@deffnx {Funktion} extremal_subset (@var{s}, @var{f}, min)

@c Returns the subset of @var{s} for which the function @var{f} takes on maximum
@c or minimum values.

Gibt die Teilmenge von @var{s} zur@"uck, f@"ur die die Funktion @var{f} maximale
oder minimale Ergebnisse hat.

@c @code{extremal_subset(@var{s}, @var{f}, max)} returns the subset of the set
@c or list @var{s} for which the real-valued function @var{f} takes on its
@c maximum value.

@code{extremal_subset(@var{s}, @var{f}, max)} gibt die Teilmenge der Liste oder
Menge @var{s} zur@"uck, f@"ur die die Funktion @var{f} ihre maximalen Werte
annimmt.

@c @code{extremal_subset(@var{s}, @var{f}, min)} returns the subset of the set
@c or list @var{s} for which the real-valued function @var{f} takes on its
@c minimum value.

@code{extremal_subset(@var{s}, @var{f}, min)} gibt die Teilmenge der Liste oder
Menge @var{s} zur@"uck, f@"ur die die Funktion @var{f} ihre minimalen Werte
annimmt.

Beispiele:

@example
(%i1) extremal_subset (@{-2, -1, 0, 1, 2@}, abs, max);
(%o1)                       @{- 2, 2@}
(%i2) extremal_subset (@{sqrt(2), 1.57, %pi/2@}, sin, min);
(%o2)                       @{sqrt(2)@}
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{flatten}
@deffn {Funktion} flatten (@var{expr})

@c Collects arguments of subexpressions which have the same operator as
@c @var{expr} and constructs an expression from these collected arguments.

Sammelt die Argumente von allen Teilausdr@"ucken, die denselben Operator wie
der Ausdruck @var{expr} haben und konstruiert einen Ausdruck mit dem Operator
des Ausdrucks @var{expr} und den Argumenten.  Ein einfaches Beispiel ist eine
verschachtelte Liste.  @code{flatten} konstruiert in diesem Fall eine Liste
aus den Elementen aller Teillisten.

@c Subexpressions in which the operator is different from the main operator of
@c @code{expr} are copied without modification, even if they, in turn, contain
@c some subexpressions in which the operator is the same as for @code{expr}.

Teilausdr@"ucke, deren Operator sich von dem Hauptoperator des Ausdrucks
@var{expr} unterscheidet, werden als ein Argument betrachtet, auch wenn der
Teilausdr@"uck wiederum Teilausdr@"ucke des Hauptoperators enth@"alt.

@c It may be possible for @code{flatten} to construct expressions in which the
@c number of arguments differs from the declared arguments for an operator;
@c this may provoke an error message from the simplifier or evaluator.
@c @code{flatten} does not try to detect such situations.

Es ist m@"oglich, dass @code{flatten} Ausdr@"ucke konstruiert, in denen die
Anzahl der Argumente nicht der erforderlichen Anzahl an Argumenten des Operators
entspricht.  Dies kann zu Fehlermeldungen bei der Auswertung oder Vereinfachung
f@"uhren.  @code{flatten} kontrolliert nicht, ob die konstruierten Ausdr@"ucke
g@"ultig sind.

@c Expressions with special representations, for example, canonical rational
@c expressions (CRE), cannot be flattened; in such cases, @code{flatten} returns
@c its argument unchanged.

Ausdr@"ucke mit speziellen Darstellungen, wie zum Beispiel CRE-Ausdr@"ucke,
k@"onnen von @code{flatten} nicht verarbeitet werden.  In diesem F@"allen gibt
@code{flatten} das Argument unver@"andert zur@"uck.

Beispiele:

@c Applied to a list, @code{flatten} gathers all list elements that are lists.

Wird @code{flatten} auf eine Liste angewendet, werden die Elemente aller
Teillisten zu einer Liste zusammengef@"ugt.

@example
(%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
(%o1)            [a, b, c, d, e, f, g, h, i, j]
@end example

@c Applied to a set, @code{flatten} gathers all members of set elements that
@c are sets.

Wird @code{flatten} auf eine Menge angewendet, werden die Elemente aller
Teilmengen zu einer Menge zusammengef@"ugt.

@example
(%i1) flatten (@{a, @{b@}, @{@{c@}@}@});
(%o1)                       @{a, b, c@}
(%i2) flatten (@{a, @{[a], @{a@}@}@});
(%o2)                       @{a, [a]@}
@end example

@c @code{flatten} is similar to the effect of declaring the main operator n-ary.
@c However, @code{flatten} has no effect on subexpressions which have an
@c operator different from the main operator, while an n-ary declaration affects
@c those.

Die Funktionsweise von @code{flatten} ist vergleichbar mit der Deklaration eines
Operators als ein N-ary-Operator.  Im Unterschied zu einer Deklaration hat 
@code{flatten} keinen Einfluss auf Teilausdr@"ucke, die einen vom Hauptoperator
verschiedenen Operator haben.

@example
(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
@end example

@c @code{flatten} treats subscripted functions the same as any other operator.

@code{flatten} behandelt indizierte Funktionen wie andere Operatoren.

@example
(%i1) flatten (f[5] (f[5] (x, y), z));
(%o1)                      f (x, y, z)
                            5
@end example

@c It may be possible for @code{flatten} to construct expressions in which the
@c number of arguments differs from the declared arguments for an operator;

Es ist m@"oglich, dass @code{flatten} einen Ausdruck konstruiert, der nicht die
korrekte Anzahl an Argumenten eines Operators enth@"alt.

@example
(%i1) 'mod (5, 'mod (7, 4));
(%o1)                   mod(5, mod(7, 4))
(%i2) flatten (%);
(%o2)                     mod(5, 7, 4)
(%i3) ''%, nouns;
Wrong number of arguments to mod
 -- an error.  Quitting.  To debug this try debugmode(true);
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{full_listify}
@deffn {Funktion} full_listify (@var{a})

@c Replaces every set operator in @var{a} by a list operator,
@c and returns the result.
@c @code{full_listify} replaces set operators in nested subexpressions,
@c even if the main operator is not @code{set}.

Ersetzt jedes Auftreten des Operators f@"ur Mengen in dem Ausdruck @var{a}
durch den Operator f@"ur Listen.  Die Ersetzung wird auch in verschachtelten
Teilausdr@"ucken ausgef@"uhrt, deren Operator nicht der Operator f@"ur Mengen
ist.

@c @code{listify} replaces only the main operator.

Die Funktion @mref{listify} ersetzt nur den Hauptoperator.

@need 800
Beispiele:

@example
(%i1) full_listify (@{a, b, @{c, @{d, e, f@}, g@}@});
(%o1)               [a, b, [c, [d, e, f], g]]
(%i2) full_listify (F (G (@{a, b, H(@{c, d, e@})@})));
(%o2)              F(G([a, b, H([c, d, e])]))
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{fullsetify}
@deffn {Funktion} fullsetify (@var{a})

@c When @var{a} is a list, replaces the list operator with a set operator,
@c and applies @code{fullsetify} to each member which is a set.
@c When @var{a} is not a list, it is returned unchanged.

Ist @var{a} eine Liste, wird der Operator f@"ur Listen durch den Operator f@"ur
Mengen ersetzt.  Dann wird @code{fullsetify} auf alle Argumente der Liste
angewendet.  Ist ein Argument keine Liste, wenn das Argument unver@"andert
zur@"uckgegeben.

@c @code{setify} replaces only the main operator.

Die Funktion @mref{setify} ersetzt nur den Hauptoperator.

Beispiele:

@c In line @code{(%o2)}, the argument of @code{f} isn't converted to a set
@c because the main operator of @code{f([b])} isn't a list.

Im zweiten Beispiel wird das Argument der Funktion @code{f} nicht in eine
Menge konvertiert, da der Operator des Teilausdrucks keine Liste ist.

@example
(%i1) fullsetify ([a, [a]]);
(%o1)                       @{a, @{a@}@}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      @{a, f([b])@}
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{identity}
@deffn {Funktion} identity (@var{x})

@c Returns @var{x} for any argument @var{x}.

Gibt f@"ur jedes Argument @var{x} das Argument selbst zur@"uck.

Beispiele:

@c @code{identity} may be used as a predicate when the arguments
@c are already Boolean values.

@code{identity} kann als eine Aussage genutzt werden, wenn die Argumente
bereits boolesche Werte sind.

@example
(%i1) every (identity, [true, true]);
(%o1)                         true
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{integer_partitions}
@deffn  {Funktion} integer_partitions (@var{n})
@deffnx {Funktion} integer_partitions (@var{n}, @var{len})

@c Returns integer partitions of @var{n}, that is,
@c lists of integers which sum to @var{n}.

Ermittelt die Zerlegung einer ganzen Zahl @var{n} in ganzen Zahlen, die
@var{n} als Summe haben.

@c @code{integer_partitions(@var{n})} returns the set of
@c all partitions of the integer @var{n}.
@c Each partition is a list sorted from greatest to least.

@code{integer_partitions(@var{n})} gibt eine Menge aller Zerlegungen der ganzen
Zahl @var{n} zur@"uck.  Jede Zerlegung ist eine Liste mit den ganzen Zahlen, die
@var{n} als Summe haben.  Die Listen sind nach der Gr@"o@ss{}e sortiert.

@c @code{integer_partitions(@var{n}, @var{len})}
@c returns all partitions that have length @var{len} or less; in this
@c case, zeros are appended to each partition with fewer than @var{len}
@c terms to make each partition have exactly @var{len} terms.
@c Each partition is a list sorted from greatest to least.

@code{integer_partitions(@var{n}, @var{len})} gibt eine Menge aller Zerlegungen
der ganzen Zahl @var{n} zur@"uck, deren Listen @code{len} oder weniger Elemente
haben.  Listen die weniger als @code{len} Elemente haben, werden mit Nullen
aufgef@"ullt.

@c TODO: MATHEMATISCHER HINTERGRUND NICHT UEBERSETZT

@c A list @math{[a_1, ..., a_m]} is a partition of a nonnegative integer
@c @math{n} when (1) each @math{a_i} is a nonzero integer, and (2) 
@c @math{a_1 + ... + a_m = n.} Thus 0 has no partitions.

Beispiele:

@example
(%i1) integer_partitions (3);
(%o1)               @{[1, 1, 1], [2, 1], [3]@}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply ("+", x)), s);
(%o4)                         @{25@}
(%i5) integer_partitions (5, 3);
(%o5) @{[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]@}
(%i6) integer_partitions (5, 2);
(%o6)               @{[3, 2], [4, 1], [5, 0]@}
@end example

@c To find all partitions that satisfy a condition, use the function
@c @code{subset}; here is an example that finds all partitions of 10 that
@c consist of prime numbers.

Um alle Zerlegungen zu finden, die eine Bedingung erf@"ullen, kann die Funktion
@mref{subset} genutzt werden.  In diesem Beispiel werden alle Zerlegungen
der Zahl 10 ermittelt, die nur Primzahlen enthalten.

@example
(%i1) s: integer_partitions (10)$
(%i2) cardinality (s);
(%o2)                          42
(%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
(%i4) subset (s, lambda ([x], every (xprimep, x)));
(%o4) @{[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]@}
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{intersect}
@deffn {Funktion} intersect (@var{a_1}, @dots{}, @var{a_n})

@c @code{intersect} is the same as @code{intersection}, which see.

@code{intersect} ist identisch mit der Funktion @mrefdot{intersection}
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{intersection}
@deffn {Funktion} intersection (@var{a_1}, @dots{}, @var{a_n})

@c Returns a set containing the elements that are common to the 
@c sets @var{a_1} through @var{a_n}.

Gibt die Schnittmenge der Mengen @var{a_1}, @dots{}, @var{a_n} zur@"uck.  Die
Schnittmenge enth@"alt die Elemente, die den Mengen gemeinsam sind.

@c @code{intersection} complains if any argument is not a literal set.

@code{intersection} gibt eine Fehlermeldung, wenn eines der Argumente
keine Liste ist.

Beispiele:

@example
(%i1) S_1 : @{a, b, c, d@};
(%o1)                     @{a, b, c, d@}
(%i2) S_2 : @{d, e, f, g@};
(%o2)                     @{d, e, f, g@}
(%i3) S_3 : @{c, d, e, f@};
(%o3)                     @{c, d, e, f@}
(%i4) S_4 : @{u, v, w@};
(%o4)                       @{u, v, w@}
(%i5) intersection (S_1, S_2);
(%o5)                          @{d@}
(%i6) intersection (S_2, S_3);
(%o6)                       @{d, e, f@}
(%i7) intersection (S_1, S_2, S_3);
(%o7)                          @{d@}
(%i8) intersection (S_1, S_2, S_3, S_4);
(%o8)                          @{@}
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{kron_delta}
@deffn {Funktion} kron_delta (@var{x}, @var{y})

@c Represents the Kronecker delta function.

Ist die Kronecker-Delta-Funktion.

@c @code{kron_delta} simplifies to 1 when @var{x} and @var{y} are identical or
@c demonstrably equivalent, and it simplifies to 0 when @var{x} and @var{y} are
@c demonstrably not equivalent.  Otherwise, it is not certain whether @var{x}
@c and @var{y} are equivalent, and @code{kron_delta} simplifies to a noun
@c expression.

@code{kron_delta} vereinfacht zu 1, wenn @var{x} und @var{y} identisch sind oder
als identisch gezeigt werden k@"onnen.  Das Ergebnis ist 0, wenn gezeigt werden
kann, das @var{x} und @var{y} nicht identisch sind.  In anderen F@"allen ist es
nicht sicher, dass @var{x} und @var{y} @"aquivalent sind und @code{kron_delta}
vereinfacht zu einer Substantivform.

@c TODO: DAS SCHEINT NICHT ZU STIMMEN.  NICHT UEBERSETZT.

@c @code{kron_delta} implements a cautious policy with respect to floating point
@c expressions: if the difference @code{@var{x} - @var{y}} is a floating point
@c number, @code{kron_delta} simplifies to a noun expression when @var{x} is
@c apparently equivalent to @var{y}.

@c Specifically, @code{kron_delta(@var{x}, @var{y})} simplifies to 1 when
@c @code{is(x = y)} is @code{true}.  @code{kron_delta} also simplifies to 1
@c when @code{sign(abs(@var{x} - @var{y}))} is @code{zero} and @code{@var{x} -
@c @var{y}} is not a floating point number (neither an ordinary float nor a
@c bigfloat).  @code{kron_delta} simplifies to 0 when @code{sign(abs(@var{x} -
@c @var{y}))} is @code{pos}.

Im Besonderen vereinfacht @code{kron_delta(@var{x}, @var{y})} zum Ergebnis 1,
wenn @code{is(x = y)} das Ergebnis @code{true} hat.  @code{kron_delta}
vereinfacht auch dann zu 1, wenn @code{sign(abs(@var{x} - @var{y}))} das
Ergebnis @code{zero} hat und @code{@var{x} - @var{y}} keine Gleitkommazahl ist.
@code{kron_delta} vereinfacht zu 0, wenn @code{sign(abs(@var{x} - @var{y}))}
das Ergebnis @code{pos} hat.

@c Otherwise, @code{sign(abs(@var{x} - @var{y}))} is something other than
@c @code{pos} or @code{zero}, or it is @code{zero} and @code{@var{x} - @var{y}}
@c is a floating point number.  In these cases, @code{kron_delta} returns a
@c noun expression.

Hat @code{sign(abs(@var{x} - @var{y}))} ein von @code{pos} oder @code{zero}
verschiedenes Ergebnis oder ist das Ergebnis @code{zero}, aber
@code{@var{x} - @var{y}} ist eine Gleitkommazahl, dann gibt @code{kron_delta}
eine Substantivform zur@"uck.

@c @code{kron_delta} is declared to be symmetric.  That is, 
@c @code{kron_delta(@var{x}, @var{y})} is equal to 
@c @code{kron_delta(@var{y}, @var{x})}.

@code{kron_delta} ist als symmetrisch deklariert.  Daher ist
@code{kron_delta(@var{x}, @var{y})} @"aquivalent zu
@code{kron_delta(@var{y}, @var{x})}.

Beispiele:

@c The arguments of @code{kron_delta} are identical.
@c @code{kron_delta} simplifies to 1.

Die Argumente der Funktion @code{kron_delta} sind identisch.  @code{kron_delta}
vereinfacht zu 1.

@example
(%i1) kron_delta (a, a);
(%o1)                           1
(%i2) kron_delta (x^2 - y^2, x^2 - y^2);
(%o2)                           1
(%i3) float (kron_delta (1/10, 0.1));
(%o3)                           1
@end example

@c The arguments of @code{kron_delta} are equivalent, and their difference is
@c not a floating point number.  @code{kron_delta} simplifies to 1.

Die Argumente der Funktion @code{kron_delta} sind @"aquivalent und die
Differenz ist keine Gleitkommazahl.  @code{kron_delta} vereinfacht zu 1.

@example
(%i1) assume (equal (x, y));
(%o1)                     [equal(x, y)]
(%i2) kron_delta (x, y);
(%o2)                           1
@end example

@c The arguments of @code{kron_delta} are not equivalent.
@c @code{kron_delta} simplifies to 0.

Die Argumente der Funktion @code{kron_delta} sind nicht @"aquivalent.
@code{kron_delta} vereinfacht zu 0.

@example
(%i1) kron_delta (a + 1, a);
(%o1)                           0
(%i2) assume (a > b)$
(%i3) kron_delta (a, b);
(%o3)                           0
(%i4) kron_delta (1/5, 0.7);
(%o4)                           0
@end example

@c The arguments of @code{kron_delta} might or might not be equivalent.
@c @code{kron_delta} simplifies to a noun expression.

Maxima kann nicht entscheiden, ob die Argumente @"aquivalent sind.
@code{kron_delta} vereinfacht zu einer Substantivform.

@example
(%i1) kron_delta (a, b);
(%o1)                   kron_delta(a, b)
(%i2) assume(x >= y)$
(%i3) kron_delta (x, y);
(%o3)                   kron_delta(x, y)
@end example

@c The arguments of @code{kron_delta} are equivalent,
@c but their difference is a floating point number.
@c @code{kron_delta} simplifies to a noun expression.

Die Argumente der Funktion @code{kron_delta} sind @"aquivalent, aber die
Differenz ist eine Gleitkommazahl.  @code{kron_delta} vereinfacht zu einer
Substantivform.

@example
(%i1) 1/4 - 0.25;
(%o1)                          0.0
(%i2) 1/10 - 0.1;
(%o2)                          0.0
(%i3) 0.25 - 0.25b0;
Warning:  Float to bigfloat conversion of 0.25
(%o3)                         0.0b0
(%i4) kron_delta (1/4, 0.25);
                                  1
(%o4)                  kron_delta(-, 0.25)
                                  4
(%i5) kron_delta (1/10, 0.1);
                                  1
(%o5)                  kron_delta(--, 0.1)
                                  10
(%i6) kron_delta (0.25, 0.25b0);
Warning:  Float to bigfloat conversion of 0.25
(%o6)               kron_delta(0.25, 2.5b-1)
@end example

@c @code{kron_delta} is symmetric.

@code{kron_delta} ist symmetrisch.

@example
(%i1) kron_delta (x, y);
(%o1)                   kron_delta(x, y)
(%i2) kron_delta (y, x);
(%o2)                   kron_delta(x, y)
(%i3) kron_delta (x, y) - kron_delta (y, x);
(%o3)                           0
(%i4) is (equal (kron_delta (x, y), kron_delta (y, x)));
(%o4)                         true
(%i5) is (kron_delta (x, y) = kron_delta (y, x));
(%o5)                         true
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{listify}
@deffn {Funktion} listify (@var{a})

@c Returns a list containing the members of @var{a} when @var{a} is a set.
@c Otherwise, @code{listify} returns @var{a}.

Ist das Argument @var{a} eine Menge, werden die Elemente der Menge als eine
Liste zur@"uckgegeben.  Ansonsten wird @var{a} zur@"uckgegeben.

@c @code{full_listify} replaces all set operators in @var{a} by list operators.

Siehe die Funktion @mrefcomma{full_listify} um alle Mengen im Ausdruck @var{a}
durch Listen zu ersetzen.

Beispiele:

@example
(%i1) listify (@{a, b, c, d@});
(%o1)                     [a, b, c, d]
(%i2) listify (F (@{a, b, c, d@}));
(%o2)                    F(@{a, b, c, d@})
@end example
@end deffn

@c --- 24.04.2011 DK -----------------------------------------------------------
@anchor{lreduce}
@deffn  {Funktion} lreduce (@var{F}, @var{s})
@deffnx {Funktion} lreduce (@var{F}, @var{s}, @var{s_0})

Extends the binary function @var{F} to an n-ary function by composition,
where @var{s} is a list.

@code{lreduce(@var{F}, @var{s})} returns
@code{F(... F(F(s_1, s_2), s_3), ... s_n)}.  When the optional argument
@var{s_0} is present, the result is equivalent to
@code{lreduce(@var{F}, cons(@var{s_0}, @var{s}))}.

The function @var{F} is first applied to the @i{leftmost} list elements, thus
the name "lreduce".

See also @code{rreduce}, @code{xreduce}, and @code{tree_reduce}.

Beispiele:

@code{lreduce} without the optional argument.

@example
(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
@end example

@code{lreduce} with the optional argument.

@example
(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
@end example

@code{lreduce} applied to built-in binary operators.
@code{/} is the division operator.

@example
(%i1) lreduce ("^", args (@{a, b, c, d@}));
                               b c d
(%o1)                       ((a ) )
(%i2) lreduce ("/", args (@{a, b, c, d@}));
                                a
(%o2)                         -----
                              b c d
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{makeset}
@deffn {Function} makeset (@var{expr}, @var{x}, @var{s})

Returns a set with members generated from the expression @var{expr}, where
@var{x} is a list of variables in @var{expr}, and @var{s} is a set or list of
lists.  To generate each set member, @var{expr} is evaluated with the variables
@var{x} bound in parallel to a member of @var{s}.

Each member of @var{s} must have the same length as @var{x}.
The list of variables @var{x} must be a list of symbols, without subscripts.
Even if there is only one symbol, @var{x} must be a list of one element,
and each member of @var{s} must be a list of one element.

@c FOLLOWING EQUIVALENT EXPRESSION IS REALLY TOO COMPLICATED, JUST SKIP IT FOR NOW
@c @code{makeset(@var{expr}, @var{x}, @var{s})} returns the same result as
@c @code{setify(map(lambda([L], sublis(map("=", ''@var{x}, L), ''@var{expr})), args(@var{s})))}.

See also @code{makelist}.

Examples:

@c ===beg===
@c makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
@c S : {x, y, z}$
@c S3 : cartesian_product (S, S, S);
@c makeset (i + j + k, [i, j, k], S3);
@c makeset (sin(x), [x], {[1], [2], [3]});
@c ===end===
@example
(%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                           1  2  3  4
(%o1)                     @{-, -, -, -@}
                           a  b  c  d
(%i2) S : @{x, y, z@}$
(%i3) S3 : cartesian_product (S, S, S);
(%o3) @{[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y], 
[x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x], 
[y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z], 
[y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y], 
[z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x], 
[z, z, y], [z, z, z]@}
(%i4) makeset (i + j + k, [i, j, k], S3);
(%o4) @{3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x, 
                                       z + 2 y, 2 z + x, 2 z + y@}
(%i5) makeset (sin(x), [x], @{[1], [2], [3]@});
(%o5)               @{sin(1), sin(2), sin(3)@}
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{moebius}
@deffn {Function} moebius (@var{n})

Represents the Moebius function.

When @var{n} is product of @math{k} distinct primes,
@code{moebius(@var{n})} simplifies to @math{(-1)^k};
when @math{@var{n} = 1}, it simplifies to 1;
and it simplifies to 0 for all other positive integers. 

@code{moebius} distributes over equations, lists, matrices, and sets.

Examples:

@c ===beg===
@c moebius (1);
@c moebius (2 * 3 * 5);
@c moebius (11 * 17 * 29 * 31);
@c moebius (2^32);
@c moebius (n);
@c moebius (n = 12);
@c moebius ([11, 11 * 13, 11 * 13 * 15]);
@c moebius (matrix ([11, 12], [13, 14]));
@c moebius ({21, 22, 23, 24});
@c ===end===
@example
(%i1) moebius (1);
(%o1)                           1
(%i2) moebius (2 * 3 * 5);
(%o2)                          - 1
(%i3) moebius (11 * 17 * 29 * 31);
(%o3)                           1
(%i4) moebius (2^32);
(%o4)                           0
(%i5) moebius (n);
(%o5)                      moebius(n)
(%i6) moebius (n = 12);
(%o6)                    moebius(n) = 0
(%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
(%o7)                      [- 1, 1, 1]
(%i8) moebius (matrix ([11, 12], [13, 14]));
                           [ - 1  0 ]
(%o8)                      [        ]
                           [ - 1  1 ]
(%i9) moebius (@{21, 22, 23, 24@});
(%o9)                      @{- 1, 0, 1@}
@end example
@end deffn
 
@c -----------------------------------------------------------------------------
@anchor{multinomial_coeff}
@deffn  {Function} multinomial_coeff (@var{a_1}, ..., @var{a_n})
@deffnx {Function} multinomial_coeff ()

Returns the multinomial coefficient.

When each @var{a_k} is a nonnegative integer, the multinomial coefficient
gives the number of ways of placing @code{@var{a_1} + ... + @var{a_n}} 
distinct objects into @math{n} boxes with @var{a_k} elements in the 
@math{k}'th box. In general, @code{multinomial_coeff (@var{a_1}, ..., @var{a_n})}
evaluates to @code{(@var{a_1} + ... + @var{a_n})!/(@var{a_1}! ... @var{a_n}!)}.

@code{multinomial_coeff()} (with no arguments) evaluates to 1.

@code{minfactorial} may be able to simplify the value returned by
@code{multinomial_coeff}.

Examples:

@c ===beg===
@c multinomial_coeff (1, 2, x);
@c minfactorial (%);
@c multinomial_coeff (-6, 2);
@c minfactorial (%);
@c ===end===
@example
(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{num_distinct_partitions}
@deffn  {Function} num_distinct_partitions (@var{n})
@deffnx {Function} num_distinct_partitions (@var{n}, list)

Returns the number of distinct integer partitions of @var{n}
when @var{n} is a nonnegative integer.
Otherwise, @code{num_distinct_partitions} returns a noun expression.

@code{num_distinct_partitions(@var{n}, list)} returns a 
list of the number of distinct partitions of 1, 2, 3, ..., @var{n}. 

A distinct partition of @var{n} is
a list of distinct positive integers @math{k_1}, ..., @math{k_m}
such that @math{@var{n} = k_1 + ... + k_m}.

Examples:

@c ===beg===
@c num_distinct_partitions (12);
@c num_distinct_partitions (12, list);
@c num_distinct_partitions (n);
@c ===end===
@example
(%i1) num_distinct_partitions (12);
(%o1)                          15
(%i2) num_distinct_partitions (12, list);
(%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
(%i3) num_distinct_partitions (n);
(%o3)              num_distinct_partitions(n)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{num_partitions}
@deffn {Function} num_partitions (@var{n})
@deffnx {Function} num_partitions (@var{n}, list)

Returns the number of integer partitions of @var{n}
when @var{n} is a nonnegative integer.
Otherwise, @code{num_partitions} returns a noun expression.

@code{num_partitions(@var{n}, list)} returns a
list of the number of integer partitions of 1, 2, 3, ..., @var{n}.

For a nonnegative integer @var{n}, @code{num_partitions(@var{n})} is equal to
@code{cardinality(integer_partitions(@var{n}))}; however, @code{num_partitions} 
does not actually construct the set of partitions, so it is much faster.

Examples:

@c ===beg===
@c num_partitions (5) = cardinality (integer_partitions (5));
@c num_partitions (8, list);
@c num_partitions (n);
@c ===end===
@example
(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{partition_set}
@deffn {Function} partition_set (@var{a}, @var{f})

Partitions the set @var{a} according to the predicate @var{f}.

@code{partition_set} returns a list of two sets.  The first set comprises the
elements of @var{a} for which @var{f} evaluates to @code{false}, and the second
comprises any other elements of @var{a}.  @code{partition_set} does not apply
@code{is} to the return value of @var{f}.

@code{partition_set} complains if @var{a} is not a literal set.

See also @code{subset}.

Examples:

@c ===beg===
@c partition_set ({2, 7, 1, 8, 2, 8}, evenp);
@c partition_set ({x, rat(y), rat(y) + z, 1}, 
@c                      lambda ([x], ratp(x)));
@c ===end===
@example
(%i1) partition_set (@{2, 7, 1, 8, 2, 8@}, evenp);
(%o1)                   [@{1, 7@}, @{2, 8@}]
(%i2) partition_set (@{x, rat(y), rat(y) + z, 1@},
                     lambda ([x], ratp(x)));
(%o2)/R/              [@{1, x@}, @{y, y + z@}]
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{permutations}
@deffn {Function} permutations (@var{a})

Returns a set of all distinct permutations of the members of 
the list or set @var{a}.  Each permutation is a list, not a set.

When @var{a} is a list, duplicate members of @var{a} are included
in the permutations.

@code{permutations} complains if @var{a} is not a literal list or set.

See also @code{random_permutation}.

Examples:

@c ===beg===
@c permutations ([a, a]);
@c permutations ([a, a, b]);
@c ===end===
@example
(%i1) permutations ([a, a]);
(%o1)                       @{[a, a]@}
(%i2) permutations ([a, a, b]);
(%o2)           @{[a, a, b], [a, b, a], [b, a, a]@}
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{powerset}
@deffn  {Function} powerset (@var{a})
@deffnx {Function} powerset (@var{a}, @var{n})

Returns the set of all subsets of @var{a}, or a subset of that set.

@code{powerset(@var{a})} returns the set of all subsets of the set @var{a}.
@code{powerset(@var{a})} has @code{2^cardinality(@var{a})} members.

@code{powerset(@var{a}, @var{n})} returns the set of all subsets of @var{a}
that have cardinality @var{n}.

@code{powerset} complains if @var{a} is not a literal set,
or if @var{n} is not a nonnegative integer.

Examples:

@c ===beg===
@c powerset ({a, b, c});
@c powerset ({w, x, y, z}, 4);
@c powerset ({w, x, y, z}, 3);
@c powerset ({w, x, y, z}, 2);
@c powerset ({w, x, y, z}, 1);
@c powerset ({w, x, y, z}, 0);
@c ===end===
@example
(%i1) powerset (@{a, b, c@});
(%o1) @{@{@}, @{a@}, @{a, b@}, @{a, b, c@}, @{a, c@}, @{b@}, @{b, c@}, @{c@}@}
(%i2) powerset (@{w, x, y, z@}, 4);
(%o2)                    @{@{w, x, y, z@}@}
(%i3) powerset (@{w, x, y, z@}, 3);
(%o3)     @{@{w, x, y@}, @{w, x, z@}, @{w, y, z@}, @{x, y, z@}@}
(%i4) powerset (@{w, x, y, z@}, 2);
(%o4)   @{@{w, x@}, @{w, y@}, @{w, z@}, @{x, y@}, @{x, z@}, @{y, z@}@}
(%i5) powerset (@{w, x, y, z@}, 1);
(%o5)                 @{@{w@}, @{x@}, @{y@}, @{z@}@}
(%i6) powerset (@{w, x, y, z@}, 0);
(%o6)                         @{@{@}@}
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{random_permutation}
@deffn {Function} random_permutation (@var{a})

Returns a random permutation of the set or list @var{a},
as constructed by the Knuth shuffle algorithm.

The return value is a new list, which is distinct
from the argument even if all elements happen to be the same.
However, the elements of the argument are not copied.

Examples:

@c ===beg===
@c random_permutation ([a, b, c, 1, 2, 3]);
@c random_permutation ([a, b, c, 1, 2, 3]);
@c random_permutation ({x + 1, y + 2, z + 3});
@c random_permutation ({x + 1, y + 2, z + 3});
@c ===end===
@example
(%i1) random_permutation ([a, b, c, 1, 2, 3]);
(%o1)                  [c, 1, 2, 3, a, b]
(%i2) random_permutation ([a, b, c, 1, 2, 3]);
(%o2)                  [b, 3, 1, c, a, 2]
(%i3) random_permutation (@{x + 1, y + 2, z + 3@});
(%o3)                 [y + 2, z + 3, x + 1]
(%i4) random_permutation (@{x + 1, y + 2, z + 3@});
(%o4)                 [x + 1, y + 2, z + 3]
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{rreduce}
@deffn  {Function} rreduce (@var{F}, @var{s})
@deffnx {Function} rreduce (@var{F}, @var{s}, @var{s_@{n + 1@}})

Extends the binary function @var{F} to an n-ary function by composition,
where @var{s} is a list.

@code{rreduce(@var{F}, @var{s})} returns @code{F(s_1, ... F(s_@{n - 2@}, F(s_@{n - 1@}, s_n)))}.
When the optional argument @var{s_@{n + 1@}} is present,
the result is equivalent to @code{rreduce(@var{F}, endcons(@var{s_@{n + 1@}}, @var{s}))}.

The function @var{F} is first applied to the
@i{rightmost} list elements, thus the name "rreduce". 

See also @code{lreduce}, @code{tree_reduce}, and @code{xreduce}.

Examples:

@code{rreduce} without the optional argument.

@c ===beg===
@c rreduce (f, [1, 2, 3]);
@c rreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
@end example

@code{rreduce} with the optional argument.

@c ===beg===
@c rreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
@end example

@code{rreduce} applied to built-in binary operators.
@code{/} is the division operator.

@c ===beg===
@c rreduce ("^", args ({a, b, c, d}));
@c rreduce ("/", args ({a, b, c, d}));
@c ===end===
@example
(%i1) rreduce ("^", args (@{a, b, c, d@}));
                                 d
                                c
                               b
(%o1)                         a
(%i2) rreduce ("/", args (@{a, b, c, d@}));
                               a c
(%o2)                          ---
                               b d
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{setdifference}
@deffn {Function}  setdifference (@var{a}, @var{b})

Returns a set containing the elements in the set @var{a} that are
not in the set @var{b}.

@code{setdifference} complains if either @var{a} or @var{b} is not a literal set.

Examples:

@c ===beg===
@c S_1 : {a, b, c, x, y, z};
@c S_2 : {aa, bb, c, x, y, zz};
@c setdifference (S_1, S_2);
@c setdifference (S_2, S_1);
@c setdifference (S_1, S_1);
@c setdifference (S_1, {});
@c setdifference ({}, S_1);
@c ===end===
@example
(%i1) S_1 : @{a, b, c, x, y, z@};
(%o1)                  @{a, b, c, x, y, z@}
(%i2) S_2 : @{aa, bb, c, x, y, zz@};
(%o2)                 @{aa, bb, c, x, y, zz@}
(%i3) setdifference (S_1, S_2);
(%o3)                       @{a, b, z@}
(%i4) setdifference (S_2, S_1);
(%o4)                     @{aa, bb, zz@}
(%i5) setdifference (S_1, S_1);
(%o5)                          @{@}
(%i6) setdifference (S_1, @{@});
(%o6)                  @{a, b, c, x, y, z@}
(%i7) setdifference (@{@}, S_1);
(%o7)                          @{@}
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{setequalp}
@deffn {Function} setequalp (@var{a}, @var{b})

Returns @code{true} if sets @var{a} and @var{b} have the same number of elements
@c $SETEQUALP CALLS THE LISP FUNCTION LIKE,
@c AND SO DOES THE CODE TO EVALUATE IS (X = Y).
and @code{is(@var{x} = @var{y})} is @code{true}
for @code{x} in the elements of @var{a}
and @code{y} in the elements of @var{b},
considered in the order determined by @code{listify}.
Otherwise, @code{setequalp} returns @code{false}.

Examples:

@c ===beg===
@c setequalp ({1, 2, 3}, {1, 2, 3});
@c setequalp ({a, b, c}, {1, 2, 3});
@c setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
@c ===end===
@example
(%i1) setequalp (@{1, 2, 3@}, @{1, 2, 3@});
(%o1)                         true
(%i2) setequalp (@{a, b, c@}, @{1, 2, 3@});
(%o2)                         false
(%i3) setequalp (@{x^2 - y^2@}, @{(x + y) * (x - y)@});
(%o3)                         false
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{setify}
@deffn {Function} setify (@var{a})

Constructs a set from the elements of the list @var{a}.  Duplicate
elements of the list @var{a} are deleted and the elements
are sorted according to the predicate @code{orderlessp}.

@code{setify} complains if @var{a} is not a literal list.

Examples:

@c ===beg===
@c setify ([1, 2, 3, a, b, c]);
@c setify ([a, b, c, a, b, c]);
@c setify ([7, 13, 11, 1, 3, 9, 5]);
@c ===end===
@example
(%i1) setify ([1, 2, 3, a, b, c]);
(%o1)                  @{1, 2, 3, a, b, c@}
(%i2) setify ([a, b, c, a, b, c]);
(%o2)                       @{a, b, c@}
(%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
(%o3)                @{1, 3, 5, 7, 9, 11, 13@}
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{setp}
@deffn {Function} setp (@var{a})

Returns @code{true} if and only if @var{a} is a Maxima set.

@code{setp} returns @code{true} for unsimplified sets (that is, sets with
redundant members) as well as simplified sets.

@c NOT SURE WE NEED TO MENTION THIS.  OK FOR NOW
@code{setp} is equivalent to the Maxima function
@code{setp(a) := not atom(a) and op(a) = 'set}.

Examples:

@c ===beg===
@c simp : false;
@c {a, a, a};
@c setp (%);
@c ===end===
@example
(%i1) simp : false;
(%o1)                         false
(%i2) @{a, a, a@};
(%o2)                       @{a, a, a@}
(%i3) setp (%);
(%o3)                         true
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{set_partitions}
@deffn  {Function} set_partitions (@var{a})
@deffnx {Function} set_partitions (@var{a}, @var{n})

Returns the set of all partitions of @var{a}, or a subset of that set.

@code{set_partitions(@var{a}, @var{n})} returns a set of all
decompositions of @var{a} into @var{n} nonempty disjoint subsets.

@code{set_partitions(@var{a})} returns the set of all partitions.

@code{stirling2} returns the cardinality of the set of partitions of a set.

A set of sets @math{P} is a partition of a set @math{S} when

@enumerate
@item
each member of @math{P} is a nonempty set,
@item
distinct members of @math{P} are disjoint,
@item
the union of the members of @math{P} equals @math{S}.
@end enumerate

Examples:

The empty set is a partition of itself, the conditions 1 and 2 being vacuously
true.

@c ===beg===
@c set_partitions ({});
@c ===end===
@example
(%i1) set_partitions (@{@});
(%o1)                         @{@{@}@}
@end example

The cardinality of the set of partitions of a set can be found using
@code{stirling2}.

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c cardinality(p) = stirling2 (6, 3);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) cardinality(p) = stirling2 (6, 3);
(%o3)                        90 = 90
@end example

Each member of @code{p} should have @var{n} = 3 members; let's check.

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c map (cardinality, p);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (cardinality, p);
(%o3)                          @{3@}
@end example

Finally, for each member of @code{p}, the union of its members should 
equal @code{s}; again let's check.

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c map (lambda ([x], apply (union, listify (x))), p);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (lambda ([x], apply (union, listify (x))), p);
(%o3)                 @{@{0, 1, 2, 3, 4, 5@}@}
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{some}
@deffn  {Function} some (@var{f}, @var{a})
@deffnx {Function} some (@var{f}, @var{L_1}, ..., @var{L_n})

Returns @code{true} if the predicate @var{f} is @code{true} for one or more
given arguments.

Given one set as the second argument, 
@code{some(@var{f}, @var{s})} returns @code{true}
if @code{is(@var{f}(@var{a_i}))} returns @code{true} for one or more @var{a_i}
in @var{s}.
@code{some} may or may not evaluate @var{f} for all @var{a_i} in @var{s}.
Since sets are unordered,
@code{some} may evaluate @code{@var{f}(@var{a_i})} in any order.

Given one or more lists as arguments,
@code{some(@var{f}, @var{L_1}, ..., @var{L_n})} returns @code{true}
if @code{is(@var{f}(@var{x_1}, ..., @var{x_n}))} returns @code{true} 
for one or more @var{x_1}, ..., @var{x_n} in @var{L_1}, ..., @var{L_n},
respectively.
@code{some} may or may not evaluate 
@var{f} for some combinations @var{x_1}, ..., @var{x_n}.
@code{some} evaluates lists in the order of increasing index.

Given an empty set @code{@{@}} or empty lists @code{[]} as arguments,
@code{some} returns @code{false}.

When the global flag @code{maperror} is @code{true}, all lists 
@var{L_1}, ..., @var{L_n} must have equal lengths.
When @code{maperror} is @code{false}, list arguments are
effectively truncated to the length of the shortest list.

Return values of the predicate @var{f} which evaluate (via @code{is})
to something other than @code{true} or @code{false}
are governed by the global flag @code{prederror}.
When @code{prederror} is @code{true},
such values are treated as @code{false}.
When @code{prederror} is @code{false},
such values are treated as @code{unknown}.

Examples:

@code{some} applied to a single set.
The predicate is a function of one argument.

@c ===beg===
@c some (integerp, {1, 2, 3, 4, 5, 6});
@c some (atom, {1, 2, sin(3), 4, 5 + y, 6});
@c ===end===
@example
(%i1) some (integerp, @{1, 2, 3, 4, 5, 6@});
(%o1)                         true
(%i2) some (atom, @{1, 2, sin(3), 4, 5 + y, 6@});
(%o2)                         true
@end example

@code{some} applied to two lists.
The predicate is a function of two arguments.

@c ===beg===
@c some ("=", [a, b, c], [a, b, c]);
@c some ("#", [a, b, c], [a, b, c]);
@c ===end===
@example
(%i1) some ("=", [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) some ("#", [a, b, c], [a, b, c]);
(%o2)                         false
@end example

Return values of the predicate @var{f} which evaluate
to something other than @code{true} or @code{false}
are governed by the global flag @code{prederror}.

@c ===beg===
@c prederror : false;
@c map (lambda ([a, b], is (a < b)), [x, y, z], 
@c            [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z + 1]);
@c prederror : true;
@c some ("<", [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z + 1]);
@c ===end===
@example
(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
           [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
(%o4)                         true
(%i5) prederror : true;
(%o5)                         true
(%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
(%o6)                         false
(%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
(%o7)                         true
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{stirling1}
@deffn {Function} stirling1 (@var{n}, @var{m})

Represents the Stirling number of the first kind.

When @var{n} and @var{m} are nonnegative 
integers, the magnitude of @code{stirling1 (@var{n}, @var{m})} is the number 
of permutations of a set with @var{n} members that have @var{m} cycles.
For details, see Graham, Knuth and Patashnik @i{Concrete Mathematics}.
Maxima uses a recursion relation to define @code{stirling1 (@var{n}, @var{m})}
for @var{m} less than 0; it is undefined for @var{n} less than 0 and for 
non-integer arguments.

@code{stirling1} is a simplifying function.
Maxima knows the following identities.

@c COPIED VERBATIM FROM SRC/NSET.LISP
@enumerate
@item
@math{stirling1(0, n) = kron_delta(0, n)} (Ref. [1])
@item
@math{stirling1(n, n) = 1} (Ref. [1])
@item
@math{stirling1(n, n - 1) = binomial(n, 2)} (Ref. [1])
@item
@math{stirling1(n + 1, 0) = 0} (Ref. [1])
@item
@math{stirling1(n + 1, 1) = n!} (Ref. [1])
@item
@math{stirling1(n + 1, 2) = 2^n  - 1} (Ref. [1])
@end enumerate

These identities are applied when the arguments are literal integers
or symbols declared as integers, and the first argument is nonnegative.
@code{stirling1} does not simplify for non-integer arguments.

References:

[1] Donald Knuth, @i{The Art of Computer Programming,}
third edition, Volume 1, Section 1.2.6, Equations 48, 49, and 50.

Examples:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
@end example

@code{stirling1} does not simplify for non-integer arguments.

@c ===beg===
@c stirling1 (sqrt(2), sqrt(2));
@c ===end===
@example
(%i1) stirling1 (sqrt(2), sqrt(2));
(%o1)              stirling1(sqrt(2), sqrt(2))
@end example

Maxima applies identities to @code{stirling1}.

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n + 1, n);
@c stirling1 (n + 1, 1);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n + 1, n);
                            n (n + 1)
(%o3)                       ---------
                                2
(%i4) stirling1 (n + 1, 1);
(%o4)                          n!
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{stirling2}
@deffn {Function} stirling2 (@var{n}, @var{m})

Represents the Stirling number of the second kind.

When @var{n} and @var{m} are nonnegative integers, @code{stirling2 (@var{n}, 
@var{m})} is the number of ways a set with cardinality @var{n} can be 
partitioned into @var{m} disjoint subsets.  Maxima uses a recursion relation 
to define @code{stirling2 (@var{n}, @var{m})} for @var{m} less than 0; it is 
undefined for @var{n} less than 0 and for non-integer arguments.

@code{stirling2} is a simplifying function.
Maxima knows the following identities.

@c COPIED VERBATIM FROM SRC/NSET.LISP
@enumerate
@item
@math{stirling2(0, n) = kron_delta(0, n)} (Ref. [1])
@item
@math{stirling2(n, n) = 1} (Ref. [1])
@item
@math{stirling2(n, n - 1) = binomial(n, 2)} (Ref. [1])
@item
@math{stirling2(n + 1, 1) = 1} (Ref. [1])
@item
@math{stirling2(n + 1, 2) = 2^n  - 1} (Ref. [1])
@item
@math{stirling2(n, 0) = kron_delta(n, 0)} (Ref. [2])
@item
@math{stirling2(n, m) = 0} when @math{m > n} (Ref. [2])
@item
@math{stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) / m!}
when @math{m} and @math{n} are integers, and @math{n} is nonnegative. (Ref. [3])
@end enumerate

These identities are applied when the arguments are literal integers
or symbols declared as integers, and the first argument is nonnegative.
@code{stirling2} does not simplify for non-integer arguments.

References:

[1] Donald Knuth. @i{The Art of Computer Programming},
third edition, Volume 1, Section 1.2.6, Equations 48, 49, and 50.

[2] Graham, Knuth, and Patashnik. @i{Concrete Mathematics}, Table 264.

[3] Abramowitz and Stegun. @i{Handbook of Mathematical Functions}, Section 24.1.4.

Examples:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
@end example

@code{stirling2} does not simplify for non-integer arguments.

@c ===beg===
@c stirling2 (%pi, %pi);
@c ===end===
@example
(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
@end example

Maxima applies identities to @code{stirling2}.

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n + 9, n + 8);
@c stirling2 (n + 1, 2);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n + 9, n + 8);
                         (n + 8) (n + 9)
(%o3)                    ---------------
                                2
(%i4) stirling2 (n + 1, 2);
                              n
(%o4)                        2  - 1
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{subset}
@deffn {Function} subset (@var{a}, @var{f})

Returns the subset of the set @var{a} that satisfies the predicate @var{f}.

@code{subset} returns a set which comprises the elements of @var{a}
for which @var{f} returns anything other than @code{false}.
@code{subset} does not apply @code{is} to the return value of @var{f}.

@code{subset} complains if @var{a} is not a literal set.

See also @code{partition_set}.

Examples:

@c ===beg===
@c subset ({1, 2, x, x + y, z, x + y + z}, atom);
@c subset ({1, 2, 7, 8, 9, 14}, evenp);
@c ===end===
@example
(%i1) subset (@{1, 2, x, x + y, z, x + y + z@}, atom);
(%o1)                     @{1, 2, x, z@}
(%i2) subset (@{1, 2, 7, 8, 9, 14@}, evenp);
(%o2)                      @{2, 8, 14@}
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{subsetp}
@deffn {Function} subsetp (@var{a}, @var{b})

Returns @code{true} if and only if the set @var{a} is a subset of @var{b}.

@code{subsetp} complains if either @var{a} or @var{b} is not a literal set.

Examples:

@c ===beg===
@c subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
@c subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
@c ===end===
@example
(%i1) subsetp (@{1, 2, 3@}, @{a, 1, b, 2, c, 3@});
(%o1)                         true
(%i2) subsetp (@{a, 1, b, 2, c, 3@}, @{1, 2, 3@});
(%o2)                         false
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{symmdifference}
@deffn {Function} symmdifference (@var{a_1}, ..., @var{a_n})

Returns the symmetric difference of sets @code{ @var{a_1}, ..., @var{a_n}}.
Given two arguments, @code{symmdifference (@var{a}, @var{b})} is the same as:

@example
union (setdifference (@var{a}, @var{b}), setdifference (@var{b}, @var{a})).
@end example

@code{symmdifference} complains if any argument is not a literal set.

Examples:

@c ===beg===
@c S_1 : {a, b, c};
@c S_2 : {1, b, c};
@c S_3 : {a, b, z};
@c symmdifference ();
@c symmdifference (S_1);
@c symmdifference (S_1, S_2);
@c symmdifference (S_1, S_2, S_3);
@c symmdifference ({}, S_1, S_2, S_3);
@c ===end===
@example
(%i1) S_1 : @{a, b, c@};
(%o1)                       @{a, b, c@}
(%i2) S_2 : @{1, b, c@};
(%o2)                       @{1, b, c@}
(%i3) S_3 : @{a, b, z@};
(%o3)                       @{a, b, z@}
(%i4) symmdifference ();
(%o4)                          @{@}
(%i5) symmdifference (S_1);
(%o5)                       @{a, b, c@}
(%i6) symmdifference (S_1, S_2);
(%o6)                        @{1, a@}
(%i7) symmdifference (S_1, S_2, S_3);
(%o7)                        @{1, b, z@}
(%i8) symmdifference (@{@}, S_1, S_2, S_3);
(%o8)                        @{1,b, z@}
@end example
@end deffn

@c TREE_REDUCE ACCEPTS A SET OR LIST AS AN ARGUMENT, BUT RREDUCE AND LREDUCE 
@c WANT ONLY LISTS; STRANGE

@c -----------------------------------------------------------------------------
@anchor{tree_reduce}
@deffn  {Function} tree_reduce (@var{F}, @var{s})
@deffnx {Function} tree_reduce (@var{F}, @var{s}, @var{s_0})

Extends the binary function @var{F} to an n-ary function by composition,
where @var{s} is a set or list.

@code{tree_reduce} is equivalent to the following:
Apply @var{F} to successive pairs of elements
to form a new list @code{[@var{F}(@var{s_1}, @var{s_2}), @var{F}(@var{s_3}, @var{s_4}), ...]},
carrying the final element unchanged if there are an odd number of elements.
Then repeat until the list is reduced to a single element, which is the return value.

When the optional argument @var{s_0} is present,
the result is equivalent @code{tree_reduce(@var{F}, cons(@var{s_0}, @var{s})}.

For addition of floating point numbers,
@code{tree_reduce} may return a sum that has a smaller rounding error
than either @code{rreduce} or @code{lreduce}.

The elements of @var{s} and the partial results may be arranged in a
minimum-depth binary tree, thus the name "tree_reduce".

Examples:

@code{tree_reduce} applied to a list with an even number of elements.

@c ===beg===
@c tree_reduce (f, [a, b, c, d]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
@end example

@code{tree_reduce} applied to a list with an odd number of elements.

@c ===beg===
@c tree_reduce (f, [a, b, c, d, e]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
@end example
@end deffn

@c -----------------------------------------------------------------------------
@anchor{union}
@deffn {Function} union (@var{a_1}, ..., @var{a_n})

Returns the union of the sets @var{a_1} through @var{a_n}.

@code{union()} (with no arguments) returns the empty set.

@code{union} complains if any argument is not a literal set.

Examples:

@c ===beg===
@c S_1 : {a, b, c + d, %e};
@c S_2 : {%pi, %i, %e, c + d};
@c S_3 : {17, 29, 1729, %pi, %i};
@c union ();
@c union (S_1);
@c union (S_1, S_2);
@c union (S_1, S_2, S_3);
@c union ({}, S_1, S_2, S_3);
@c ===end===
@example
(%i1) S_1 : @{a, b, c + d, %e@};
(%o1)                   @{%e, a, b, d + c@}
(%i2) S_2 : @{%pi, %i, %e, c + d@};
(%o2)                 @{%e, %i, %pi, d + c@}
(%i3) S_3 : @{17, 29, 1729, %pi, %i@};
(%o3)                @{17, 29, 1729, %i, %pi@}
(%i4) union ();
(%o4)                          @{@}
(%i5) union (S_1);
(%o5)                   @{%e, a, b, d + c@}
(%i6) union (S_1, S_2);
(%o6)              @{%e, %i, %pi, a, b, d + c@}
(%i7) union (S_1, S_2, S_3);
(%o7)       @{17, 29, 1729, %e, %i, %pi, a, b, d + c@}
(%i8) union (@{@}, S_1, S_2, S_3);
(%o8)       @{17, 29, 1729, %e, %i, %pi, a, b, d + c@}
@end example
@end deffn

@c XREDUCE ACCEPTS A SET OR LIST AS AN ARGUMENT, BUT RREDUCE AND LREDUCE WANT ONLY LISTS; STRANGE

@c -----------------------------------------------------------------------------
@anchor{xreduce}
@deffn  {Function} xreduce (@var{F}, @var{s})
@deffnx {Function} xreduce (@var{F}, @var{s}, @var{s_0})

Extends the function @var{F} to an n-ary function by composition,
or, if @var{F} is already n-ary, applies @var{F} to @var{s}.
When @var{F} is not n-ary, @code{xreduce} is the same as @code{lreduce}.
The argument @var{s} is a list.

Functions known to be n-ary include
addition @code{+}, multiplication @code{*}, @code{and}, @code{or}, @code{max},
@code{min}, and @code{append}.
Functions may also be declared n-ary by @code{declare(@var{F}, nary)}.
For these functions,
@code{xreduce} is expected to be faster than either @code{rreduce} or @code{lreduce}.

When the optional argument @var{s_0} is present,
the result is equivalent to @code{xreduce(@var{s}, cons(@var{s_0}, @var{s}))}.

@c NOT SURE WHAT IS THE RELEVANCE OF THE FOLLOWING COMMENT
@c MAXIMA IS NEVER SO CAREFUL ABOUT FLOATING POINT ASSOCIATIVITY SO FAR AS I KNOW
Floating point addition is not exactly associative; be that as it may,
@code{xreduce} applies Maxima's n-ary addition when @var{s} contains floating point numbers.

Examples:

@code{xreduce} applied to a function known to be n-ary.
@code{F} is called once, with all arguments.

@c ===beg===
@c declare (F, nary);
@c F ([L]) := L;
@c xreduce (F, [a, b, c, d, e]);
@c ===end===
@example
(%i1) declare (F, nary);
(%o1)                         done
(%i2) F ([L]) := L;
(%o2)                      F([L]) := L
(%i3) xreduce (F, [a, b, c, d, e]);
(%o3)         [[[[[("[", simp), a], b], c], d], e]
@end example

@code{xreduce} applied to a function not known to be n-ary.
@code{G} is called several times, with two arguments each time.

@c ===beg===
@c G ([L]) := L;
@c xreduce (G, [a, b, c, d, e]);
@c lreduce (G, [a, b, c, d, e]);
@c ===end===
@example
(%i1) G ([L]) := L;
(%o1)                      G([L]) := L
(%i2) xreduce (G, [a, b, c, d, e]);
(%o2)         [[[[[("[", simp), a], b], c], d], e]
(%i3) lreduce (G, [a, b, c, d, e]);
(%o3)                 [[[[a, b], c], d], e]
@end example
@end deffn

@c --- End of file Nset.de.texi ------------------------------------------------

