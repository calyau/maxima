@menu
* Introduction to Integration::
* Functions and Variables for Integration::
* Introduction to QUADPACK::
* Functions and Variables for QUADPACK::
@end menu

@c -----------------------------------------------------------------------------
@node Introduction to Integration, Functions and Variables for Integration, Integration, Integration
@section Introduction to Integration
@c -----------------------------------------------------------------------------

Maximaは、積分を扱うためのいくつかのルーチンを持っています。
@code{integrate}関数はそれらのほとんどを利用します。
指定されていない関数（ともちろんその導関数）を扱う@code{antid}パッケージもあります。
数値目的のためには、
@code{quad_qag}, @code{quad_qags}などと名付けられたQUADPACKから適応積分器一式があります。
それらは見出し@code{QUADPACK}の下で記述されています。
超幾何関数を扱うことができます。詳細は@code{specint}を参照してください。
一般的に言って、Maximaは
「初等関数」（有理関数、三角関数、対数、指数関数、根号など）と２、３の拡張（誤差関数、二重対数関数）を使った積分可能な積分だけを扱います。
@code{g(x)}や@code{h(x)}と言った未知の関数を使った積分を扱いません。

@c end concepts Integration

@c -----------------------------------------------------------------------------
@node Functions and Variables for Integration, Introduction to QUADPACK, Introduction to Integration, Integration
@section Functions and Variables for Integration
@c -----------------------------------------------------------------------------

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{changevar}
@deffn {関数} changevar (@var{expr}, @var{f(x,y)}, @var{y}, @var{x})

@var{x}に関する積分を含む@var{expr}の中に現れるすべての積分に関して、
@code{@var{f(x,y)} = 0}で与えられる変数変換を生成します。
新しい変数は@var{y}です。

@c HMM, THIS EXAMPLE YIELDS A CORRECT BUT SLIGHTLY STRANGE RESULT...
@example
(%i1) assume(a > 0)$
@group
(%i2) 'integrate (%e**sqrt(a*y), y, 0, 4);
                      4
                     /
                     [    sqrt(a) sqrt(y)
(%o2)                I  %e                dy
                     ]
                     /
                      0
@end group
@group
(%i3) changevar (%, y-z^2/a, z, y);
                      0
                     /
                     [                abs(z)
                   2 I            z %e       dz
                     ]
                     /
                      - 2 sqrt(a)
(%o3)            - ----------------------------
                                a
@end group
@end example

上の@code{'integrate}のインスタンスのように、名詞形を含む式は
@code{nouns}フラグありの@code{ev}によって評価されるかもしれません。
例えば、上の@code{changevar}が返す式は@code{ev (%o3, nouns)}で評価することができます。

@code{changevar}は、
和や積のインデックスに関する変更にも使えます。
しかしながら、
変更が和や積の中でなされる時、
この変更はシフトすなわち@code{i = j+ ...}
でなければならず、高階関数ではなことをはっきり理解しなければいけません。
例えば、

@example
@group
(%i4) sum (a[i]*x^(i-2), i, 0, inf);
                         inf
                         ====
                         \         i - 2
(%o4)                     >    a  x
                         /      i
                         ====
                         i = 0
@end group
@group
(%i5) changevar (%, i-2-n, n, i);
                        inf
                        ====
                        \               n
(%o5)                    >      a      x
                        /        n + 2
                        ====
                        n = - 2
@end group
@end example

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c THIS ITEM IS A MESS, BUT DON'T BOTHER TO CLEAN IT UP:
@c THE GAUSS-KRONROD FUNCTIONS (QUADPACK) MAKE THIS OBSOLETE

@c -----------------------------------------------------------------------------
@deffn {関数} dblint (@var{f}, @var{r}, @var{s}, @var{a}, @var{b})

トップレベルMaximaで書かれ、翻訳され機械語にコンパイルされた二重積分ルーチン。
このパッケージをアクセスするには@code{load (dblint)}を使ってください。
以下を計算するため、xとy方向に関して
シンプソンの規則方法を使います。

@tex
$$\int_a^b \int_{r\left(x\right)}^{s\left(x\right)} f\left(x,y\right) \, dy \, dx.$$
@end tex
@ifnottex
@example
@group
/b /s(x)
|  |
|  |    f(x,y) dy dx
|  |
/a /r(x)
@end group
@end example
@end ifnottex

関数@var{f}は、２つの変数の翻訳されコンパイルされた関数でなければいけなく、
@var{r}と@var{s}はそれぞれ、翻訳されコンパイルされた変数でなければいけません。
一方で、@var{a}と@var{b}は浮動小数点数でなければいけません。
ルーチンは、
xとyの区間の分割の数を決める２つのグローバル変数を持ちます:
@code{dblint_x}と@code{dblint_y},
両方とも初期は10で、他の整数値（x方向に計算される@code{2*dblint_x+1}点があり、
y方向に計算される@code{2*dblint_y+1}点があります）に独立に変えることができます。
ルーチンは、X軸を更に分割します。
Xのそれぞれの値に関して、最初、
@code{@var{r}(x)}と@code{@var{s}(x)}を計算します;
そして@code{@var{r}(x)}と@code{@var{s}(x)}の間でY軸が更に分割され、
シンプソン規則を使ってY軸に沿っての積分が実行されます;
そして、
シンプソン規則を使って
Y積分である関数値を用いてX軸に沿っての積分が実行されます;
この手続きは、様々な理由のため数値的に不安定かもしれませんが、
かなり速いです:
非常に振動的な関数や特異点（領域内の極や分岐点）を持つ関数にこれを使うことは避けてください。
Y積分は、@code{@var{r}(x)}と@code{@var{s}(x)}がどこくらい離れているかに依存します。
だから、もし距離@code{@var{s}(x) - @var{r}(x)}がXに関して急速に変化するなら、
様々なY積分での異なるステップサイズでの切り詰めから起こる本質的なエラーがあるかもしれません。
領域の範囲を改善するために、計算時間という犠牲を払って、@code{dblint_x}と@code{dblint_y}を増やすことができます。
関数値は保存されないので、もし関数が非常に時間がかかるものなら、
もし何か変えたら再計算を待たなければいけません（すいません）。
関数@var{f}, @var{r}, @var{s}は、 @code{dblint}コールの前に、翻訳されるかコンパイルされるかどちらかが要求されます。
これは、多くの場合、インタープリタコードに対して桁違いの速度改善がなされるでしょう！

@code{demo (dblint)}は、
例の問題に適用された@code{dblint}のデモンストレーションを実行します。
@c demo (dblint_1) FAILS WITH Could not find `fltdfnk.mc' -- DON'T BOTHER TO MENTION IT. !!!
@c @code{demo (dblint_1)} executes another demonstration.

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{defint}
@deffn {関数} defint (@var{expr}, @var{x}, @var{a}, @var{b})

定積分を計算しようとします。
@code{integrate}は、
積分の範囲が指定されている時、
すなわち、@code{integrate}が
@code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}としてコールされた時、
@code{defint}をコールします。

このように、ユーザーの観点からは、@code{integrate}をコールすることは十分です。
@c SHOULD WE BOTHER TO DOCUMENT defint ??? NO FUNCTIONALITY HERE THAT IS NOT ALREADY PRESENT IN integrate !!!

@code{defint}は、シンボリック式、計算された積分または積分の名詞形、
を返します。
定積分の数値近似に関しては、@code{quad_qag}と関連関数を参照してください。

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{erfflag}
@defvr {オプション変数} erfflag
デフォルト値: @code{true}

@code{erfflag}が@code{false}の時、
@code{risch}が
もしまず第一に被積分になにもないなら、
答えの中に@code{erf}関数を導入することを妨げます。

@opencatbox
@category{Integral calculus}
@closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{ilt}
@deffn {関数} ilt (@var{expr}, @var{s}, @var{t})

@var{expr}の@var{s}とパラメータ@var{t}に関する逆ラプラス変換を計算します。
@var{expr}は、
分子は線形２次因子だけを持つ多項式の比でなければいけません。
@code{solve}または@code{linsolve}と合わせて
関数@code{laplace}や@code{ilt}を使うことによって
ユーザーは１つの微分または畳み込み積分方程式やそれらの組を解くことができます。

@example
@group
(%i1) 'integrate (sinh(a*x)*f(t-x), x, 0, t) + b*f(t) = t**2;
              t
             /
             [                                    2
(%o1)        I  f(t - x) sinh(a x) dx + b f(t) = t
             ]
             /
              0
@end group
@group
(%i2) laplace (%, t, s);
                               a laplace(f(t), t, s)   2
(%o2)  b laplace(f(t), t, s) + --------------------- = --
                                       2    2           3
                                      s  - a           s
@end group
@group
(%i3) linsolve ([%], ['laplace(f(t), t, s)]);
                                        2      2
                                     2 s  - 2 a
(%o3)     [laplace(f(t), t, s) = --------------------]
                                    5         2     3
                                 b s  + (a - a  b) s
@end group
@group
(%i4) ilt (rhs (first (%)), s, t);
Is  a b (a b - 1)  positive, negative, or zero?

pos;
               sqrt(a b (a b - 1)) t
        2 cosh(---------------------)       2
                         b               a t
(%o4) - ----------------------------- + -------
              3  2      2               a b - 1
             a  b  - 2 a  b + a

                                                       2
                                             + ------------------
                                                3  2      2
                                               a  b  - 2 a  b + a
@end group
@end example

@opencatbox
@category{Laplace transform}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{intanalysis}
@defvr {オプション変数} intanalysis
デフォルト値: @code{true}

@code{true}の時、定積分は、積分区間内の被積分関数の極を見つけようとします。
もしあれば、積分は主値積分として適切に評価されます。
もしintanalysisが@code{false}なら、
このチェックは実行されず、積分は極がないことを仮定して実行されます。

@code{ldefint}も参照してください。

例:

@code{intanalysis}が@code{false}に設定されている時
Maximaは以下の積分を解くことができます:

@c ===beg===
@c integrate(1/(sqrt(x+1)+1),x,0,1);
@c integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
@c integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
@c intanalysis:false$
@c integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
@c ===end===
@example
(%i1) integrate(1/(sqrt(x)+1),x,0,1);
                                1
                               /
                               [       1
(%o1)                          I  ----------- dx
                               ]  sqrt(x) + 1
                               /
                                0

(%i2) integrate(1/(sqrt(x)+1),x,0,1),intanalysis:false;
(%o2)                            2 - 2 log(2)

(%i3) integrate(cos(a)/sqrt((tan(a))^2 +1),a,-%pi/2,%pi/2);
The number 1 isn't in the domain of atanh
 -- an error. To debug this try: debugmode(true);

(%i4) intanalysis:false$
(%i5) integrate(cos(a)/sqrt((tan(a))^2+1),a,-%pi/2,%pi/2);
                                      %pi
(%o5)                                 ---
                                       2
@end example

@opencatbox
@category{Integral calculus}
@closecatbox
@end defvr

@anchor{integrate}
@deffn  {関数} integrate (@var{expr}, @var{x})
@deffnx {関数} integrate (@var{expr}, @var{x}, @var{a}, @var{b})
@var{x}に関する@var{expr}の積分をシンボリックに計算しようとします。
@code{integrate (@var{expr}, @var{x})}は不定積分で、
@code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}は@var{a},@var{b}の上限下限を持つ定積分です。
@code{integrate}はこの制限を強制しませんが、上限下限は@var{x}を含んではいけません。
@var{a}は@var{b}より小さい必要はありません。
@var{b}が@var{a}と等しいなら、@code{integrate}は0を返します。

定積分の数値近似に関しては@code{quad_qag}と関連関数を参照してください。
（複素積分）留数の計算に関しては@code{residue}を参照してください。
不定積分の代替計算方法に関しては@code{antid}を参照してください。

@code{integrate}が成功すれば、積分（@code{integrate}を含まない式）を返します。
そうでなければ、積分の名詞形式（クォートされた演算子@code{'integrate})もしくは１つ以上の名詞形式を含む式を返します。
@code{integrate}の名詞形式は積分記号で表示されます。

いくつかの環境では、（例えば、@code{'integrate (@var{expr}, @var{x})}のように、
シングルクオートされた@code{integrate}で手動で名詞形式を構成することが役に立ちます。
例えば、積分が、また計算されていないいくつかのパラメータに依存しているかもしれません。
名詞は、@var{i}が注目の名詞形式であるところの@code{ev (@var{i}, nouns)}によって、引数に適用されるかもしれません。

@c BEGIN EXPOSITION ON HEURISTICS
@code{integrate}は不定積分とは別に、定積分を扱います。
それぞれの場合を扱うため、ある範囲の発見法を用意しています。
定積分の特別な場合は、0や無限大に等しい積分の下限上限を含んだり、
0や@code{%pi}や@code{2 %pi}に等しい下限上限を持つ三角関数を含んだり、
有理関数やベータやプサイ関数の定義に関連した積分やいくつかの対数的な積分、三角関数積分を含んだりします。
有理関数の処理は、留数の計算を含むかもしれません。
もし適用可能な特殊な場合が見つからなければ、不定積分を計算し、下限上限でそれを評価しようとするでしょう。
これは、下限上限に無限大の極限を取ることを含みます。@code{ldefint}も参照してください。

不定積分の特殊な場合は、三角関数、指数対数関数、有理関数を含みます。
@code{integrate}は初等積分の短いテーブルもまた利用しています。

もし非積分関数が形式@code{f(g(x)) * diff(g(x), x)}を持つなら、@code{integrate}は、変数の交換を実行します。
@code{integrate}は、@code{g(x)}の導関数が非積分関数を割るような部分式@code{g(x)}を見つけようとします。
この探索は、@code{gradef}関数によって定義された導関数を利用します。
@code{changevar}や@code{antid}も参照ください。

もしこれまでの発見法のどれも不定積分を見つけられなければ、リッシュのアルゴリズムが実行されます。
フラグ@code{risch}が、@code{ev}のコールやコマンドライン上で@code{evflag}として設定されるかもしれません。
例えば、@code{ev (integrate (@var{expr}, @var{x}), risch)}や
@code{integrate (@var{expr}, @var{x}), risch}というように。
もし@code{risch}が@code{true}なら、@code{integrate}は、発見法を最初に試さずに、@code{risch}関数をコールします。
@code{risch}も参照ください。
@c END EXPOSITION ON HEURISTICS

@code{integrate}は@code{f(x)}記法で陽に表現された関数関係のみに動作します。
@code{integrate}は@code{depends}関数で規定された陰の依存性を考慮しません。

@code{integrate}は非積分関数のパラメータのある性質を知っている必要がある場合があります。
@code{integrate}は@code{assume}データベースを最初に参照し、
注目の変数がそこになければ、@code{integrate}はユーザーに問い合わせます。
質問に依存して、適切な応答は、@code{yes;}や@code{no;}や@code{pos;}, @code{zero;}, @code{neg;}など。

@code{integrate}は線形には宣言されていません。@code{declare}と@code{linear}を参照ください。

@code{integrate}は２、３の特集な場合だけ、部分積分を企てます。

例:

@itemize @bullet
@item
初等不定積分、定積分

@example
@group
(%i1) integrate (sin(x)^3, x);
                           3
                        cos (x)
(%o1)                   ------- - cos(x)
                           3
@end group
@group
(%i2) integrate (x/ sqrt (b^2 - x^2), x);
                                 2    2
(%o2)                    - sqrt(b  - x )
@end group
@group
(%i3) integrate (cos(x)^2 * exp(x), x, 0, %pi);
                               %pi
                           3 %e      3
(%o3)                      ------- - -
                              5      5
@end group
@group
(%i4) integrate (x^2 * exp(-x^2), x, minf, inf);
                            sqrt(%pi)
(%o4)                       ---------
                                2
@end group
@end example

@item
@code{assume}と対話的問い合わせの利用

@example
(%i1) assume (a > 1)$
@group
(%i2) integrate (x**a/(x+1)**(5/2), x, 0, inf);
    2 a + 2
Is  -------  an integer?
       5

no;
Is  2 a - 3  positive, negative, or zero?

neg;
                                   3
(%o2)                  beta(a + 1, - - a)
                                   2
@end group
@end example

@item
変数変換。この例では２回変数変換があります。
@code{gradef}で規定された導関数を使ったものと未知関数@code{r(x)}の微分@code{diff(r(x))}を使ったもの。

@example
@group
(%i3) gradef (q(x), sin(x**2));
(%o3)                         q(x)
@end group
@group
(%i4) diff (log (q (r (x))), x);
                      d               2
                     (-- (r(x))) sin(r (x))
                      dx
(%o4)                ----------------------
                            q(r(x))
@end group
@group
(%i5) integrate (%, x);
(%o5)                     log(q(r(x)))
@end group
@end example

@item
@code{'integrate}名詞形を含む戻り値。
この例では、Maximaは有理関数の分母の因子を抽出できますが、剰余を因数分解できないか積分をみつけられません。
@code{grind}は、結果として名詞形@code{'integrate}を示します。
積分や有理関数について更に知るには@code{integrate_use_rootsof}も参照ください。

@example
@group
(%i1) expand ((x-4) * (x^3+2*x+1));
                    4      3      2
(%o1)              x  - 4 x  + 2 x  - 7 x - 4
@end group
@group
(%i2) integrate (1/%, x);
                              /  2
                              [ x  + 4 x + 18
                              I ------------- dx
                              ]  3
                 log(x - 4)   / x  + 2 x + 1
(%o2)            ---------- - ------------------
                     73               73
@end group
@group
(%i3) grind (%);
log(x-4)/73-('integrate((x^2+4*x+18)/(x^3+2*x+1),x))/73$
@end group
@end example

@item
積分を使った関数の定義。
関数の本体は、関数が定義された時には評価されません。
この例では、@code{f_1}の本体は、@code{integrate}の名詞形を含みます。
クォートクォート演算子@code{'@w{}'}があると、積分が評価され、結果が@code{f_2}の本体になります。

@example
@group
(%i1) f_1 (a) := integrate (x^3, x, 1, a);
                                     3
(%o1)           f_1(a) := integrate(x , x, 1, a)
@end group
@group
(%i2) ev (f_1 (7), nouns);
(%o2)                          600
@end group
@group
(%i3) /* Note parentheses around integrate(...) here */
      f_2 (a) := ''(integrate (x^3, x, 1, a));
                                   4
                                  a    1
(%o3)                   f_2(a) := -- - -
                                  4    4
@end group
@group
(%i4) f_2 (7);
(%o4)                          600
@end group
@end example
@end itemize

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{integration_constant}
@defvr {システム変数} integration_constant
デフォルト値: @code{%c}

積分定数は、等式の不定積分によって導入され、
定数名は、
@code{integration_constant}と@code{integration_constant_counter}を連結することで構成されます。

@code{integration_constant}は、任意のシンボルに割り当てられます。

例:

@c ===beg===
@c integrate (x^2 = 1, x);
@c integration_constant : 'k;
@c integrate (x^2 = 1, x);
@c ===end===
@example
@group
(%i1) integrate (x^2 = 1, x);
                           3
                          x
(%o1)                     -- = x + %c1
                          3
@end group
@group
(%i2) integration_constant : 'k;
(%o2)                           k
@end group
@group
(%i3) integrate (x^2 = 1, x);
                            3
                           x
(%o3)                      -- = x + k2
                           3
@end group
@end example

@opencatbox
@category{Integral calculus}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{integration_constant_counter}
@defvr {システム変数} integration_constant_counter
デフォルト値: 0

積分定数が等式の不定積分によって導入された時、
定数名は、
@code{integration_constant}と@code{integration_constant_counter}を連結することで構成されます。

@code{integration_constant_counter}は、
次の積分定数を構成する前に増分されます。

例:

@c ===beg===
@c integrate (x^2 = 1, x);
@c integrate (x^2 = 1, x);
@c integrate (x^2 = 1, x);
@c reset (integration_constant_counter);
@c integrate (x^2 = 1, x);
@c ===end===
@example
@group
(%i1) integrate (x^2 = 1, x);
                           3
                          x
(%o1)                     -- = x + %c1
                          3
@end group
@group
(%i2) integrate (x^2 = 1, x);
                           3
                          x
(%o2)                     -- = x + %c2
                          3
@end group
@group
(%i3) integrate (x^2 = 1, x);
                           3
                          x
(%o3)                     -- = x + %c3
                          3
@end group
@group
(%i4) reset (integration_constant_counter);
(%o4)            [integration_constant_counter]
@end group
@group
(%i5) integrate (x^2 = 1, x);
                           3
                          x
(%o5)                     -- = x + %c1
                          3
@end group
@end example

@opencatbox
@category{Integral calculus}
@closecatbox

@end defvr

@c -----------------------------------------------------------------------------
@anchor{integrate_use_rootsof}
@defvr {オプション変数} integrate_use_rootsof
デフォルト値: @code{false}

@code{integrate_use_rootsof}が@code{true}かつ有理関数の分子が因数分解できない時、
@code{integrate}は、
分子の（まだ知られていない）根上の和という形式で積分を返します。

例えば、
@code{integrate_use_rootsof}を@code{false}に設定すると、
@code{integrate}は、有理関数の未解決積分を名詞形で返します:

@example
(%i1) integrate_use_rootsof: false$
@group
(%i2) integrate (1/(1+x+x^5), x);
        /  2
        [ x  - 4 x + 5
        I ------------ dx                            2 x + 1
        ]  3    2                2            5 atan(-------)
        / x  - x  + 1       log(x  + x + 1)          sqrt(3)
(%o2)   ----------------- - --------------- + ---------------
                7                 14             7 sqrt(3)
@end group
@end example

さて、フラグを@code{true}に設定し、
積分の未解決部分を
有理関数の分子の根上の和として表現しましょう:

@example
(%i3) integrate_use_rootsof: true$
@group
(%i4) integrate (1/(1+x+x^5), x);
      ====        2
      \       (%r4  - 4 %r4 + 5) log(x - %r4)
       >      -------------------------------
      /                    2
      ====            3 %r4  - 2 %r4
                        3      2
      %r4 in rootsof(%r4  - %r4  + 1, %r4)
(%o4) ----------------------------------------------------------
               7

                                                      2 x + 1
                                  2            5 atan(-------)
                             log(x  + x + 1)          sqrt(3)
                           - --------------- + ---------------
                                   14             7 sqrt(3)
@end group
@end example

代わりにユーザーは別々に分子の根を計算できます。
例えば、もし分子が3次多項式なら
@code{1/((x - a)*(x - b)*(x - c))}または@code{1/((x^2 - (a+b)*x + a*b)*(x - c))}
というように
これらの根を使って被積分関数を表現できます。
時々、これはMaximaがもっと役立つ結果を得るのを助けます。

@opencatbox
@category{Integral calculus}
@closecatbox

@end defvr

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{ldefint}
@deffn {関数} ldefint (@var{expr}, @var{x}, @var{a}, @var{b})

@var{expr}の@var{x}に関する不定積分を上限@var{b}と下限@var{a}で評価するために
@code{limit}を使うことによって@var{expr}の定積分を計算しようとします。
もし定積分を計算するのに失敗したなら、
@code{ldefint}は、名詞形として極限を含む式を返します。

@code{ldefint}は、@code{integrate}からコールされないので、
o executing 
@code{ldefint (@var{expr}, @var{x}, @var{a}, @var{b})}
を実行することは、
@code{integrate (@var{expr}, @var{x}, @var{a}, @var{b})}
とは違った結果をもたらすかもしれません。
@code{ldefint}は、定積分を評価するためにいつも同じ方法を使いますが、
@code{integrate}は、様々な発見的方法を利用し、いくつかの特殊な場合を認識することもあります。

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c UMM, IS THERE SOME TEXT MISSING HERE ???
@c WHAT IS THIS ABOUT EXACTLY ??

@c -----------------------------------------------------------------------------
@anchor{potential}
@deffn {関数} potential (@var{givengradient})

計算は、
@code{nonlist}または形式
@example
[indeterminatej=expressionj, indeterminatek=expressionk, ...]
@end example
でなければならないグローバル変数@code{potentialzeroloc[0]}を利用します。
ここで、前者は後者の中のすべての右辺のnonlist式と同値です（訳者無理解）。
示された右辺は、積分の下限として使われます。
積分の成功は、
それらの値と順序に依存するかもしれません。
@code{potentialzeroloc}は、0に初期化されます。

@end deffn

@c -----------------------------------------------------------------------------
@anchor{residue}
@deffn {関数} residue (@var{expr}, @var{z}, @var{z_0})

変数@var{z}が値@var{z_0}を仮定する時、
式@var{expr}の複素平面での留数を計算します。
留数は、
@var{expr}のローラン級数における
@code{(@var{z} - @var{z_0})^(-1)}の係数です。

@example
@group
(%i1) residue (s/(s**2+a**2), s, a*%i);
                                1
(%o1)                           -
                                2
@end group
@group
(%i2) residue (sin(a*x)/x**4, x, 0);
                                 3
                                a
(%o2)                         - --
                                6
@end group
@end example

@opencatbox
@category{Integral calculus} @category{Complex variables}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{risch}
@deffn {関数} risch (@var{expr}, @var{x})

リッシュアルゴリズムの超越な場合を使って、
@var{expr}を
@var{x}に関して積分します。
（リッシュアルゴリズムの代数的な場合は実装されていません。）
これは、現在、@code{integrate}の主要部ができない入れ子の指数関数や対数関数の場合を扱います。
@code{integrate}は、これらの場合が与えられたなら、自動的に@code{risch}を適用します。

@code{erfflag}がもし@code{false}なら、
もしまず第一に被積分関数になにもないなら、
@code{risch}が
答えの中に@code{erf}関数を導入することを妨げます。

@example
@group
(%i1) risch (x^2*erf(x), x);
                                                        2
             3                      2                - x
        %pi x  erf(x) + (sqrt(%pi) x  + sqrt(%pi)) %e
(%o1)   -------------------------------------------------
                              3 %pi
@end group
@group
(%i2) diff(%, x), ratsimp;
                             2
(%o2)                       x  erf(x)
@end group
@end example

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@c NEEDS EXPANSION, CLARIFICATION, AND EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{residue}
@deffn {関数} tldefint (@var{expr}, @var{x}, @var{a}, @var{b})

@code{tlimswitch}が@code{true}に設定されている@code{ldefint}と同値です。

@opencatbox
@category{Integral calculus}
@closecatbox
@end deffn

@footnotestyle end

@c -----------------------------------------------------------------------------
@node Introduction to QUADPACK, Functions and Variables for QUADPACK, Functions and Variables for Integration, Integration
@section Introduction to QUADPACK
@anchor{residue}

@c FOLLOWING TEXT ADAPTED WITH HEAVY MODIFICATION FROM http://www.netlib.org/slatec/src/qpdoc.f

QUADPACKは、１次元定積分の数値計算のための関数のコレクションです。
R. Piessens @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
E. de Doncker @footnote{Applied Mathematics and Programming Division, K.U. Leuven},
C. Ueberhuber @footnote{Institut f@"ur Mathematik, T.U. Wien},
D. Kahaner @footnote{National Bureau of Standards, Washington, D.C., U.S.A}.
の合同プロジェクトから始まりました。

Maximaに含まれるQUADPACKライブラリは、
SLATEC共通数学ライブラリ バージョン4.1@footnote{@url{http://www.netlib.org/slatec}}
に現れる
QUADPACKのFortranのソースコードの
(プログラム@code{f2cl}による)自動翻訳です。

SLATECライブラリは1993年7月付ですが、QUADPACK関数は何年か前に書かれました。
QUADPACKももう１つのバージョンが
Netlib @footnote{@url{http://www.netlib.org/quadpack}}に
あります;
このバージョンがSLATECバージョンとどう違うのかはっきりしません。

Maximaに含まれるQUADPACK関数は、
これらの関数が、不特定の回数の関数の評価を要求し、
指定された精度まで結果を計算しようとする意味で、
すべて自動的です。
Maximaの、QUADPACKのLisp翻訳は、いくつかの自動的でない関数も含みますが、
それらは、Maximaレベルで公開されていません。

QUADPACKについての更なる情報は、
QUADPACK本
@footnote{R. Piessens, E. de Doncker-Kapenga, C.W. Uberhuber, and D.K. Kahaner.
@i{QUADPACK: A Subroutine Package for Automatic Integration.}
Berlin: Springer-Verlag, 1983, ISBN 0387125531.}
の中に見つけることができます。

@c -----------------------------------------------------------------------------
@subsection Overview
@c -----------------------------------------------------------------------------

@table @code
@item quad_qag
一般関数の有限の区間上の積分。
@code{quad_qag}は、Aind(Piessens, 1973)の戦略を使った
簡単な大域的適応積分器を実装しています。
呼び出し側は、ルール評価コンポーネントのための
ガウスークロンロッドの求積公式の6つのペアの中から選ぶことができます。
強く振動する非積分関数には高次のルールが適切です。

@item quad_qags
一般関数の有限の区間上の積分。
@code{quad_qags}は、イプシロンアルゴリズム(Wynn, 1956)による外挿(de Doncker,1978)を
使った大域的適応積分器を実装しています。

@item quad_qagi
一般関数の無限のもしくは半無限の区間上の積分。
区間は、有限の区間上に写像され、@code{quad_qags}の中で使われるのと同じ戦略が適用されます。

@item quad_qawo
@ifnottex
@math{cos(omega x) f(x)}
@end ifnottex
@tex
$\cos\left(\omega \, x\right) \, f\left(x\right)$
@end tex
や
@ifnottex
@math{sin(omega x) f(x)}
@end ifnottex
@tex
$\sin\left(\omega \, x\right) \, f\left(x\right)$
@end tex
の有限の区間上の積分。
ここで、
@ifnottex
@math{omega}
@end ifnottex
@tex
$\omega$
@end tex
は定数です。
規則評価構成要素は、変形Clenshaw-Curtis手法に基づいています。
@code{quad_qawo}は、
@code{quad_qags}に似て、外挿とともに適応再分割を適用します。

@item quad_qawf
フーリエコサイン変換またはフーリエサイン変換を半無限区間上で計算します。
@code{quad_qawo}で使われるのと同じアプローチが、連続する区間に適用され、
イプシロンアルゴリズム(Wynn, 1956)を使った収束の促進が積分寄与の級数に適用されます。

@item quad_qaws
@ifnottex
@math{w(x) f(x)}
@end ifnottex
@tex
$w\left(x\right) \, f\left(x\right)$
@end tex
の有限区間
@ifnottex
@math{[a, b]}
@end ifnottex
@tex
$\left[a, b\right]$
@end tex
上の積分。
ここで、
@ifnottex
@math{w}
@end ifnottex
@tex
$w$
@end tex
は形式
@ifnottex
@math{(x - a)^alpha (b - x)^beta v(x)}
@end ifnottex
@tex
$\left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, v\left(x\right)$
@end tex
の関数で、
@ifnottex
@math{v(x)}
@end ifnottex
@tex
$v\left(x\right)$
@end tex
は、
@ifnottex
1, @math{log(x - a)}, @math{log(b - x)}, @math{log(x - a) log(b - x)}
@end ifnottex
@tex
$1$, $\log\left(x - a\right)$
, $\log\left(b - x\right)$, $\log\left(x - a\right) \, \log\left(b - x\right)$
@end tex
のいずれかであり、
@ifnottex
@math{alpha > -1}
@end ifnottex
@tex
$\alpha > -1$
@end tex
かつ
@ifnottex
@math{beta > -1}
@end ifnottex
@tex
$\beta > -1$
@end tex
です。

大域的適応再分割戦略が適用され、
@math{a}または@math{b}を含む部分区間上では、
変形Clenshaw-Curtis積分を使います。

@item quad_qawc
@math{f(x)/(x - c)}のコーシーの主値を
有限の区間@math{(a, b)}上で指定された@math{c}を用いて
計算します。
戦略は、大域的適応的で、
点@math{x = c}を含む部分範囲上で変形Clenshaw-Curtis積分が使われます。
@end table

@opencatbox
@category{Integral calculus} @category{Numerical methods} @category{Share packages} @category{Package quadpack}
@closecatbox

@c -----------------------------------------------------------------------------
@node Functions and Variables for QUADPACK, , Introduction to QUADPACK, Integration
@section Functions and Variables for QUADPACK
@c -----------------------------------------------------------------------------

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qag}
@deffn  {関数} quad_qag (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{key}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {関数} quad_qag (@var{f}, @var{x}, @var{a}, @var{b}, @var{key}, [@var{epsrel}, @var{epsabs}, @var{limit}])

一般関数の有限の区間上の積分。
@code{quad_qag}は、Aind(Piessens, 1973)の戦略を使った
簡単な大域的適応積分器を実装しています。
呼び出し側は、ルール評価コンポーネントのための
ガウスークロンロッドの求積公式の6つのペアの中から選ぶことができます。
強く振動する非積分関数には高次のルールが適切です。

quad_qagは積分
@ifnottex
@math{integrate (f(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b {f(x) \, dx}$$
@end tex
を計算します。

非積分関数は依存変数@var{x}の@var{f(x)}であり、
関数は下限@var{a}上限@var{b}の間で積分されます。
@var{key}は利用される積分器で、1から6までのいずれかの整数でなければなりません。
@var{key}の値は、ガウスークロンロッドの積分ルールの次数を選びます。
高次のルールが、強く振動する非積分関数には適切です。

非積分関数は、MaximaもしくはLisp関数もしくは演算子の名前もしくMaximaのラムダ式か、
一般的なMaximaの式として指定されます。

数値積分は、望まれる精度が達成されるまで、
積分領域を部分区間に分割することによって適応的に実行されます。

キーワード引数はオプションで、どの次数においても指定できます。
それらは形式@code{key=val}を取ります。キーワード引数は：

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。limitは使用する部分区間の最大数。デフォルトは200。
@end table

@code{quad_qag}は４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード（戻り値の４番目の要素）は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 6
入力が無効な場合;

@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

例:

@example
@group
(%i1) quad_qag (x^(1/2)*log(1/x), x, 0, 1, 3, 'epsrel=5d-8);
(%o1)    [.4444444444492108, 3.1700968502883E-9, 961, 0]
@end group
@group
(%i2) integrate (x^(1/2)*log(1/x), x, 0, 1);
                                4
(%o2)                           -
                                9
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qags}
@deffn {関数} quad_qags (@var{f(x)}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {関数} quad_qags (@var{f}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

一般関数の有限の区間上の積分。
@code{quad_qags}は、イプシロンアルゴリズム(Wynn, 1956)による外挿(de Doncker,1978)を
使った大域的適応積分器を実装しています。

@code{quad_qags}は、積分

@ifnottex
@math{integrate (f(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b {f(x) \, dx}$$
@end tex
を計算します。

非積分関数は依存変数@var{x}の@var{f(x)}であり、
関数は下限@var{a}上限@var{b}の間で積分されます。

非積分関数は、MaximaもしくはLisp関数もしくは演算子の名前もしくMaximaのラムダ式か、一般的なMaximaの式として指定されます。

キーワード引数はオプションで、どの次数においても指定できます。
それらは形式@code{key=val}を取ります。キーワード引数は：

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。limitは使用する部分区間の最大数。デフォルトは200。
@end table

@code{quad_qags}は４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード（戻り値の４番目の要素）は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;
@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

例:

@example
@group
(%i1) quad_qags (x^(1/2)*log(1/x), x, 0, 1, 'epsrel=1d-10);
(%o1)   [.4444444444444448, 1.11022302462516E-15, 315, 0]
@end group
@end example

この積分に関しては、@code{quad_qags}は、@code{quad_qag}よりも精確で
効率的であることに注意してください。

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qagi}
@deffn  {関数} quad_qagi (@var{f(x)}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {関数} quad_qagi (@var{f}, @var{x}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

一般関数の無限のもしくは半無限の区間上の積分。
区間は、有限の区間上に写像され、@code{quad_qags}の中で使われるのと同じ戦略が適用されます。

@code{quad_qagi}は、Quadpack QAGIルーチンを使って以下の積分の１つを評価します。

@ifnottex
@math{integrate (f(x), x, a, inf)}
@end ifnottex
@tex
$$\int_a^\infty {f(x) \, dx}$$
@end tex

@ifnottex
@math{integrate (f(x), x, minf, a)}
@end ifnottex
@tex
$$\int_\infty^a {f(x) \, dx}$$
@end tex

@ifnottex
@math{integrate (f(x), x, minf, inf)}
@end ifnottex
@tex
$$\int_{-\infty}^\infty {f(x) \, dx}$$
@end tex

被積分関数は、@var{f(x)}であり、
従属変数@var{x}を使って、
関数は無限範囲上で積分されます。

被積分関数は、MaximaまたはLispの関数または演算子の名前、
Maximaのラムダ式またはMaximaの一般式として指定されるかもしれません。

積分の境界の１つは、無限でなければいけません。
もしそうでなければ、
@code{quad_qagi}はただ名詞形を返します。

キーワード引数は随意で、任意の順序で指定できます。
それらすべては形式@code{key=val}を取ります。
キーワード引数は:

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。limitは使用する部分区間の最大数。デフォルトは200。
@end table

@code{quad_qagi}は、４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;
@end table

@c NEED CROSS REFS HERE -- EITHER CROSS REF A QUADPACK OVERVIEW, OR CROSS REF EACH OF THE quad_* FUNCTIONS

例:

@example
@group
(%i1) quad_qagi (x^2*exp(-4*x), x, 0, inf, 'epsrel=1d-8);
(%o1)        [0.03125, 2.95916102995002E-11, 105, 0]
@end group
@group
(%i2) integrate (x^2*exp(-4*x), x, 0, inf);
                               1
(%o2)                          --
                               32
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qawc}
@deffn {関数} quad_qawc (@var{f(x)}, @var{x}, @var{c}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {関数} quad_qawc (@var{f}, @var{x}, @var{c}, @var{a}, @var{b}, [@var{epsrel}, @var{epsabs}, @var{limit}])

@math{f(x)/(x - c)}のコーシーの主値を
有限の区間@math{(a, b)}上で指定された@math{c}を用いて
計算します。
戦略は、大域的適応的で、
点@math{x = c}を含む部分範囲上で変形Clenshaw-Curtis積分が使われます。

@code{quad_qawc}は、
Quadpack QAWCルーチンを使って、
@ifnottex
@math{integrate (f(x)/(x - c), x, a, b)}
@end ifnottex
@tex
$$\int_{a}^{b}{{{f\left(x\right)}\over{x-c}}\>dx}$$
@end tex

のコーシーの主値を計算します。

被積分関数は、
@code{@var{f(x)}/(@var{x} - @var{c})}で、
従属変数@var{x}を使って、
関数は@var{a}から@var{b}までの区間上で積分されます。

被積分関数は、MaximaまたはLispの関数または演算子の名前、
Maximaのラムダ式またはMaximaの一般式として指定されるかもしれません。

キーワード引数は随意で、任意の順序で指定できます。
それらすべては形式@code{key=val}を取ります。
キーワード引数は:

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。limitは使用する部分区間の最大数。デフォルトは200。
@end table

@code{quad_qagc}は、４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;

@end table

例:

@example
@group
(%i1) quad_qawc (2^(-5)*((x-1)^2+4^(-5))^(-1), x, 2, 0, 5,
                 'epsrel=1d-7);
(%o1)    [- 3.130120337415925, 1.306830140249558E-8, 495, 0]
@end group
@group
(%i2) integrate (2^(-alpha)*(((x-1)^2 + 4^(-alpha))*(x-2))^(-1),
      x, 0, 5);
Principal Value
                       alpha
        alpha       9 4                 9
       4      log(------------- + -------------)
                      alpha           alpha
                  64 4      + 4   64 4      + 4
(%o2) (-----------------------------------------
                        alpha
                     2 4      + 2

       3 alpha                       3 alpha
       -------                       -------
          2            alpha/2          2          alpha/2
    2 4        atan(4 4       )   2 4        atan(4       )   alpha
  - --------------------------- - -------------------------)/2
              alpha                        alpha
           2 4      + 2                 2 4      + 2
@end group
@group
(%i3) ev (%, alpha=5, numer);
(%o3)                    - 3.130120337415917
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qawf}
@deffn  {関数} quad_qawf (@var{f(x)}, @var{x}, @var{a}, @var{omega}, @var{trig}, [@var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])
@deffnx {関数} quad_qawf (@var{f}, @var{x}, @var{a}, @var{omega}, @var{trig}, [@var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])

フーリエコサイン変換またはフーリエサイン変換を、
Quadpack QAWF関数を使って、半無限区間上で計算します。
@code{quad_qawo}で使われるのと同じアプローチが、連続する区間に適用され、
イプシロンアルゴリズム(Wynn, 1956)を使った収束の促進が積分寄与の級数に適用されます。

@code{quad_qawf}は積分
@ifnottex
@math{integrate (f(x)*w(x), x, a, inf)}
@end ifnottex
@tex
$$\int_a^\infty f(x) \, w(x) \, dx$$
@end tex
を計算します。

重み関数@math{w}は@var{trig}によって選択されます:

@table @code
@item cos
@math{w(x) = cos (omega x)}
@item sin
@math{w(x) = sin (omega x)}
@end table

被積分関数は、MaximaまたはLispの関数または演算子の名前、
Maximaのラムダ式またはMaximaの一般式として指定されるかもしれません。

キーワード引数は随意で、任意の順序で指定できます。
それらすべては形式@code{key=val}を取ります。
キーワード引数は:

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。(@var{limit} - @var{limlst})/2は使用する部分区間の最大数。デフォルトは200。
@item maxp1
チェビシェフ積率の最大数。
0より大きくなければいけません。
デフォルトは100です。
@item limlst
サイクル数に関する上限。
3以上でなければいけません。
デフォルトは10です。
@end table

@code{quad_qawf}は、４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;

@end table

例:

@example
@group
(%i1) quad_qawf (exp(-x^2), x, 0, 1, 'cos, 'epsabs=1d-9);
(%o1)   [.6901942235215714, 2.84846300257552E-11, 215, 0]
@end group
@group
(%i2) integrate (exp(-x^2)*cos(x), x, 0, inf);
                          - 1/4
                        %e      sqrt(%pi)
(%o2)                   -----------------
                                2
@end group
@group
(%i3) ev (%, numer);
(%o3)                   .6901942235215714
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qawo}
@deffn  {関数} quad_qawo (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, [@var{epsrel}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])
@deffnx {関数} quad_qawo (@var{f}, @var{x}, @var{a}, @var{b}, @var{omega}, @var{trig}, [@var{epsrel}, @var{epsabs}, @var{limit}, @var{maxp1}, @var{limlst}])

@ifnottex
@math{cos(omega x) f(x)}
@end ifnottex
@tex
$\cos\left(\omega \, x\right) \, f\left(x\right)$
@end tex
や
@ifnottex
@math{sin(omega x) f(x)}
@end ifnottex
@tex
$\sin\left(\omega \, x\right) \, f\left(x\right)$
@end tex
の有限の区間上の積分。
ここで、
@ifnottex
@math{omega}
@end ifnottex
@tex
$\omega$
@end tex
は定数です。
規則評価構成要素は、変形Clenshaw-Curtis手法に基づいています。
@code{quad_qawo}は、
@code{quad_qags}に似て、外挿とともに適応再分割を適用します。

@code{quad_qawo}は、
Quadpack QAWOルーチンを使って
積分を計算します:

@ifnottex
@math{integrate (f(x)*w(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b f(x) \, w(x) \, dx$$
@end tex

重み関数@math{w}は、@var{trig}によって選択されます:

@table @code
@item cos
@ifnottex
@math{w(x) = cos (omega x)}
@end ifnottex
@tex
$w\left(x\right) = \cos \left(\omega \, x\right)$
@end tex
@item sin
@ifnottex
@math{w(x) = sin (omega x)}
@end ifnottex
@tex
$w\left(x\right) = \sin \left(\omega \, x\right)$
@end tex
@end table

被積分関数は、MaximaまたはLispの関数または演算子の名前、
Maximaのラムダ式またはMaximaの一般式として指定されるかもしれません。

キーワード引数は随意で、任意の順序で指定できます。
それらすべては形式@code{key=val}を取ります。
キーワード引数は:

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。@var{limit}/2は使用する部分区間の最大数。デフォルトは200。
@item maxp1
チェビシェフ積率の最大数。
0より大きくなければいけません。
デフォルトは100です。
@item limlst
サイクル数に関する上限。
3以上でなければいけません。
デフォルトは10です。
@end table

@code{quad_qawo}は、４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;
@end table

例:

@example
@group
(%i1) quad_qawo (x^(-1/2)*exp(-2^(-2)*x), x, 1d-8, 20*2^2, 1, cos);
(%o1)     [1.376043389877692, 4.72710759424899E-11, 765, 0]
@end group
@group
(%i2) rectform (integrate (x^(-1/2)*exp(-2^(-alpha)*x) * cos(x),
      x, 0, inf));
                   alpha/2 - 1/2            2 alpha
        sqrt(%pi) 2              sqrt(sqrt(2        + 1) + 1)
(%o2)   -----------------------------------------------------
                               2 alpha
                         sqrt(2        + 1)
@end group
@group
(%i3) ev (%, alpha=2, numer);
(%o3)                     1.376043390090716
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

@c THERE ARE OPTIONAL ARGUMENTS WHICH MAKES LISTING THE VARIANTS A LITTLE TEDIOUS
@c NEED A MORE CONVENIENT (AND NONAMBIGUOUS) NOTATION FOR OPTIONAL ARGUMENTS

@c -----------------------------------------------------------------------------
@anchor{quad_qaws}
@deffn  {関数} quad_qaws (@var{f(x)}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, [@var{epsrel}, @var{epsabs}, @var{limit}])
@deffnx {関数} quad_qaws (@var{f}, @var{x}, @var{a}, @var{b}, @var{alpha}, @var{beta}, @var{wfun}, [@var{epsrel}, @var{epsabs}, @var{limit}])

@math{w(x) f(x)}の有限の区間上の積分。
ここで、@math{w(x)}は、ある代数的または対数関数です。
大域的適応最分割戦略が適用されます。
積分の区間の端点を含む部分区間上で変形Clenshaw-Curtis積分を使います。

@code{quad_qaws}は、 
Quadpack QAWSルーチンを使って
積分を計算します:

@ifnottex
@math{integrate (f(x)*w(x), x, a, b)}
@end ifnottex
@tex
$$\int_a^b f(x) \, w(x) \, dx$$
@end tex

重み関数@math{w}は@var{wfun}によって選択されます:

@table @code
@item 1
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta$
@end tex
@item 2
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(x - a)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(x - a\right)$
@end tex
@item 3
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(b - x)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(b - x\right)$
@end tex
@item 4
@ifnottex
@math{w(x) = (x - a)^alpha (b - x)^beta log(x - a) log(b - x)}
@end ifnottex
@tex
$w\left(x\right) = \left(x - a\right)^\alpha \, \left(b - x\right)^\beta \, \log\left(x - a\right) \, \log\left(b - x\right)$
@end tex
@end table

被積分関数は、MaximaまたはLispの関数または演算子の名前、
Maximaのラムダ式またはMaximaの一般式として指定されるかもしれません。

キーワード引数は随意で、任意の順序で指定できます。
それらすべては形式@code{key=val}を取ります。
キーワード引数は:

@table @code
@item epsrel
望まれる近似の相対誤差。デフォルトは1d-8。
@item epsabs
望まれる近似の絶対誤差。デフォルトは0。
@item limit
内部の作業配列のサイズ。@var{limit}は使用する部分区間の最大数。デフォルトは200。
@end table

@code{quad_qaws}は、４つの要素のリストを返します:

@itemize
@item
積分の近似
@item
見積もられた近似の絶対誤差
@item
非積分関数の評価数
@item
エラーコード
@end itemize

エラーコード(戻り値の４番目の要素)は以下の値を取ります:

@table @code
@item 0
問題が発生しなかった場合;
@item 1
部分区間の数が上限を超えた場合;
@item 2
丸め誤差が超過した場合;
@item 3
非積分関数の振る舞いが極端に悪い場合;
@item 4
収束に失敗した場合;
@item 5
積分が発散しているか収束が遅い場合;
@item 6
入力が無効な場合;

@end table

例:

@example
@group
(%i1) quad_qaws (1/(x+1+2^(-4)), x, -1, 1, -0.5, -0.5, 1,
                 'epsabs=1d-9);
(%o1)     [8.750097361672832, 1.24321522715422E-10, 170, 0]
@end group
@group
(%i2) integrate ((1-x*x)^(-1/2)/(x+1+2^(-alpha)), x, -1, 1);
       alpha
Is  4 2      - 1  positive, negative, or zero?

pos;
                          alpha         alpha
                   2 %pi 2      sqrt(2 2      + 1)
(%o2)              -------------------------------
                               alpha
                            4 2      + 2
@end group
@group
(%i3) ev (%, alpha=4, numer);
(%o3)                     8.750097361672829
@end group
@end example

@opencatbox
@category{Numerical methods} @category{Package quadpack}
@closecatbox
@end deffn

