@menu     
* Introduction to operators::      
* Arithmetic operators::
* Relational operators::
* Logical operators::
* Operators for Equations::
* Assignment operators::
* User defined operators::
@end menu

@c -----------------------------------------------------------------------------
@node Introduction to operators, Arithmetic operators, Operators, Operators
@section Introduction to operators
@c -----------------------------------------------------------------------------

指定された優先順位を持つ新しい演算子を定義したり、
既存の演算子を未定義にしたり、既存の演算子の優先順位を再定義することが可能です。
演算子は単項前置、単項後置、二項中置、n項中置、マッチフィックスか無項でありえます。
「マッチフィックス」は引数を括るシンボルの対を意味し、
「無項」は引数を取らない演算子を意味します。
異なるタイプの演算子の例として、以下があります。

@table @asis
@item unary prefix
negation @code{- a}
@item unary postfix
factorial @code{a!}
@item binary infix
exponentiation @code{a^b}
@item n-ary infix
addition @code{a + b}
@item matchfix
list construction @code{[a, b]}
@end table

(組み込みの無項演算子はありません; そんな演算子の例は、@code{nofix}を参照してください。.)

新しい演算子を定義するメカニズムはわかりやすいものです。
関数を演算子として宣言することだけが必要です;
演算子関数は定義されることもされないこともあります。

ユーザー定義の演算子の例は以下の通りです。
明示的な関数コール @code{"dd" (a)}は @code{dd a}と同値であり、また、
@code{"<-" (a, b)}は @code{a <- b}と同値であることに注意してください。
この例で、 @code{"dd"}と @code{"<-"}は未定義です。

@c ===beg===
@c prefix ("dd");
@c dd a;
@c "dd" (a);
@c infix ("<-");
@c a <- dd b;
@c "<-" (a, "dd" (b));
@c ===end===
@example
(%i1) prefix ("dd");
(%o1)                          dd
(%i2) dd a;
(%o2)                         dd a
(%i3) "dd" (a);
(%o3)                         dd a
(%i4) infix ("<-");
(%o4)                          <-
(%i5) a <- dd b;
(%o5)                      a <- dd b
(%i6) "<-" (a, "dd" (b));
(%o6)                      a <- dd b
@end example

新しい演算子を定義するMaxima関数はこの表にまとめられます。
デフォルトの左と右の結合力(それぞれlbpとrbp)を記載します。
@c REWORK FOLLOWING COMMENT.
@c IT'S NOT CLEAR ENOUGH, GIVEN THAT IT'S FAIRLY IMPORTANT
(結合力は演算子の優先順位を決めます。
しかしながら、左と右の結合力は異なることがあり、
結合力は優先順位より幾分複雑です。)
演算定義関数のいくつかは追加の引数を取ります;
詳細は関数記述を参照してください。

@c MAKE ANCHORS FOR ALL 6 FUNCTIONS AND CHANGE @code TO @ref ACCORDINGLY
@table @code
@item prefix
rbp=180
@item postfix
lbp=180
@item infix
lbp=180, rbp=180
@item nary
lbp=180, rbp=180
@item matchfix
(binding power not applicable)
@item nofix
(binding power not applicable)
@end table

比較のために、いくつかの組み込み演算子と左右結合力を上げます。

@example
Operator   lbp     rbp

  :        180     20 
  ::       180     20 
  :=       180     20 
  ::=      180     20 
  !        160
  !!       160
  ^        140     139 
  .        130     129 
  *        120
  /        120     120 
  +        100     100 
  -        100     134 
  =        80      80 
  #        80      80 
  >        80      80 
  >=       80      80 
  <        80      80 
  <=       80      80 
  not              70 
  and      65
  or       60
  ,        10
  $        -1
  ;        -1
@end example

@mref{remove}と @mref{kill}は演算子プロパティをアトムから削除します。
@code{remove ("@var{a}", op)}は @var{a}の演算子プロパティだけを削除します。
@code{kill ("@var{a}")}は 演算子プロパティを含む@var{a}のすべてのロパティを削除します。
演算子名はクォーテーションマークで括らないといけないことに注意してください。

@c MAYBE COPY THIS EXAMPLE TO remove AND/OR kill
@c ===beg===
@c infix ("##");
@c "##" (a, b) := a^b;
@c 5 ## 3;
@c remove ("##", op);
@c 5 ## 3;
@c "##" (5, 3);
@c infix ("##");
@c 5 ## 3;
@c kill ("##");
@c 5 ## 3;
@c "##" (5, 3);
@c ===end===
@example
(%i1) infix ("##");
(%o1)                          ##
(%i2) "##" (a, b) := a^b;
                                     b
(%o2)                     a ## b := a
(%i3) 5 ## 3;
(%o3)                          125
(%i4) remove ("##", op);
(%o4)                         done
(%i5) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i5) "##" (5, 3);
(%o5)                          125
(%i6) infix ("##");
(%o6)                          ##
(%i7) 5 ## 3;
(%o7)                          125
(%i8) kill ("##");
(%o8)                         done
(%i9) 5 ## 3;
Incorrect syntax: # is not a prefix operator
5 ##
  ^
(%i9) "##" (5, 3);
(%o9)                       ##(5, 3)
@end example

@opencatbox
@category{Operators} @category{Syntax}
@closecatbox

@c -----------------------------------------------------------------------------
@node Arithmetic operators, Relational operators, Introduction to operators, Operators
@section Arithmetic operators
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{+}
@anchor{-}
@anchor{*}
@anchor{/}
@anchor{^}
@deffn {演算子} +
@ifinfo
@fnindex 足し算
@end ifinfo
@deffnx {演算子} -
@ifinfo
@fnindex 引き算
@end ifinfo
@deffnx {演算子} *
@ifinfo
@fnindex かけ算
@end ifinfo
@deffnx {演算子} /
@ifinfo
@fnindex 割り算
@end ifinfo
@deffnx {演算子} ^
@ifinfo
@fnindex べき乗
@end ifinfo

シンボル @code{+} @code{*} @code{/} @code{^}はそれぞれ、
足し算、かけ算、割り算、べき乗を表します。
これらの演算子の名前は @code{"+"} @code{"*"} @code{"/"} @code{"^"}です。
これらは関数や演算子の名前が求められるところで使います。

シンボル @code{+}や @code{-}はそれぞれ、プラスとマイナスの単項演算子を示し、
それらの名前はそれぞれ @code{"+"}と@code{"-"}です。

引き算 @code{a - b}はMaximaの中では足し算 @code{a + (- b)}として表されます。
@code{a + (- b)}のような式は引き算として表示されます。
Maximaは @code{"-"}を足し算の単項逆元演算子の名前としてのみ認識して、
二項引き算演算子としては認識しません。

Maximaの中では割り算@code{a / b}をかけ算@code{a * b^(- 1)}として表現します。
@code{a * b^(- 1)}のような式は割り算として表示されます。
Maximaは@code{"/"}を割り算演算子の名前として認識します。

足し算とかけ算はn項可換演算子です。
割り算とべき乗は二項の非可換演算子です。

Maximaは正準表現を構成するために可換演算子のオペランド(訳注：引数)を並べ替えます。
順序は内部的には @code{orderlessp}で決定します。
表示のためには、足し算の順序は @code{ordergreatp}で決定し、
かけ算は内部的な順序と同じです。

算術計算は、数リテラル（整数、有理数、通常の浮動小数点、多倍長浮動小数点）上で実行されます。
べき乗を除いて、数に対するすべての算術演算子は数に整理されます。
べき乗は、オペランドが通常の浮動小数点か多倍長浮動小数点の時、もしくは結果が厳密に整数もしくは有理数の時、数に整理されます;
そうでなければ、べき乗は @code{sqrt}か他のべき乗に整理されるか、そのまま残されます。

浮動小数点の伝搬が算術計算に適用されます:
もしどれか１つでもオペランドが多倍長浮動小数点なら、結果は多倍長浮動小数点です;
そうでなければ、もしどれか１つでもオペランドが通常の浮動小数点なら、結果は通常の浮動小数点です;
そうでなければオペランドは有理数か整数であり、結果は有理数か整数です。

算術計算は式整理であって、評価ではありません。
従って、クォートされた（しかし整理される）式の中で算術計算は実行されます。

算術演算は、
グローバルフラグ @code{listarith}が @code{true}の時
リストに対して要素毎に適用され、
行列に対しては常に要素毎に適用されます。
オペランドの１つがリストか行列であり、もう１つのオペランドが別のタイプの時、
他のオペランドはリストか行列の要素のそれぞれに組み合わされます。

例:

足し算とかけ算は、n項可換演算子です。
Maximaは、正準表現を構成するために、可換演算子のオペランドを並べ替えます。
それらの名前はそれぞれ @code{"+"}と @code{"*"}です。

@c ===beg===
@c c + g + d + a + b + e + f;
@c [op (%), args (%)];
@c c * g * d * a * b * e * f;
@c [op (%), args (%)];
@c apply ("+", [a, 8, x, 2, 9, x, x, a]);
@c apply ("*", [a, 8, x, 2, 9, x, x, a]);
@c ===end===
@example
(%i1) c + g + d + a + b + e + f;
(%o1)               g + f + e + d + c + b + a
(%i2) [op (%), args (%)];
(%o2)              [+, [g, f, e, d, c, b, a]]
(%i3) c * g * d * a * b * e * f;
(%o3)                     a b c d e f g
(%i4) [op (%), args (%)];
(%o4)              [*, [a, b, c, d, e, f, g]]
(%i5) apply ("+", [a, 8, x, 2, 9, x, x, a]);
(%o5)                    3 x + 2 a + 19
(%i6) apply ("*", [a, 8, x, 2, 9, x, x, a]);
                                 2  3
(%o6)                       144 a  x
@end example

割り算とべき乗は、二項の非可換演算子です。
それらの名前はそれぞれ @code{"/"}と @code{"^"}です。

@c ===beg===
@c [a / b, a ^ b];
@c [map (op, %), map (args, %)];
@c [apply ("/", [a, b]), apply ("^", [a, b])];
@c ===end===
@example
(%i1) [a / b, a ^ b];
                              a   b
(%o1)                        [-, a ]
                              b
(%i2) [map (op, %), map (args, %)];
(%o2)              [[/, ^], [[a, b], [a, b]]]
(%i3) [apply ("/", [a, b]), apply ("^", [a, b])];
                              a   b
(%o3)                        [-, a ]
                              b
@end example

引き算と割り算は内部的にはそれぞれ、足し算とかけ算を使って表現されます。

@c ===beg===
@c [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
@c [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
@c ===end===
@example
(%i1) [inpart (a - b, 0), inpart (a - b, 1), inpart (a - b, 2)];
(%o1)                      [+, a, - b]
(%i2) [inpart (a / b, 0), inpart (a / b, 1), inpart (a / b, 2)];
                                   1
(%o2)                       [*, a, -]
                                   b
@end example

計算は数リテラルに対して実行されます。
浮動小数点伝搬が適用されます。

@c ===beg===
@c 17 + b - (1/2)*29 + 11^(2/4);
@c [17 + 29, 17 + 29.0, 17 + 29b0];
@c ===end===
@example
(%i1) 17 + b - (1/2)*29 + 11^(2/4);
                                       5
(%o1)                   b + sqrt(11) + -
                                       2
(%i2) [17 + 29, 17 + 29.0, 17 + 29b0];
(%o2)                   [46, 46.0, 4.6b1]
@end example

算術計算は式整理であって、評価ではありません。

@c ===beg===
@c simp : false;
@c '(17 + 29*11/7 - 5^3);
@c simp : true;
@c '(17 + 29*11/7 - 5^3);
@c ===end===
@example
(%i1) simp : false;
(%o1)                         false
(%i2) '(17 + 29*11/7 - 5^3);
                              29 11    3
(%o2)                    17 + ----- - 5
                                7
(%i3) simp : true;
(%o3)                         true
(%i4) '(17 + 29*11/7 - 5^3);
                                437
(%o4)                         - ---
                                 7
@end example

算術計算は（@code{listarith}に依存して）リストや行列に対して要素毎に実行されます。

@c ===beg===
@c matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
@c 5 * matrix ([a, x], [h, u]);
@c listarith : false;
@c [a, c, m, t] / [1, 7, 2, 9];
@c [a, c, m, t] ^ x;
@c listarith : true;
@c [a, c, m, t] / [1, 7, 2, 9];
@c [a, c, m, t] ^ x;
@c ===end===
@example
(%i1) matrix ([a, x], [h, u]) - matrix ([1, 2], [3, 4]);
@group
                        [ a - 1  x - 2 ]
(%o1)                   [              ]
                        [ h - 3  u - 4 ]
@end group
(%i2) 5 * matrix ([a, x], [h, u]);

                          [ 5 a  5 x ]
(%o2)                     [          ]
                          [ 5 h  5 u ]
(%i3) listarith : false;
(%o3)                         false
(%i4) [a, c, m, t] / [1, 7, 2, 9];
                          [a, c, m, t]
(%o4)                     ------------
                          [1, 7, 2, 9]
(%i5) [a, c, m, t] ^ x;
                                      x
(%o5)                     [a, c, m, t]
(%i6) listarith : true;
(%o6)                         true
(%i7) [a, c, m, t] / [1, 7, 2, 9];
                              c  m  t
(%o7)                     [a, -, -, -]
                              7  2  9
(%i8) [a, c, m, t] ^ x;
                          x   x   x   x
(%o8)                   [a , c , m , t ]
@end example

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{**}
@deffn {演算子} **

べき乗演算子。
Maximaは入力の中で @code{**}を @code{^}と同じ演算子と認識し、
1次元出力の中では @code{^}として表示し、
また、2次元出力の中では指数を上付き添字として配置します。

@mref{fortran}関数は、入力が @code{**}でも @code{^}でも、
べき乗演算子を @code{**}として表示します。

例:

@c ===beg===
@c is (a**b = a^b);
@c x**y + x^z;
@c string (x**y + x^z);
@c fortran (x**y + x^z);
@c ===end===
@example
(%i1) is (a**b = a^b);
(%o1)                         true
(%i2) x**y + x^z;
                              z    y
(%o2)                        x  + x
(%i3) string (x**y + x^z);
(%o3)                        x^z+x^y
(%i4) fortran (x**y + x^z);
      x**z+x**y
(%o4)                         done
@end example

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{^^}
@deffn {演算子} ^^
@ifinfo
@fnindex 非可換べき乗
@end ifinfo

非可換べき乗演算子。
ちょうど可換なかけ算 @code{*}に通常のべき乗演算子 @code{^}が対応するように、
@code{^^}は非可換かけ算 @code{.}に対応するべき乗演算子です。

非可換べき乗演算子は、１次元出力では @code{^^}で表示され、
２次元出力では、指数をかっこ @code{< >}で囲まれた上付き添字として置きます。

例:

@c ===beg===
@c a . a . b . b . b + a * a * a * b * b;
@c string (a . a . b . b . b + a * a * a * b * b);
@c ===end===
@example
(%i1) a . a . b . b . b + a * a * a * b * b;
                        3  2    <2>    <3>
(%o1)                  a  b  + a    . b
(%i2) string (a . a . b . b . b + a * a * a * b * b);
(%o2)                  a^3*b^2+a^^2 . b^^3
@end example

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{.}
@deffn {演算子} .
@ifinfo
@fnindex 非可換かけ算
@end ifinfo

行列（非可換）かけ算のためのドット演算子。
@code{"."}をこの意味で用いる時、
例えば @code{A . B}のように両側にスペースを置かなければいけません。
これで浮動小数点の小数点と区別します。

@code{dot}や
@code{dot0nscsimp},
@code{dot0simp},
@code{dot1simp},
@code{dotassoc},
@code{dotconstrules},
@code{dotdistrib},
@code{dotexptsimp},
@code{dotident},
@code{dotscrules}.
も参照してください。

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Relational operators, Logical operators, Arithmetic operators, Operators
@section Relational operators
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{<}
@anchor{<=}
@anchor{>=}
@anchor{>}
@deffn {演算子} <
@ifinfo
@fnindex 小なり
@end ifinfo
@deffnx {演算子} <=
@ifinfo
@fnindex 以下
@end ifinfo
@deffnx {演算子} >=
@ifinfo
@fnindex 以上
@end ifinfo
@deffnx {演算子} >
@ifinfo
@fnindex 大なり
@end ifinfo

シンボル @code{<}  @code{<=} @code{>=} @code{>}はそれぞれ、小なり、以下、以上、大なり、を表します。
これらの演算子の名前は、 @code{"<"}、 @code{"<="}、 @code{">="}、 @code{">"}です。
それらは関数や演算子の名前が求められるところで使われます。

これらの関係演算子はすべて二項演算子です;
@code{a < b < c}のような構成をMaximaは認識しません。

関数 @mref{is}や @mref{maybe}、
プログラミング構成子 @mref{if}, @mref{while}, @mref{unless}が
関係式をブーリアン値に評価します。
そうでなければ、関係式はブーリアン値に評価されたり整理されたりしませんが、
関係式の引数は（評価がクォーテーションによって妨げられないかぎり）評価されます。

関係式が @code{true}もしくは @code{false}に評価できない時、
@code{is}や @code{if}の振る舞いは、グローバルフラグ @mref{prederror}が決定します。
@code{prederror}が @code{true}の時、 @code{is}や @code{if}はエラーをトリガーします。
@code{prederror}が @code{false}の時、
@code{is}は @code{unknown}を返し、
@code{if}は部分的に評価された条件式を返します。

@code{maybe}はいつも、 @code{prederror}が @code{false}であるかのように振る舞い、
@code{while}や @code{unless}はいつも、 @code{prederror}が @code{true}であるかのように振る舞います。

関係演算子はリストやほかの集合上で展開されることはありません。

@mref{=}や @mref{#}、 @mref{equal}、 @mref{notequal}も参照してください。

例:

いくつかの関数やプログラミング構成子が関係式をブーリアン値に評価します。

@c ===beg===
@c [x, y, z] : [123, 456, 789];
@c is (x < y);
@c maybe (y > z);
@c if x >= z then 1 else 0;
@c block ([S], S : 0, for i:1 while i <= 100 do S : S + i, 
@c        return (S));
@c ===end===
@example
(%i1) [x, y, z] : [123, 456, 789];
(%o1)                    [123, 456, 789]
(%i2) is (x < y);
(%o2)                         true
(%i3) maybe (y > z);
(%o3)                         false
(%i4) if x >= z then 1 else 0;
(%o4)                           0
(%i5) block ([S], S : 0, for i:1 while i <= 100 do S : S + i, 
             return (S));
(%o5)                         5050
@end example

そうでなければ関係式はブーリアン値に評価されたり整理されたりしませんが、
関係式の引数は評価されます。

@c ===beg===
@c [x, y, z] : [123, 456, 789];
@c [x < y, y <= z, z >= y, y > z];
@c map (is, %);
@c ===end===
@example
(%o1)                    [123, 456, 789]
(%i2) [x < y, y <= z, z >= y, y > z];
(%o2)    [123 < 456, 456 <= 789, 789 >= 456, 456 > 789]
(%i3) map (is, %);
(%o3)               [true, true, true, false]
@end example

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Logical operators, Operators for Equations, Relational operators, Operators
@section Logical operators
@c -----------------------------------------------------------------------------

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{and}
@deffn {演算子} and
@ifinfo
@fnindex 論理積
@end ifinfo

論理積演算子。
@code{and}は、n項中置演算子です;
オペランドはブーリアン値で、結果もブーリアン値です。

@code{and}は、（@code{is}のように）１以上のオペランドの評価を強制し、
すべてのオペランドの評価を強制するかもしれません。

オペランドは、出現順に評価されます。
@code{and}は、結果を決定するのに必要なだけオペランドを評価します。
もし任意のオペランドが@code{false}なら、結果は@code{false}であり、
ほかのオペランドは評価されません。

グローバルフラグ@code{prederror}は、
評価されたオペランドが@code{true}か@code{false}に決定できない時の@code{and}の振る舞いを決定します。
@code{prederror}が@code{true}の時、@code{and}は、エラーメッセージを出力します。
そうでなければ、@code{true}か@code{false}に評価されないオペランドを受け付け、
結果はブーリアン式になります。

@code{and}は可換ではありません:
@code{a and b}は、不定のオペランドの扱いのため、@code{b and a}と同値ではないかもしれません。

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{not}
@deffn {演算子} not
@ifinfo
@fnindex 論理否定
@end ifinfo

論理否定演算子。
@code{not}は、接頭演算子です;
オペランドはブーリアン値で、結果もブーリアン値です。

@code{or}は、（@code{is}のように）オペランドの評価を強制します。

グローバルフラグ@code{prederror}は、
評価されたオペランドが@code{true}か@code{false}に決定できない時の@code{not}の振る舞いを決定します。
@code{prederror}が@code{true}の時、@code{not}は、エラーメッセージを出力します。
そうでなければ、@code{true}か@code{false}に評価されないオペランドを受け付け、
結果はブーリアン式になります。

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{or}
@deffn {演算子} or
@ifinfo
@fnindex 論理和
@end ifinfo

論理和演算子。
@code{or}は、n項中置演算子です;
オペランドはブーリアン値で、結果もブーリアン値です。

@code{or}は、（@code{is}のように）１以上のオペランドの評価を強制し、
すべてのオペランドの評価を強制するかもしれません。

オペランドは、出現順に評価されます。
@code{and}は、結果を決定するのに必要なだけオペランドを評価します。
もし任意のオペランドが@code{true}なら、結果は@code{true}であり、
ほかのオペランドは評価されません。

グローバルフラグ@code{prederror}は、
評価されたオペランドが@code{true}か@code{false}に決定できない時の@code{or}の振る舞いを決定します。
@code{prederror}が@code{true}の時、@code{or}は、エラーメッセージを出力します。
そうでなければ、@code{true}か@code{false}に評価されないオペランドを受け付け、
結果はブーリアン式になります。

@code{or}は可換ではありません:
@code{a or b}は、不定のオペランドの扱いのため、@code{b or a}と同値ではないかもしれません。

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Operators for Equations, Assignment operators, Logical operators, Operators
@section Operators for Equations
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{#}
@deffn {演算子} #
@ifinfo
@fnindex 不等号（構文的不等号）
@end ifinfo
構文的等号@code{=}の否定を表します。

述語論理式の評価のルールのため
（特に @code{not @var{expr}}は @var{expr}の評価を伴うので）、
@code{not @var{a} = @var{b}}は、 @code{@var{a} # @var{b}}ではなく、
@code{is(@var{a} # @var{b})}と同値です。

例:

@c ===beg===
@c a = b;
@c is (a = b);
@c a # b;
@c not a = b;
@c is (a # b);
@c is (not a = b);
@c ===end===
@example
(%i1) a = b;
(%o1)                         a = b
(%i2) is (a = b);
(%o2)                         false
(%i3) a # b;
(%o3)                         a # b
(%i4) not a = b;
(%o4)                         true
(%i5) is (a # b);
(%o5)                         true
(%i6) is (not a = b);
(%o6)                         true
@end example

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{=}
@deffn {演算子} =
@ifinfo
@fnindex 等式演算子
@fnindex 等号 (構文法的に等しい)
@end ifinfo

等式演算子。

式@code{@var{a} = @var{b}}は、それ自身、未評価の等式を表します。
等式は成り立つかもしれませんし、成り立たないかもしれません。
未評価の等式は、@mref{solve}や@mref{algsys}や他の関数の引数として用いられます。

関数@mref{is}は、@code{=}をブーリアン値に評価します。
@code{is(@var{a} = @var{b})}は、@var{a}と@var{b}が同一のとき、
@code{@var{a} = @var{b}}を@code{true}に評価します。
すなわち、@var{a}と@var{b}が同一のアトムであるか、もしくは、それらはアトムではなく、
それらの演算子が同一で、演算子の引数が同一です。
そうでなければ、@code{is(@var{a} = @var{b})}は@code{false}に評価されます;
決して、@code{unknown}には評価されません。
@code{is(@var{a} = @var{b})}が@code{true}の時、
@var{a}と@var{b}は、同値の式と対照的に、構文法的に等しいと言われます。
同値の式は、@code{is(equal(@var{a}, @var{b}))}が@code{true}の式です。
式は、同値だが構文法的に等しくないことが起こりえます。

@code{=}の否定は、@mref{#}で表されます。
@code{=}と同様、式@code{@var{a} # @var{b}}は、それ自身、評価されません。
@code{is(@var{a} # @var{b})}は、@code{@var{a} # @var{b}}を@code{true}もしくは@code{false}に評価します。

@code{is}に加えて、他のいくつかの演算子が@code{=}と@code{#}を@code{true}もしくは@code{false}に評価します。@mref{if}, @mref{and}, @mref{or}, @mref{not}という演算子です。

述語論理式の評価規則のため
（特に、@code{not @var{expr}}は@var{expr}の評価を起こすため）、
@code{not @var{a} = @var{b}}は、@code{@var{a} # @var{b}}ではなく、
@code{is(@var{a} # @var{b})}と同値になります。

@mref{rhs}と@mref{lhs}は、それぞれ、等式、不等式の右辺と左辺を返します。

@mref{equal}や@mref{notequal}も参照してください。

例:

式@code{@var{a} = @var{b}}は、それ自身、未評価の等式であり、成り立つことも成り立たないこともあります。

@c ===beg===
@c eq_1 : a * x - 5 * y = 17;
@c eq_2 : b * x + 3 * y = 29;
@c solve ([eq_1, eq_2], [x, y]);
@c subst (%, [eq_1, eq_2]);
@c ratsimp (%);
@c ===end===
@example
(%i1) eq_1 : a * x - 5 * y = 17;
(%o1)                    a x - 5 y = 17
(%i2) eq_2 : b * x + 3 * y = 29;
(%o2)                    3 y + b x = 29
(%i3) solve ([eq_1, eq_2], [x, y]);
                        196         29 a - 17 b
(%o3)          [[x = ---------, y = -----------]]
                     5 b + 3 a       5 b + 3 a
(%i4) subst (%, [eq_1, eq_2]);
         196 a     5 (29 a - 17 b)
(%o4) [--------- - --------------- = 17, 
       5 b + 3 a      5 b + 3 a
                                  196 b     3 (29 a - 17 b)
                                --------- + --------------- = 29]
                                5 b + 3 a      5 b + 3 a
(%i5) ratsimp (%);
(%o5)                  [17 = 17, 29 = 29]
@end example

@code{is(@var{a} = @var{b})}は、
@var{a}と@var{b}が構文法的に等しい（すなわち、同一の）時
式は、同値だが構文法的に等しくないことがありえます。

@c ===beg===
@c a : (x + 1) * (x - 1);
@c b : x^2 - 1;
@c [is (a = b), is (a # b)];
@c [is (equal (a, b)), is (notequal (a, b))];
@c ===end===
@example
(%i1) a : (x + 1) * (x - 1);
(%o1)                    (x - 1) (x + 1)
(%i2) b : x^2 - 1;
                              2
(%o2)                        x  - 1
(%i3) [is (a = b), is (a # b)];
(%o3)                     [false, true]
(%i4) [is (equal (a, b)), is (notequal (a, b))];
(%o4)                     [true, false]
@end example

いくつかの演算子は、@code{=}と@code{#}を@code{true}もしくは@code{false}に評価します。

@c ===beg===
@c if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else 
@c       BAR;
@c eq_3 : 2 * x = 3 * x;
@c eq_4 : exp (2) = %e^2;
@c [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
@c ===end===
@example
(%i1) if expand ((x + y)^2) = x^2 + 2 * x * y + y^2 then FOO else
      BAR;
(%o1)                          FOO
(%i2) eq_3 : 2 * x = 3 * x;
(%o2)                       2 x = 3 x
(%i3) eq_4 : exp (2) = %e^2;
                              2     2
(%o3)                       %e  = %e
(%i4) [eq_3 and eq_4, eq_3 or eq_4, not eq_3];
(%o4)                  [false, true, true]
@end example

@code{not @var{expr}}は@var{expr}の評価をするので、
@code{not @var{a} = @var{b}}は、@code{is(@var{a} # @var{b})}と同値です。

@c ===beg===
@c [2 * x # 3 * x, not (2 * x = 3 * x)];
@c is (2 * x # 3 * x);
@c ===end===
@example
(%i1) [2 * x # 3 * x, not (2 * x = 3 * x)];
(%o1)                   [2 x # 3 x, true]
(%i2) is (2 * x # 3 * x);
(%o2)                         true
@end example

@opencatbox
@category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node Assignment operators, User defined operators, Operators for Equations, Operators
@section Assignment operators
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{:}
@deffn {演算子} :
@ifinfo
@fnindex 割り当て演算子
@end ifinfo

割り当て演算子。

左辺が（添字のない）単純変数の時、 @code{:}は右辺を評価し、その値を左辺に関連づけます。

左辺がリストや行列、宣言されたMaxima配列、Lisp配列の添字指定された要素の時、
右辺がその要素に割り当てられます。
添字は存在している要素を示していなければなりません;
先に列挙した対象は、存在していない要素を名付けることで拡張することはできません。

左辺が未宣言のMaxima配列の添字指定された要素の時、
もし既に存在しているなら、右辺はその要素に割り当てられ、
もしまだ存在していなければ新しい要素が確保されます。

左辺が単純変数や添字あり変数のリストの時、
右辺はリストに評価されなければなりません。
そして、右辺の要素が左辺の要素に平行に割り当てられます。

@mref{kill}や@mref{remvalue}も参照してください。
それらは左辺とその値の関連をアンドゥします。

例:

単純変数への割り当て

@c ===beg===
@c a;
@c a : 123;
@c a;
@c ===end===
@example
(%i1) a;
(%o1)                           a
(%i2) a : 123;
(%o2)                          123
(%i3) a;
(%o3)                          123
@end example

リストの要素への割り当て

@c ===beg===
@c b : [1, 2, 3];
@c b[3] : 456;
@c b;
@c ===end===
@example
(%i1) b : [1, 2, 3];
(%o1)                       [1, 2, 3]
(%i2) b[3] : 456;
(%o2)                          456
(%i3) b;
(%o3)                      [1, 2, 456]
@end example

割り当ては未宣言配列を生成する。

@c ===beg===
@c c[99] : 789;
@c c[99];
@c c;
@c arrayinfo (c);
@c listarray (c);
@c ===end===
@example
(%i1) c[99] : 789;
(%o1)                          789
(%i2) c[99];
(%o2)                          789
(%i3) c;
(%o3)                           c
(%i4) arrayinfo (c);
(%o4)                   [hashed, 1, [99]]
(%i5) listarray (c);
(%o5)                         [789]
@end example

多重割り当て

@c ===beg===
@c [a, b, c] : [45, 67, 89];
@c a;
@c b;
@c c;
@c ===end===
@example
(%i1) [a, b, c] : [45, 67, 89];
(%o1)                     [45, 67, 89]
(%i2) a;
(%o2)                          45
(%i3) b;
(%o3)                          67
(%i4) c;
(%o4)                          89
@end example

多重割り当ては平行に実行されます。
この例では@code{a}と@code{b}の値が置換されます。

@c ===beg===
@c [a, b] : [33, 55];
@c [a, b] : [b, a];
@c a;
@c b;
@c ===end===
@example
(%i1) [a, b] : [33, 55];
(%o1)                       [33, 55]
(%i2) [a, b] : [b, a];
(%o2)                       [55, 33]
(%i3) a;
(%o3)                          55
(%i4) b;
(%o4)                          33
@end example

@opencatbox
@category{Evaluation} @category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@need 900
@anchor{::}
@deffn {演算子} ::
@ifinfo
@fnindex 割り当て演算子 (左辺を評価する)
@end ifinfo

割り当て演算子。

@code{::}は、@code{::}は右辺はもちろん左辺も評価することを除いて、@mref{:}と同じです。

例:

@c ===beg===
@c x : 'foo;
@c x :: 123;
@c foo;
@c x : '[a, b, c];
@c x :: [11, 22, 33];
@c a;
@c b;
@c c;
@c ===end===
@example
(%i1) x : 'foo;
(%o1)                          foo
(%i2) x :: 123;
(%o2)                          123
(%i3) foo;
(%o3)                          123
(%i4) x : '[a, b, c];
(%o4)                       [a, b, c]
(%i5) x :: [11, 22, 33];
(%o5)                     [11, 22, 33]
(%i6) a;
(%o6)                          11
(%i7) b;
(%o7)                          22
(%i8) c;
(%o8)                          33
@end example

@opencatbox
@category{Evaluation} @category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{::=}
@deffn {演算子} ::=
@ifinfo
@fnindex マクロ関数定義の演算子
@end ifinfo

マクロ関数定義の演算子。
@code{::=}は、引数をクォートする関数（歴史的理由によりマクロと呼ばれる）を定義します。
そして、それが返す式（マクロ展開と呼ばれる）はマクロが呼ばれた文脈の中で評価されます。
それ以外はマクロ関数は通常の関数と同じです。

@mref{macroexpand}は（評価せずに）マクロ展開を返します。
@code{foo}がマクロ関数の時、
@code{macroexpand (foo (x))}に続けて @code{``%}を実行すると、
それは @code{foo (x)}と同値です。

@code{::=}は、新しいマクロ関数の名前をグローバルリスト @mref{macros}に追加します。
@mref{kill}や @mref{remove}, @mref{remfunction}は、マクロ関数定義をアンバインドし、
@code{macros}から名前を削除します。

@mref{fundef}や @mref{dispfun}はそれぞれマクロ関数定義を返し、
それをラベルに割り当てます。

評価対象となる式を構成するために、
マクロ関数は一般的に@mref{buildq}, @mref{splice}式を含みます。

例

マクロ関数は引数をクォートします。
だから、メッセージ(1)は @code{y - z}の値ではなく、 @code{y - z}を示します。
マクロ展開（クォートされた式 @code{'(print ("(2) x is equal to", x)}）は、
マクロが呼ばれた文脈（表示メッセージ(2)）の中で評価されます。

@c ===beg===
@c x: %pi$
@c y: 1234$
@c z: 1729 * w$
@c printq1 (x) ::= block (print ("(1) x is equal to", x), 
@c                                 '(print ("(2) x is equal to", x)))$
@c printq1 (y - z);
@c ===end===
@example
(%i1) x: %pi$
(%i2) y: 1234$
(%i3) z: 1729 * w$
(%i4) printq1 (x) ::= block (print ("(1) x is equal to", x),
      '(print ("(2) x is equal to", x)))$
(%i5) printq1 (y - z);
(1) x is equal to y - z
(2) x is equal to %pi
(%o5)                                 %pi
@end example

通常の関数は引数を評価します。だから、メッセージ(1)は @code{y - z}の値を示します。
戻り値は評価されず、従って、メッセージ(2)は @code{``%}で陽に評価されるまで出力されません。

@c ===beg===
@c x: %pi$
@c y: 1234$
@c z: 1729 * w$
@c printe1 (x) := block (print ("(1) x is equal to", x), 
@c       '(print ("(2) x is equal to", x)))$
@c printe1 (y - z);
@c ''%;
@c ===end===
@example
(%i1) x: %pi$
(%i2) y: 1234$
(%i3) z: 1729 * w$
(%i4) printe1 (x) := block (print ("(1) x is equal to", x),
      '(print ("(2) x is equal to", x)))$
(%i5) printe1 (y - z);
(1) x is equal to 1234 - 1729 w
(%o5)                     print((2) x is equal to, x)
(%i6) ''%;
(2) x is equal to %pi
(%o6)                                 %pi
@end example

@code{macroexpand}はマクロ展開を返します。
@code{foo}がマクロ関数の時、
@code{macroexpand (foo (x))}の後 @code{``%}を実行すると、@code{foo (x)}と同値です。

@c ===beg===
@c x: %pi$
@c y: 1234$
@c z: 1729 * w$
@c g (x) ::= buildq ([x], print ("x is equal to", x))$
@c macroexpand (g (y - z));
@c ''%;
@c g (y - z);
@c ===end===
@example
(%i1) x: %pi$
(%i2) y: 1234$
(%i3) z: 1729 * w$
(%i4) g (x) ::= buildq ([x], print ("x is equal to", x))$
(%i5) macroexpand (g (y - z));
(%o5)                     print(x is equal to, y - z)
(%i6) ''%;
x is equal to 1234 - 1729 w
(%o6)                            1234 - 1729 w
(%i7) g (y - z);
x is equal to 1234 - 1729 w
(%o7)                            1234 - 1729 w
@end example

@opencatbox
@category{Function definition} @category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{:=}
@deffn {演算子} :=
@ifinfo
@fnindex 関数定義演算子
@end ifinfo

関数定義の演算子。
@code{f(@var{x_1}, .., @var{x_n}) := @var{expr}}は、
引数が@var{x_1}, ..., @var{x_n}で関数本体が@var{expr}の、@var{f}という名前の関数を定義します。
@code{:=}は（クォートクォート@code{`@w{}`}で陽に評価されない限り）関数本体は評価しません。
定義される関数は（引数をかっこでくくる）通常のMaxima関数か、（引数をかぎかっこでくくる）配列関数です。

最後の引数@var{x_n}が要素１つのリストの時、@code{:=}で定義された関数は可変の数の引数をとります。
実際の引数は、形式的な引数@var{x_1}, @dots{}, @var{x_(n - 1)}に一対一に割り当てられ、
さらに引数があれば、@var{x_n}にリストとして割り当てられます。

関数定義すべては、同じ名前空間を使います;
別の関数@code{g}の中で関数@code{f}を定義することは、@code{f}のスコープを@code{g}に限定しません。
しかし、@code{local(f)}は、関数@code{f}の定義を@mref{local}が現れたブロックや他の合成式内に限定します。

もしある形式引数@var{x_k}がクォートされたシンボルなら、@code{:=}で定義された関数は対応する実際の引数を評価しません。
それ以外の場合、実際の引数はすべて評価されます。

@mref{define}や@mref{::=}も参照してください。

例:

@code{:=}は（クォートクォートで陽に評価されない限り）関数本体を評価しません。

@c ===beg===
@c expr : cos(y) - sin(x);
@c F1 (x, y) := expr;
@c F1 (a, b);
@c F2 (x, y) := ''expr;
@c F2 (a, b);
@c ===end===
@example
(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) F1 (x, y) := expr;
(%o2)                   F1(x, y) := expr
(%i3) F1 (a, b);
(%o3)                    cos(y) - sin(x)
(%i4) F2 (x, y) := ''expr;
(%o4)              F2(x, y) := cos(y) - sin(x)
(%i5) F2 (a, b);
(%o5)                    cos(b) - sin(a)
@end example

@code{:=}で定義された関数は、通常のMaxima関数か、配列関数です。

@c ===beg===
@c G1 (x, y) := x.y - y.x;
@c G2 [x, y] := x.y - y.x;
@c ===end===
@example
(%i1) G1 (x, y) := x.y - y.x;
(%o1)               G1(x, y) := x . y - y . x
(%i2) G2 [x, y] := x.y - y.x;
(%o2)                G2     := x . y - y . x
                       x, y
@end example

最後の引数@var{x_n}が要素１つのリストの時、
@code{:=}で定義された関数は、可変の数の引数を取ります。

@c ===beg===
@c H ([L]) := apply ("+", L);
@c H (a, b, c);
@c ===end===
@example
(%i1) H ([L]) := apply ("+", L);
(%o1)                H([L]) := apply("+", L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
@end example

@code{local}はローカル関数定義を可能にします。

@c ===beg===
@c foo (x) := 1 - x;
@c foo (100);
@c block (local (foo), foo (x) := 2 * x, foo (100));
@c foo (100);
@c ===end===
@example
(%i1) foo (x) := 1 - x;
(%o1)                    foo(x) := 1 - x
(%i2) foo (100);
(%o2)                         - 99
(%i3) block (local (foo), foo (x) := 2 * x, foo (100));
(%o3)                          200
(%i4) foo (100);
(%o4)                         - 99
@end example

@opencatbox
@category{Function definition} @category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@node User defined operators, , Assignment operators, Operators
@section User defined operators
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{infix}
@deffn  {関数} infix (@var{op})
@deffnx {関数} infix (@var{op}, @var{lbp}, @var{rbp})
@deffnx {関数} infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})

@var{op}を中置演算子に宣言します。
中置演算子は２つの引数の関数で、引数の間に関数名が来ます。
例えば、引き算演算子@code{-}は中置演算子です。

@code{infix (@var{op})}は、デフォルトの結合力（左右両方とも180）と品詞
（左右両方とも@code{any})に等しい）で@var{op}を中置演算子に宣言します。
@c HOW IS pos DIFFERENT FROM lpos AND rpos ??

@code{infix (@var{op}, @var{lbp}, @var{rbp})}は、
記述された左右の結合力
とデフォルトの品詞（左右両方とも@code{any})に等しい）で、
@var{op}を中置演算子に宣言します。

@code{infix (@var{op}, @var{lbp}, @var{rbp}, @var{lpos}, @var{rpos}, @var{pos})}は、
記述された左右の結合力と、
左オペランド、右オペランド、演算子結果それぞれについて、
品詞を@var{lpos}, @var{rpos}, @var{pos}に設定して、
@var{op}を中置演算子に宣言します。

（演算子宣言に関係して）「品詞」は、式のタイプを意味します。
３つのタイプが認識されます; @code{expr}, @code{clause}, @code{any}。それぞれは、
代数式、ブーリアン式、任意の種類の式を示します。
Maximaは、宣言された品詞を実際の式に比較することで、
いくつかの構文法エラーを検出します。

他の演算子に関する@var{op}の優先順位は、問題となっている演算子の左右結合力から演繹されます。
もし@var{op}の左右結合力のどちらもある他の演算子の左右結合力より大きいなら、
@var{op}は、他の演算子より高い優先順位をとります。
もし結合力がどちらも大きくも、どちらも小さくもなければ、
あるもっと複雑な関係が成り立ちます。

@var{op}の結合性は結合力に依存します。
より大きな左結合力(@var{lbp})は、@var{op}のインスタンスが
式の中で左にある他の演算子の前に評価されることを示し、
より大きな右結合力(@var{rbp})は、@var{op}のインスタンスが
式の中で右にある他の演算子の前に評価されることを示します。
このように、より大きな@var{lbp}は@var{op}を右結合にし、
より大きな@var{rbp}は@var{op}を左結合にします。
もし@var{lbp}が@var{rbp}と等しいなら、
@var{op}は左結合です。

@code{Syntax}も参照してください。

例:

もし@var{op}左右結合力それぞれが、他の演算子のそれより大きいなら、
@var{op}は他の演算子より高い優先順位をとります。

@c ===beg===
@c :lisp (get '$+ 'lbp)
@c :lisp (get '$+ 'rbp)
@c infix ("##", 101, 101);
@c "##"(a, b) := sconcat("(", a, ",", b, ")");
@c 1 + a ## b + 2;
@c infix ("##", 99, 99);
@c 1 + a ## b + 2;
@c ===end===
@example
(%i1) :lisp (get '$+ 'lbp)
100
(%i1) :lisp (get '$+ 'rbp)
100
(%i1) infix ("##", 101, 101);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")");
(%o2)       (a ## b) := sconcat("(", a, ",", b, ")")
(%i3) 1 + a ## b + 2;
(%o3)                       (a,b) + 3
(%i4) infix ("##", 99, 99);
(%o4)                          ##
(%i5) 1 + a ## b + 2;
(%o5)                       (a+1,b+2)
@end example

より大きな@var{lbp}は@var{op}を右結合にし、
より大きな@var{rbp}は@var{op}を左結合にします。

@c ===beg===
@c infix ("##", 100, 99);
@c "##"(a, b) := sconcat("(", a, ",", b, ")")$
@c foo ## bar ## baz;
@c infix ("##", 100, 101);
@c foo ## bar ## baz;
@c ===end===
@example
(%i1) infix ("##", 100, 99);
(%o1)                          ##
(%i2) "##"(a, b) := sconcat("(", a, ",", b, ")")$
(%i3) foo ## bar ## baz;
(%o3)                    (foo,(bar,baz))
(%i4) infix ("##", 100, 101);
(%o4)                          ##
(%i5) foo ## bar ## baz;
(%o5)                    ((foo,bar),baz)
@end example

Maximaは、宣言された品詞を実際の式と比較することで、
いくつかの構文法エラーを検出します。

@c ===beg===
@c infix ("##", 100, 99, expr, expr, expr);
@c if x ## y then 1 else 0;
@c infix ("##", 100, 99, expr, expr, clause);
@c if x ## y then 1 else 0;
@c ===end===
@example
(%i1) infix ("##", 100, 99, expr, expr, expr);
(%o1)                          ##
(%i2) if x ## y then 1 else 0;
Incorrect syntax: Found algebraic expression where logical
expression expected
if x ## y then 
             ^
(%i2) infix ("##", 100, 99, expr, expr, clause);
(%o2)                          ##
(%i3) if x ## y then 1 else 0;
(%o3)                if x ## y then 1 else 0
@end example

@opencatbox
@category{Operators} @category{Declarations and inferences} @category{Syntax}
@closecatbox

@end deffn

@c -----------------------------------------------------------------------------
@anchor{matchfix}
@deffn  {関数} matchfix (@var{ldelimiter}, @var{rdelimiter})
@deffnx {関数} matchfix (@var{ldelimiter}, @var{rdelimiter}, @var{arg_pos}, @var{pos})

左と右の区切り記号@var{ldelimiter}と@var{rdelimiter}を持つ
matchfix演算子を宣言します
区切り記号は文字列として指定されます。

"matchfix"演算子は、
任意の数の引数の関数で、引数は左と右の区切り記号をマッチする間で現れます。
パーサがオペランドや他の式や演算子から区切り記号を区別できる限り
区切り記号は任意の文字列を取り得ます。
実際には、これは、@code{%}, @code{,}, @code{$}, @code{;}のような
パースできない区切り記号を除外し、空白を持つ区切り記号を分離することを要求するかもしれません。
右区切り記号は、左区切り記号と同じかもしれませんし、違うかもしれません。

左区切り記号は、たった１つの右区切り記号と関連づけられることができます;
２つの異なるmatchfix演算子は同じ左区切り記号を持つことはできません。

存在する演算子は、
他のプロパティを変えることなく、
matchfix演算子として再宣言することができます。
特に、足し算@code{+}のような組み込み演算子が
matchfixに宣言されることが可能ですが、
演算子関数は組み込み演算子に関して定義できません。

コマンド@code{matchfix (@var{ldelimiter}, @var{rdelimiter}, @var{arg_pos},
@var{pos})} は、
引数品詞@var{arg_pos}と結果品詞@var{pos}、区切り記号
@var{ldelimiter}と@var{rdelimiter}を宣言します。

演算子宣言に関して、「品詞」は式のタイプを意味します。
３つのタイプが認識されます: 
それぞれ、代数式、ブーリアン式、任意の種類の式を示す、
@code{expr}, @code{clause}, @code{any}。
Maximaは、
宣言された品詞を実際の式と比較することで、
いくつかの構文法エラーを検知します。

@c DUNNO IF WE REALLY NEED TO MENTION BINDING POWER HERE -- AS NOTED IT'S IRRELEVANT
@c An operator declared by @code{matchfix} is assigned a low binding power.
@c Since a matchfix operator must be evaluated before any expression
@c which contains it,
@c binding power is effectively irrelevant
@c to the declaration of a matchfix operator.

matchfix演算を実行する関数は通常のユーザー定義関数です。
演算子関数は、
関数定義演算子@code{:=}や@code{define}を使って
普通の方法で定義されます。
引数は、区切り記号の間に書かれるか、
クォートされた文字列としての左区切り記号と括弧の中で続く引数を使って書かれます。
@code{dispfun (@var{ldelimiter})}は関数定義を表示します。

唯一の組み込みmatchfix演算子はリスト構成子@code{[ ]}です。
括弧@code{( )}とダブルクォート@code{" "}はmatchfix演算子のように振る舞いますが、
Maximaパーサによってそのようには扱われません。

@code{matchfix}は引数を評価します。
@code{matchfix}は最初の引数@var{ldelimiter}を返します。
@c HOW TO TAKE AWAY THE MATCHFIX PROPERTY ??

例:

区切り記号はほとんど任意の文字列を取り得ます。

@c ===beg===
@c matchfix ("@@", "~");
@c @@ a, b, c ~;
@c matchfix (">>", "<<");
@c >> a, b, c <<;
@c matchfix ("foo", "oof");
@c foo a, b, c oof;
@c >> w + foo x, y oof + z << / @@ p, q ~;
@c ===end===
@example
(%i1) matchfix ("@@@@", "~");
(%o1)                          @@@@
(%i2) @@@@ a, b, c ~;
(%o2)                      @@@@a, b, c~
(%i3) matchfix (">>", "<<");
(%o3)                          >>
(%i4) >> a, b, c <<;
(%o4)                      >>a, b, c<<
(%i5) matchfix ("foo", "oof");
(%o5)                          foo
(%i6) foo a, b, c oof;
(%o6)                     fooa, b, coof
(%i7) >> w + foo x, y oof + z << / @@@@ p, q ~;
                     >>z + foox, yoof + w<<
(%o7)                ----------------------
                            @@@@p, q~
@end example

Matchfix演算子は通常のユーザー定義関数です。

@example
(%i1) matchfix ("!-", "-!");
(%o1)                         "!-"
(%i2) !- x, y -! := x/y - y/x;
                                    x   y
(%o2)                   !-x, y-! := - - -
                                    y   x
(%i3) define (!-x, y-!, x/y - y/x);
                                    x   y
(%o3)                   !-x, y-! := - - -
                                    y   x
(%i4) define ("!-" (x, y), x/y - y/x);
                                    x   y
(%o4)                   !-x, y-! := - - -
                                    y   x
(%i5) dispfun ("!-");
                                    x   y
(%t5)                   !-x, y-! := - - -
                                    y   x

(%o5)                         done
(%i6) !-3, 5-!;
                                16
(%o6)                         - --
                                15
(%i7) "!-" (3, 5);
                                16
(%o7)                         - --
                                15
@end example

@opencatbox
@category{Syntax} @category{Operators}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{operator_nary}
@deffn  {関数} nary (@var{op})
@deffnx {関数} nary (@var{op}, @var{bp}, @var{arg_pos}, @var{pos})

@code{nary}演算子は
任意の数の引数の関数を示すのに使われます。
引数それぞれは、例えば、A+BやA+B+Cように演算子の出現で分離されます。
@code{nary("x")}関数は
@code{x}を @code{nary}演算子に宣言する構文拡張関数です。
関数は @code{nary}であると宣言されるかもしれません。
もし @code{declare(j,nary);}が実行されたら、
これは整理器に
例えば、@code{j(j(a,b),j(c,d))}を @code{j(a, b, c, d)}に整理するよう指示します。

@ref{Introduction to operators}も参照してください。

@opencatbox
@category{Operators} @category{Syntax}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{nofix}
@deffn  {関数} nofix (@var{op})
@deffnx {関数} nofix (@var{op}, @var{pos})

@code{nofix}演算子は引数のない関数を示すのに使われます。
コマンドにそんな演算子が存在すると、
対応する関数が評価されるだけです。
例えば、Maximaブレイクから抜けるために"exit;"とタイプする時、
"exit"は@code{nofix}演算子と似たように振る舞います。
関数 @code{nofix("x")}は
@code{x}を @code{nofix}演算子に宣言する構文拡張関数です。

@ref{Introduction to operators}も参照してください。

@opencatbox
@category{Operators} @category{Syntax}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{postfix}
@deffn  {関数} postfix (@var{op})
@deffnx {関数} postfix (@var{op}, @var{lbp}, @var{lpos}, @var{pos})

@code{prefix}変種のような@code{postfix}演算子は引数一つの関数を示しますが、
この場合、例えば3!のように、入力文字列の中で引数が演算子に先行します。
@code{postfix("x")}関数は @code{x}を@code{postfix}演算子に宣言する構文拡張関数です。

@ref{Introduction to operators}も参照してください。

@opencatbox
@category{Operators} @category{Syntax}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{prefix}
@deffn  {関数} prefix (@var{op})
@deffnx {関数} prefix (@var{op}, @var{rbp}, @var{rpos}, @var{pos})

@code{prefix}演算子は引数一つの関数であり、
その引数は演算子のすぐ後ろに置かれます。
@code{prefix("x")}は @code{x}を@code{prefix}演算子に宣言する構文拡張関数です。

@ref{Introduction to operators}も参照してください。

@opencatbox
@category{Operators} @category{Syntax}
@closecatbox
@end deffn
