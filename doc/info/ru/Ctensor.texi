@c Language=Russian
@c Encoding=CP1251
@c File=Ctensor.texi 
@c OriginalRevision=1.33


@menu
* Введение в пакет ctensor::
* Функции и переменные пакета ctensor::
@end menu

@node Введение в пакет ctensor, Функции и переменные пакета ctensor, Пакет ctensor, Пакет ctensor
@section Введение в пакет ctensor

Пакет @code{ctensor} предназначен для операций с компонентами тензоров.
Для загрузки @code{ctensor} необходимо ввести команду
@code{load(ctensor)}.  Стандартная интерактивная
сессия в @code{ctensor} начинается с команды @code{csetup()}.  После этого
пользователь запрашивается о размерности многообразия.  Если размерность
равна 2, 3 или 4, тогда список координат по умолчанию устанавливается
равным @code{[x,y]}, @code{[x,y,z]} или @code{[x,y,z,t]} соответственно.
Имена координат могут быть изменены присваиванием нового
списка координат переменной @code{ct_coords} (см. ниже), пользователь
также запрашивается о необходимости переопределения списка координат.
Следует внимательно выбирать имена координат таким образом, чтобы
избежать конфликтов с другими объектами.

После этого пользователь задает метрику непосредственно, либо
указывая файл в котром она находится.
@c NO SUCH FILE !
Файл @code{share/tensor/metrics.mac} содержит определения некоторых
стандартных метрик. Метрика хранится в матрице @code{lg}.
Обратная метрика вычисляется и помещается в матрицу @code{ug}.
При определении метрики существует возможность использования степенных рядов.

Ниже приведено начало протокола определения статической,
сферически-симметричной метрики (стандартные координаты)
с целью вычисления вакуумных уравнений Эйнштейна,
приводящих к решению Шварцшильда.  Многие функции пакета
@code{ctensor} будут продемонстрированы на примере этой метрики.

@example
(%i1) load(ctensor);
(%o1)      /usr/local/lib/maxima/share/tensor/ctensor.mac
(%i2) csetup();
Enter the dimension of the coordinate system:
4;
Do you wish to change the coordinate names?
n;
Do you want to
1. Enter a new metric?

2. Enter a metric from a file?

3. Approximate a metric with a Taylor series?
1;

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;
Row 1 Column 1:
a;
Row 2 Column 2:
x^2;
Row 3 Column 3:
x^2*sin(y)^2;
Row 4 Column 4:
-d;

Matrix entered.
Enter functional dependencies with the DEPENDS function or 'N' if none
depends([a,d],x);
Do you wish to see the metric?
y;
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
                          [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%o2)                                done
(%i3) christof(mcs);
                                            a
                                             x
(%t3)                          mcs        = ---
                                  1, 1, 1   2 a

                                             1
(%t4)                           mcs        = -
                                   1, 2, 2   x

                                             1
(%t5)                           mcs        = -
                                   1, 3, 3   x

                                            d
                                             x
(%t6)                          mcs        = ---
                                  1, 4, 4   2 d

                                              x
(%t7)                          mcs        = - -
                                  2, 2, 1     a

                                           cos(y)
(%t8)                         mcs        = ------
                                 2, 3, 3   sin(y)

                                               2
                                          x sin (y)
(%t9)                      mcs        = - ---------
                              3, 3, 1         a

(%t10)                   mcs        = - cos(y) sin(y)
                            3, 3, 2

                                            d
                                             x
(%t11)                         mcs        = ---
                                  4, 4, 1   2 a
(%o11)                               done

@end example


@node Функции и переменные пакета ctensor,  , Введение в пакет ctensor, Пакет ctensor

@section Функции и переменные пакета ctensor

@subsection Начальные установки

@deffn {Функция} csetup ()
Эта функция производит начальные установки пакета @code{ctensor}
и позволяет пользователю ввести метрику интерактивно.
См. @code{ctensor} для более подробного описания.
@end deffn

@deffn {Функция} cmetric (@var{dis})
@deffnx {Функция} cmetric ()
Функция пакета @code{ctensor}, которая вычисляет обратную
метрику и готовит пакет к проведению дальнейших вычислений.

Если переключатель @code{cframe_flag} равен @code{false}, то функция
вычисляет обратную метрику @code{ug} исходя из заданной пользователем
матрицы @code{lg}.  Определитель метрики тоже вычисляется и
сохраняется в переменной @code{gdet}.  Боле того, программа определяет
является ли метрика диагональной и соответственным образом
устанавливает значение ключа @code{diagmetric}.  Если задан необязательный
ключ @var{dis} и его значение не равно @code{false}, то в ходе сессии
пользователь запрашивается требуется ли распечатать компоненты обратной
метрики на экран.

Если ключ @code{cframe_flag} равен @code{true}, тогда ожидается, что
заданы значения @code{fri} (матрица обратного базиса) и массив @code{lfg}
(метрика относительно данного базиса).  Исходя из этих данных
вычисляются матрица @code{fr} и обратная метрика @code{ufg}
относительно заданного базиса.

@end deffn

@deffn {Функция} ct_coordsys (@var{coordinate_system}, @var{extra_arg})
@deffnx {Функция} ct_coordsys (@var{coordinate_system})
Задает одну из предопределенных координатных систем и метрик.
Аргумент @var{coordinate_system} может принимать одно из следующих
значений:

@example

  Символ               Dim Координаты        Описание/комментарии
  --------------------------------------------------------------------------
  cartesian2d           2  [x,y]             Декартовы 2D координаты
  polar                 2  [r,phi]           Полярные координаты
  elliptic              2  [u,v]             Эллиптические координаты
  confocalelliptic      2  [u,v]             Конфокальные эллиптические
  bipolar               2  [u,v]             Биполярные координаты
  parabolic             2  [u,v]             Параболические координаты
  cartesian3d           3  [x,y,z]           Декартова 3D система координат
  polarcylindrical      3  [r,theta,z]       Цилиндрические координаты
  ellipticcylindrical   3  [u,v,z]           Эллиптические 2D с цилинром z
  confocalellipsoidal   3  [u,v,w]           Конфокальные эллипсоидальные
  bipolarcylindrical    3  [u,v,z]           Биполярные 2D с цилиндром z
  paraboliccylindrical  3  [u,v,z]           Параболические 2D с цилиндром z
  paraboloidal          3  [u,v,phi]         Параболоидные координаты
  conical               3  [u,v,w]           Конические координаты
  toroidal              3  [u,v,phi]         Тороидальные координаты
  spherical             3  [r,theta,phi]     Сферические координаты
  oblatespheroidal      3  [u,v,phi]         Сжатые сфероидальные
  oblatespheroidalsqrt  3  [u,v,phi]
  prolatespheroidal     3  [u,v,phi]         Вытянутые сфероидальные
  prolatespheroidalsqrt 3  [u,v,phi]
  ellipsoidal           3  [r,theta,phi]     Эллипсоидальные координаты
  cartesian4d           4  [x,y,z,t]         Декартовы 4D координаты
  spherical4d           4  [r,theta,eta,phi] Сферические 4D координаты
  exteriorschwarzschild 4  [t,r,theta,phi]   Метрика Шварцшильда
  interiorschwarzschild 4  [t,z,u,v]         Внутреняя метрика Шрарцшильда
  kerr_newman           4  [t,r,theta,phi]   Метрика Керра-Ньюмана

@end example

@code{coordinate_system} может быть списком функций преобразования,
за которым следует список координат.  Например,
можно задать метрику следующим образом:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o2)                                done
(%i3) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o3)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
(%i4) ct_coords;
(%o4)                           [r, theta, phi]
(%i5) dim;
(%o5)                                  3

@end example

Функции преобразования могут также использоваться и в случае,
когда @code{cframe_flag} равно @code{true}:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) cframe_flag:true;
(%o2)                                true
(%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o3)                                done
(%i4) fri;
      [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
      [                                                                       ]
(%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
      [                                                                       ]
      [     sin(theta)            r cos(theta)                   0            ]
(%i5) cmetric();
(%o5)                                false
(%i6) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o6)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]

@end example

Необязательный аргумент @var{extra_arg} может принимать одно из
следующих значений:
@c LOOKING AT share/tensor/ctensor.mac CIRCA LINE 837, misner IS RECOGNIZED ALSO; WHAT EFFECT DOES IT HAVE ??

@code{cylindrical} указывает @code{ct_coordsys} добавить одну
дополнительную цилиндрическую координату.

@code{minkowski} указывает @code{ct_coordsys} добавить дополнительную
декартову координату с отрицательной сигнатурой.

@code{all} указывает @code{ct_coordsys}, что после определения метрики
необходимо вызвать @code{cmetric} и @code{christof(false)}.

@c GLOBAL VARIABLE verbose IS USED IN ctensor.mac IN JUST THIS ONE CONTEXT
Если глобальная переменная @code{verbose} равна @code{true},
то @code{ct_coordsys} выводит значения @code{dim}, @code{ct_coords}, и
или @code{lg} или @code{lfg} и @code{fri}, в зависимости от значения
@code{cframe_flag}.

@end deffn

@deffn {Функция} init_ctensor ()
Инициализирует пакет @code{ctensor}.

Функция @code{init_ctensor} ре-инициализирует пакет
@code{ctensor}, при этом из памяти удаляются все использованные ранее пакетом @code{ctensor}
массивы и матрицы и восстанавливаются стандартные значения всех
ключей, в том числе: размерность многообразия, @code{dim},
устанавливается равной 4, а метрика устанавливается равной метрике Лоренца.

@end deffn


@subsection Тензоры искривленного пространства

Основное назначение пакета @code{ctensor} -- вычисление различных
тензоров для искривленного пространства-времени, в основном
тензоров, использующихся в общей теории относительности.

При использовании голономного (координатного) базиса @code{ctensor} может вычислить
следующие объекты:

@example

 lg  -- ug
   \      \
    lcs -- mcs -- ric -- uric
              \      \       \
               \      tracer - ein -- lein
                \
                 riem -- lriem -- weyl
                     \
                      uriem


@end example

@code{ctensor} может также работать при неголономном базисе (тетрадный формализм).
Когда @code{cframe_flag} равно @code{true}, следующие
объекты могут быть вычислены:

@example

 lfg -- ufg
     \
 fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
      \                       |  \      \       \
       lg -- ug               |   weyl   tracer - ein -- lein
                              |\
                              | riem
                              |
                              \uriem

@end example

@deffn {Функция} christof (@var{dis})
Функция пакета @code{ctensor}, вычисляющая символы Кристоффеля
первого и второго родов.   Аргумент @var{dis} определяет какой
результат должен быть отображен.
Символы Кристоффеля первого и второго рода хранятся в массивах
@code{lcs[i,j,k]} и @code{mcs[i,j,k]} соответственно и считается
симметричным по первой паре индексов.  Если аргумент
@code{christof} есть @code{lcs} или @code{mcs} то будут выведены
все уникальные (симметрия) ненулевые значения @code{lcs[i,j,k]}
или @code{mcs[i,j,k]}, соответственно.  Если аргумент равен
@code{all}, тогда печатаются уникальные ненулевые значения
как @code{lcs[i,j,k]} и @code{mcs[i,j,k]}.
Если аргумент равен @code{false}, то ни какие значения не
отображаются.  Массив @code{mcs[i,j,k]} определен таким образом,
что последний индекс является контравариантным.

@end deffn

@deffn {Функция} ricci (@var{dis})
Функция пакета @code{ctensor}, вычисляющая ковариантные
(симметричные) компоненты тензора Риччи @code{ric[i,j]}.
Если аргумент @var{dis} равен @code{true}, то на экран выводится печать
результатов вычисления ненулевых компонент тензора.

@end deffn

@deffn {Функция} uricci (@var{dis})
Эта функция сначала вычисляет ковариантные
компоненты тензора Риччи @code{ric[i,j]}.
Затем с помощью контравариантной метрики
вычисляется тензор Риччи со смешанными компонентами.
Если аргумент @var{dis} равен @code{true}, тогда смешанные
компоненты @code{uric[i,j]} (индекс @code{i} ковариантный,
а индекс @code{j} контравариантный), будут распечатаны.
При @code{ricci(false)} просто вычисляется массив @code{uric[i,j]}
без печати на экран.

@end deffn

@deffn {Функция} scurvature ()
Возвращает значение скалярной кривизны, получаемое
сверткой тензора кривизны Риччи.

@end deffn

@deffn {Функция} einstein (@var{dis})
Функция @code{einstein} вычисляет смешанный тензор Эйнштейна
после того как вычислены символы Кристоффеля и тензор Риччи
пи помощи функций @code{christof} и @code{ricci}.
Если аргумент @var{dis} равен @code{true}, тогда ненулевые компоненты
тензора Эйнштейна @code{ein[i,j]} будут напечатаны, где
индекс @code{j} является ковариантным.
Переключатель @code{rateinstein} вызывает рациональное упрощение
результирующих компонент.  Если @code{ratfac} равен @code{true}
тогда компоненты будут автоматически факторизованы.

@end deffn

@deffn {Функция} leinstein (@var{dis})
Вычисляет ковариантный тензор Эйнштейна. @code{leinstein} записывает
компоненты ковариантного тензора Эйнштейна в массив @code{lein}.
Контравариантные компоненты тензора Эйнштейна вычисляются исходя из
смешанного тензора Эйнштейна @code{ein}.  Если аргумент @var{dis}
равен  @code{true}, тогда ненулевые компоненты ковариантного тензора
Эйнштейна распечатываются на экране.

@end deffn

@deffn {Функция} riemann (@var{dis})
Функция @code{riemann} вычисляет тензор кривизны Римана используя
метрику и символы Кристоффеля.  При этом используются следующие
соглашения:

@example
                l      _l       _l       _l   _m    _l   _m
 R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                ijk     ij,k     ik,j     mk   ij    mj   ik
@end example

Эти обозначения совместимы с используемыми в пакете @code{itensor}
и его функцией @code{icurvature}.  Если необязательный
аргумент @var{dis} равен @code{true}, тогда
ненулевые компоненты тензора @code{riem[i,j,k,l]} печатаются на экране.
Как и для тензора Эйнштейна, управление процессом упрощения компонент тензора Римана
осуществляется при помощи различные переключателей(флагов).
Если @code{ratriemann} равен @code{true}, тогда
будет применено рациональное упрощение.
Если @code{ratfac} равен @code{true}, тогда каждая компонента
факторизуется.

Если @code{cframe_flag} равен @code{false}, тогда тензор Римана
вычисляется непосредственно исходя из символов Кристоффеля.
Если @code{cframe_flag} равен @code{true}, тогда сначала
вычисляется ковариантный тензор Римана исходя из компонент
неголономного базиса.

@end deffn

@deffn {Функция} lriemann (@var{dis})
Ковариантный тензор Римана (@code{lriem[]}).
Функция вычисляет ковариантный тензор Римана и заносит результаты в
массив @code{lriem}. Если флаг @var{dis} равен @code{true}, то
результаты вычислений уникальных ненулевых компонент тензора выводятся
на экран.

Если флаг @code{cframe_flag} равен @code{true}, то ковариантный тензор
Римана вычисляется напрямую по компонентам тетрады, если иначе, то
вначале вычисляется тензор Римана ранга (3,1).

Информация о порядке следования индексов подробнее освящена в пункте @code{riemann}.

@end deffn

@deffn {Функция} uriemann (@var{dis})
Вычисляет контравариантные компоненты тензора Римана и заносит их в
матрицу @code{uriem[i,j,k,l]}. Результаты вычислений печатаются на
экране если флаг @var{dis} равен @code{true}.

@end deffn

@deffn {Функция} rinvariant ()
Вычисляет инвариант Кречмана (Kretchmann) (@code{kinvariant}),
используя свертку тензоров. Например,

@example
lriem[i,j,k,l]*uriem[i,j,k,l].
@end example

Поскольку выражение может быть громоздким, то по умолчанию отключено
автоматическое упрощение результата вычисления инварианта.

@end deffn

@deffn {Функция} weyl (@var{dis})
Вычисляет конформный тензор Вейля.  Если флаг @var{dis} равен
@code{true} - на экране печатаются не нулевые компоненты
@code{weyl[i,j,k,l]}, если иначе, то результаты вычислений просто
заносятся в матрицу. Если ключ @code{ratweyl} равен @code{true}, тогда
производится автоматическое упрощение результата с использованием
алгебры рациональных чисел; при  @code{ratfac} равном @code{true}
результат вычислений автоматически факторизуется.

@end deffn

@subsection Разложение в ряды Тейлора

В пакете @code{ctensor} реализованы возможности упрощения результатов
вычислений если метрика апроксимирована рядом Тейлора. Для учета метрики
такого типа необходимо установить ключ @code{ctayswitch} равным
@code{true}. Данный ключ заставляет использовать при пакетных вычислениях
функцию @code{ctaylor} для упрощения результатов.

Функция @code{ctaylor} вызывается в следующих пакетных функциях @code{ctensor}:

@example

    Функция      Комментарий
    ---------------------------------
    christof()   Только для mcs
    ricci()
    uricci()
    einstein()
    riemann()
    weyl()
    checkdiv()

@end example

@deffn {Функция} ctaylor ()

Функция @code{ctaylor} преобразует выражения заданных аргументов конвертируя их в
Тейлоровские ряды, используя функцию @code{taylor}, и затем вызывая 
@code{ratdisrep}. Это приводит к отбрасыванию слагаемых высокого
порядка по переменной разложения @code{ctayvar}. Порядок отбрасываемых
членов определен переменной @code{ctaypov}; центральная точка окрестности
разложения определяется переменной @code{ctaypt}.

В качестве примера рассмотрим простую метрику , полученную в результате
возмущений метрики Минковского. Если не наложить ограничений, то даже
диагональная метрика в этом случае приводит к достаточно громоздким
выражениям тензора Эйнштейна:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) derivabbrev:true;
(%o3)                                true
(%i4) ct_coords:[t,r,theta,phi];
(%o4)                         [t, r, theta, phi]
(%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                        [ - 1  0  0         0        ]
                        [                            ]
                        [  0   1  0         0        ]
                        [                            ]
(%o5)                   [          2                 ]
                        [  0   0  r         0        ]
                        [                            ]
                        [              2    2        ]
                        [  0   0  0   r  sin (theta) ]
(%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                            [ h11   0    0    0  ]
                            [                    ]
                            [  0   h22   0    0  ]
(%o6)                       [                    ]
                            [  0    0   h33   0  ]
                            [                    ]
                            [  0    0    0   h44 ]
(%i7) depends(l,r);
(%o7)                               [l(r)]
(%i8) lg:lg+l*h;
         [ h11 l - 1      0          0                 0            ]
         [                                                          ]
         [     0      h22 l + 1      0                 0            ]
         [                                                          ]
(%o8)    [                        2                                 ]
         [     0          0      r  + h33 l            0            ]
         [                                                          ]
         [                                    2    2                ]
         [     0          0          0       r  sin (theta) + h44 l ]
(%i9) cmetric(false);
(%o9)                                done
(%i10) einstein(false);
(%o10)                               done
(%i11) ntermst(ein);
[[1, 1], 62]
[[1, 2], 0]
[[1, 3], 0]
[[1, 4], 0]
[[2, 1], 0]
[[2, 2], 24]
[[2, 3], 0]
[[2, 4], 0]
[[3, 1], 0]
[[3, 2], 0]
[[3, 3], 46]
[[3, 4], 0]
[[4, 1], 0]
[[4, 2], 0]
[[4, 3], 0]
[[4, 4], 46]
(%o12)                               done

@end example

Однако если считать что @code{l} мало и оставить только линейные члены
по  @code{l}, тогда получим намного более простое выражение для тензора Эйнштейна:

@example

(%i14) ctayswitch:true;
(%o14)                               true
(%i15) ctayvar:l;
(%o15)                                 l
(%i16) ctaypov:1;
(%o16)                                 1
(%i17) ctaypt:0;
(%o17)                                 0
(%i18) christof(false);
(%o18)                               done
(%i19) ricci(false);
(%o19)                               done
(%i20) einstein(false);
(%o20)                               done
(%i21) ntermst(ein);
[[1, 1], 6]
[[1, 2], 0]
[[1, 3], 0]
[[1, 4], 0]
[[2, 1], 0]
[[2, 2], 13]
[[2, 3], 2]
[[2, 4], 0]
[[3, 1], 0]
[[3, 2], 2]
[[3, 3], 9]
[[3, 4], 0]
[[4, 1], 0]
[[4, 2], 0]
[[4, 3], 0]
[[4, 4], 9]
(%o21)                               done
(%i22) ratsimp(ein[1,1]);
                         2      2  4               2     2
(%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                              r               r r

                                2               2      4    2
                  - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                           r r                r



@end example

Данное приближение полезно в пределе слабого поля, вдали от
гравитационных источников.

@end deffn


@subsection Неголономный базис

Если ключ @code{cframe_flag} равен @code{true}, то пакетные
вычисления выполняются с использованием тетрадного (неголономного в общем
случае) базиса.

@deffn {Функция} frame_bracket (@var{fr}, @var{fri}, @var{diagframe})
Скобка тетрады (@code{fb[]}).

Вычисляет скобку тетрады, следуя определению:

@example
   c          c         c        d     e
ifb   = ( ifri    - ifri    ) ifr   ifr
   ab         d,e       e,d      a     b
@end example

@end deffn

@subsection Алгебраическая классификация

Новой особенностью пакета @code{ctensor} (начиная с ноября 2004)
является возможность вычисления классификации Петрова 4-мерного
пространственно-временного многообразия.
Демонстрационные вычисления по данной теме представлены в  файле
@code{share/tensor/petrov.dem}.

@deffn {Функция} nptetrad ()
Вычисляет световую тетраду (@code{np}) Ньюмана-Пенроуза и связанную с ней
дуальную часть (@code{npi}), см. @code{petrov} для примера.

Световая тетрада конструируется с использованием 4-х мерного ортонормального
базиса метрики, обладающей сигнатурой  (-,+,+,+). Компоненты
световой тетрады связаны с обратной матрицей метрики следующими соотношениями:

@example

np  = (fri  + fri ) / sqrt(2)
  1       1      2

np  = (fri  - fri ) / sqrt(2)
  2       1      2

np  = (fri  + %i fri ) / sqrt(2)
  3       3         4

np  = (fri  - %i fri ) / sqrt(2)
  4       3         4

@end example

@end deffn

@deffn {Функция} psi (@var{dis})
Вычисляет пять коэффициентов Ньюмана-Пенроуза @code{psi[0]}...@code{psi[4]}.
Если @code{psi} равен @code{true}, эти коэффициенты печатаются на
экране, см пример в пункте @code{petrov}.

Коэффициенты вычисляются в координатном базисе из тензора Вейля.
Если при использовании тетрадного базиса, компоненты тензора Вейля предварительно
конвертируются в координатный базис. Эта процедура не оптимальна с
вычислительной точки зрения и поэтому перед вычислением тензора Вейля
предварительно рекомендуется задать координатный базис.
Заметим однако, что вычисления световой тетрады (@code{np})
Ньюмана-Пенроуза требует задания тетрадного базиса. Таким образом,
имеющая смысл схема вычислений в этом случае может состоять из следующих
этапов: вначале задается базис тетрады, который затем используется для
вычисления метрики @code{lg} (вычисляется автоматически при вызове @code{cmetric})
и обратной метрики @code{ug}; на этом этапе можно переключится обратно к
координатному базису установив ключ @code{cframe_flag} равным
@code{false} перед началом вычислений символов Кристоффеля.
Переход обратно к тетрадному базису на более поздних стадиях вычислений
может привести к несогласованным результатам, поскольку в выражении
перемешиваются результаты вычислений компонент тензоров выполненных в
различных базисах.

@end deffn

@deffn {Функция} petrov ()
Вычисляет классификацию Петрова для данной метрики, определяя @code{psi[0]}...@code{psi[4]}.

Например, нижеследующее показывает, как получить классификацию Петрова
для метрики Керра:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) ug:invert(lg)$
(%i5) weyl(false);
(%o5)                                done
(%i6) nptetrad(true);
(%t6) np =

       [  sqrt(r - 2 m)           sqrt(r)                                     ]
       [ ---------------   ---------------------      0             0         ]
       [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
       [                                                                      ]
       [  sqrt(r - 2 m)            sqrt(r)                                    ]
       [ ---------------  - ---------------------     0             0         ]
       [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
       [                                                                      ]
       [                                              r      %i r sin(theta)  ]
       [        0                    0             -------   ---------------  ]
       [                                           sqrt(2)       sqrt(2)      ]
       [                                                                      ]
       [                                              r       %i r sin(theta) ]
       [        0                    0             -------  - --------------- ]
       [                                           sqrt(2)        sqrt(2)     ]

                             sqrt(r)          sqrt(r - 2 m)
(%t7) npi = matrix([- ---------------------, ---------------, 0, 0],
                      sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

          sqrt(r)            sqrt(r - 2 m)
[- ---------------------, - ---------------, 0, 0],
   sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

           1               %i
[0, 0, ---------, --------------------],
       sqrt(2) r  sqrt(2) r sin(theta)

           1                 %i
[0, 0, ---------, - --------------------])
       sqrt(2) r    sqrt(2) r sin(theta)

(%o7)                                done
(%i7) psi(true);
(%t8)                              psi  = 0
                                      0

(%t9)                              psi  = 0
                                      1

                                          m
(%t10)                             psi  = --
                                      2    3
                                          r

(%t11)                             psi  = 0
                                      3

(%t12)                             psi  = 0
                                      4
(%o12)                               done
(%i12) petrov();
(%o12)                                 D

@end example

Вычисление классификации Петрова основано на алгоритме опубликованном в монографии
"Classifying geometries in general relativity: III Classification in practice"
by Pollney, Skea, and d'Inverno, Class. Quant. Grav. 17 2885-2902 (2000).
В текущем виде (по состоянию на 19 декабря 2004) код программы протестирован только для некоторых простых
случаев и может содержать ошибки.

@end deffn


@subsection Кручение и неметричность

В пакете @code{ctensor} реализованы учета
неметричности и кручения в коэффициентах связности.

Коэффициенты кручения вычисляются при помощи определенного пользователем
тензора кручения ранга (2,1) @code{tr}. Используя его, коэффициенты
кручения, @code{kt}, вычисляются по формулам:

@example

              m          m      m
       - g  tr   - g   tr   - tr   g
          im  kj    jm   ki     ij  km
kt   = -------------------------------
  ijk                 2


  k     km
kt   = g   kt
  ij         ijm

@end example

Заметим, что массив @code{kt} содержит только смешанные компоненты.

Коэффициенты неметричности вычисляются из предварительно определенного
пользователем вектора неметричности @code{nm} по следующим формулам:

@example

             k    k        km
       -nm  D  - D  nm  + g   nm  g
   k      i  j    i   j         m  ij
nmc  = ------------------------------
   ij                2

@end example

где D обозначает дельта-символ Кронекера.

Если  ключ @code{ctorsion_flag} равен @code{true}, то коэффициенты @code{kt}
выделяются из смешанных компонент связности вычисляемых функцией 
@code{christof} и запоминаются в массиве @code{mcs}. Аналогичным образом
Maxima поступает, если флаг @code{cnonmet_flag} равен @code{true}, в
этом случае из смешанных компонент связности выделяется массив @code{nmc}.

Если необходимо, функция @code{christof} вызывает функции @code{contortion}
@code{nonmetricity} для вычисления массивов @code{kt}  @code{nm}.

@deffn {Функция} contortion (@var{tr})

Вычисляет коэффициенты кручения ранга (2,1) из тензора кручения @var{tr}.

@end deffn

@deffn {Функция} nonmetricity (@var{nmс})

Вычисляет коэффициенты неметричности  ранга  (2,1) из вектора неметричности @var{nm}.

@end deffn



@subsection Вспомогательные средства

@deffn {Функция} ctransform (@var{M})
Функция, выполняющая координатное преобразование произвольной
симметричной  матрицы @var{M}. Пользователь интерактивно запрашивается
системой о функциях осуществляющих преобразование (прошлое название @code{transform}).

@end deffn

@deffn {Функция} findde (@var{A}, @var{n})

возвращает список дифференциальных уравнений, соответствующих элементам
 @var{n} -ой квадратной матрицы @var{A}. В текущем виде @var{n} может
 быть 2 или 3. @code{deindex} - список (определенный глобально) содержащий  индексы
 матрицы @var{A} соответствующие этим дифференциальным уравнениям.
Для тензора Эйнштейна (@code{ein}), представленного в форме двухмерного
 массива вычисленного по метрике данной ниже, функция @code{findde} дает
 следующую систему уравнений:


@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) dim:4;
(%o3)                                  4
(%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
(%o4)                     [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%i5) depends([a,d],x);
(%o5)                            [a(x), d(x)]
(%i6) ct_coords:[x,y,z,t];
(%o6)                            [x, y, z, t]
(%i7) cmetric();
(%o7)                                done
(%i8) einstein(false);
(%o8)                                done
(%i9) findde(ein,2);
                                            2
(%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
        x                     x x         x        x    x            x

                                                        2          2
                                                - 2 a  d , a  x + a  - a]
                                                     x      x
(%i10) deindex;
(%o10)                     [[1, 1], [2, 2], [4, 4]]

@end example


@end deffn

@deffn {Функция} cograd ()
Вычисляет ковариантный градиент скалярной функции. Пользователь может
задать имя полученному вектору, согласно процедуре проиллюстрированной
ниже в пункте @code{contragrad}.

@end deffn

@deffn {Функция} contragrad ()

Вычисляет контравариантный градиент скалярной функции. Пользователь может
задать имя полученному вектору, следуя примеру (вычисления используют
метрику Шварцшильда):
@c "vector^F2name^F*" LOOKS LIKE IT NEEDS TO BE FIXED UP, NOT SURE HOW THOUGH

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(f,r);
(%o4)                               [f(r)]
(%i5) cograd(f,g1);
(%o5)                                done
(%i6) listarray(g1);
(%o6)                            [0, f , 0, 0]
                                      r
(%i7) contragrad(f,g2);
(%o7)                                done
(%i8) listarray(g2);
                               f  r - 2 f  m
                                r        r
(%o8)                      [0, -------------, 0, 0]
                                     r

@end example

@end deffn
@deffn {Функция} dscalar ()
вычисляет даламбертиан скалярной функции, (зависимость от переменных
должна быть определена заранее), например:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(p,r);
(%o4)                               [p(r)]
(%i5) factor(dscalar(p));
                          2
                    p    r  - 2 m p    r + 2 p  r - 2 m p
                     r r           r r        r          r
(%o5)               --------------------------------------
                                       2
                                      r
@end example

@end deffn
@deffn {Функция} checkdiv ()

вычисляет ковариантную дивергенцию смешанного тензора второго ранга
(первый индекс должен быть ковариантным). На печать выводится
n-соответствующих компонент полученного векторного поля, где 
n = @code{dim}. Если аргументом функции является  @code{g} (метрический
тензор), тогда для упрощения результата используется равенство нулю
ковариантной дивергенции тензора Эйнштейна. Результат вычислений (вектор)
запоминается в массиве с именем @code{div}.
@end deffn

@deffn {Функция} cgeodesic (@var{dis})
Функция пакета @code{ctensor} вычисляющая уравнения геодезических для
заданной метрики. Результат запоминается в массиве @code{geod[i]}. Если аргумент
 @var{dis} равен @code{true}, тогда на экране печатается результат вычислений.

@end deffn


@deffn {Функция} bdvac (@var{f})

генерирует ковариантные компоненты вакуумных уравнений поля теории
 Бранса-Дикке. Скалярное поле определено аргументом @var{f}, который задается в виде
 взятого в кавычки имени функции вместе со своими функциональными
 аргументами, например, @code{bdvac('p(x))}. Результат вычислений
 (компоненты поля ковариантного тензора 2-го ранга) запоминается в @code{bd}.

@end deffn

@deffn {Функция} invariant1 ()

генерирует полевые уравнения Эйлера-Лагранжа для инвариантной плотности
R^2. Результат запоминается в массиве @code{inv1}.

@end deffn

@deffn {Функция} invariant2 ()

*** ПОКА НЕ РЕАЛИЗОВАНО ***
генерирует смешанные полевые уравнения Эйлера-Лагранжа для инвариантной плотности
@code{ric[i,j]*uriem[i,j]}. Результат запоминается в массиве @code{inv2}.

@end deffn

@deffn {Функция} bimetric ()

*** ПОКА НЕ РЕАЛИЗОВАНО ***
генерирует полевые уравнения биметрической теории Розена.
 Результат запоминается в массиве @code{rosen}.

@end deffn

@subsection Утилиты

@deffn {Функция} diagmatrixp (@var{M})

Возвращает @code{true} если @var{M} - диагональная матрица (2-х мерный массив).

@end deffn

@deffn {Функция} symmetricp (@var{M})

Возвращает @code{true} если @var{M} - симметричная матрица (2-х мерный массив).

@end deffn

@deffn {Функция} ntermst (@var{f})
Дает пользователю возможность оценить размеры  массива компонент
 тензора @var{f}. В результате печатается список двух элементов, где
 первый элемент является списком индексов компоненты тензора, а
 второй элемент соответствует количеству слагаемых этой компоненты.
Таким способом можно быстро выявить ненулевые компоненты и оценить
 стратегию упрощения  тензора.

@end deffn

@deffn {Функция} cdisplay (@var{ten})
показывает все элементы тензора @var{ten}, в виде многомерного массива.
Тензора ранга 0 и 1, также как и другие типы переменных показываются
стандартной функцией Maxima - @code{ldisplay}. Тензоры ранга 2 печатаются в виде
двухмерной матрицы, тензоры более высокого порядка выводятся на экран как
список 2-мерных матриц. Например в следующем примере на экран выводится
результаты вычисления тензора Римана для метрики Шварцшильда:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) riemann(false);
(%o4)                                done
(%i5) cdisplay(riem);
               [ 0               0                    0            0      ]
               [                                                          ]
               [                              2                           ]
               [      3 m (r - 2 m)   m    2 m                            ]
               [ 0  - ------------- + -- - ----       0            0      ]
               [            4          3     4                            ]
               [           r          r     r                             ]
               [                                                          ]
    riem     = [                                 m (r - 2 m)              ]
        1, 1   [ 0               0               -----------       0      ]
               [                                      4                   ]
               [                                     r                    ]
               [                                                          ]
               [                                              m (r - 2 m) ]
               [ 0               0                    0       ----------- ]
               [                                                   4      ]
               [                                                  r       ]

                                [    2 m (r - 2 m)       ]
                                [ 0  -------------  0  0 ]
                                [          4             ]
                                [         r              ]
                     riem     = [                        ]
                         1, 2   [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]

                                [         m (r - 2 m)    ]
                                [ 0  0  - -----------  0 ]
                                [              4         ]
                                [             r          ]
                     riem     = [                        ]
                         1, 3   [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]

                                [            m (r - 2 m) ]
                                [ 0  0  0  - ----------- ]
                                [                 4      ]
                                [                r       ]
                     riem     = [                        ]
                         1, 4   [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]

                               [       0         0  0  0 ]
                               [                         ]
                               [       2 m               ]
                               [ - ------------  0  0  0 ]
                    riem     = [    2                    ]
                        2, 1   [   r  (r - 2 m)          ]
                               [                         ]
                               [       0         0  0  0 ]
                               [                         ]
                               [       0         0  0  0 ]

                   [     2 m                                         ]
                   [ ------------  0        0               0        ]
                   [  2                                              ]
                   [ r  (r - 2 m)                                    ]
                   [                                                 ]
                   [      0        0        0               0        ]
                   [                                                 ]
        riem     = [                         m                       ]
            2, 2   [      0        0  - ------------        0        ]
                   [                     2                           ]
                   [                    r  (r - 2 m)                 ]
                   [                                                 ]
                   [                                         m       ]
                   [      0        0        0         - ------------ ]
                   [                                     2           ]
                   [                                    r  (r - 2 m) ]

                                [ 0  0       0        0 ]
                                [                       ]
                                [            m          ]
                                [ 0  0  ------------  0 ]
                     riem     = [        2              ]
                         2, 3   [       r  (r - 2 m)    ]
                                [                       ]
                                [ 0  0       0        0 ]
                                [                       ]
                                [ 0  0       0        0 ]

                                [ 0  0  0       0       ]
                                [                       ]
                                [               m       ]
                                [ 0  0  0  ------------ ]
                     riem     = [           2           ]
                         2, 4   [          r  (r - 2 m) ]
                                [                       ]
                                [ 0  0  0       0       ]
                                [                       ]
                                [ 0  0  0       0       ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [ m          ]
                               3, 1   [ -  0  0  0 ]
                                      [ r          ]
                                      [            ]
                                      [ 0  0  0  0 ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [    m       ]
                               3, 2   [ 0  -  0  0 ]
                                      [    r       ]
                                      [            ]
                                      [ 0  0  0  0 ]

                               [   m                      ]
                               [ - -   0   0       0      ]
                               [   r                      ]
                               [                          ]
                               [        m                 ]
                               [  0   - -  0       0      ]
                    riem     = [        r                 ]
                        3, 3   [                          ]
                               [  0    0   0       0      ]
                               [                          ]
                               [              2 m - r     ]
                               [  0    0   0  ------- + 1 ]
                               [                 r        ]

                                    [ 0  0  0    0   ]
                                    [                ]
                                    [ 0  0  0    0   ]
                                    [                ]
                         riem     = [            2 m ]
                             3, 4   [ 0  0  0  - --- ]
                                    [             r  ]
                                    [                ]
                                    [ 0  0  0    0   ]

                                [       0        0  0  0 ]
                                [                        ]
                                [       0        0  0  0 ]
                                [                        ]
                     riem     = [       0        0  0  0 ]
                         4, 1   [                        ]
                                [      2                 ]
                                [ m sin (theta)          ]
                                [ -------------  0  0  0 ]
                                [       r                ]

                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                     riem     = [ 0        0        0  0 ]
                         4, 2   [                        ]
                                [         2              ]
                                [    m sin (theta)       ]
                                [ 0  -------------  0  0 ]
                                [          r             ]

                              [ 0  0          0          0 ]
                              [                            ]
                              [ 0  0          0          0 ]
                              [                            ]
                   riem     = [ 0  0          0          0 ]
                       4, 3   [                            ]
                              [                2           ]
                              [         2 m sin (theta)    ]
                              [ 0  0  - ---------------  0 ]
                              [                r           ]

                 [        2                                             ]
                 [   m sin (theta)                                      ]
                 [ - -------------         0                0         0 ]
                 [         r                                            ]
                 [                                                      ]
                 [                         2                            ]
                 [                    m sin (theta)                     ]
      riem     = [        0         - -------------         0         0 ]
          4, 4   [                          r                           ]
                 [                                                      ]
                 [                                          2           ]
                 [                                   2 m sin (theta)    ]
                 [        0                0         ---------------  0 ]
                 [                                          r           ]
                 [                                                      ]
                 [        0                0                0         0 ]

(%o5)                                done

@end example
@end deffn

@deffn {Функция} deleten (@var{L}, @var{n})
Возвращает новый список состоящий из элементов списка @var{L} с
удаленным @var{n}-ым элементом.
@end deffn

@subsection Переменные пакета ctensor

@defvr {Управляющая переменная} dim
Значение по умолчанию: 4

Опция пакета @code{ctensor} (компонентные вычисления).
Размерность многообразия, по умолчанию: 4
Команда  @code{dim: n} переопределяет размерность величине равной @code{n}.

@end defvr

@defvr {Управляющая переменная} diagmetric
Значение по умолчанию: @code{false}

Опция пакета @code{ctensor} (компонентные вычисления).
Если @code{diagmetric} равен @code{true}, тогда вычисления
всех геометрических объектов проводятся по упрощенной схеме: с учетом
диагональности метрики. Это позволяет уменьшить время счета. Данная опция
устанавливается автоматически если при вызове  @code{csetup} была задана
диагональная метрика.

@end defvr

@defvr {Управляющая переменная} ctrgsimp

Включает использование тригонометрических преобразований при упрощении
тензора. В настоящее время, @code{ctrgsimp} влияет только на результаты
вычислений, выполненные  в  тетрадном базисе.

@end defvr

@defvr {Управляющая переменная} cframe_flag

Если ключ @code{cframe_flag}  равен @code{true}, тогда вычисления проводятся
в тетрадном базисе (в общем случае с не голономной метрикой). 
Базис определяется массивом дуального фрейма  @code{fri} и метрикой базиса
 @code{lfg}. При вычислениях в декартовой тетраде  массив,
@code{lfg} должен быть единичной матрицей соответствующего размера; при
вычислениях с Лоренцевой тетрадой,  массив @code{lfg} должен иметь
соответствующую сигнатуру.

@end defvr

@defvr {Управляющая переменная} ctorsion_flag

Если @code{ctorsion_flag} равен @code{true}, тогда при вычислении
связности учитываются коэффициенты кручения @code{contortion}.
В свою очередь, коэффициенты кручения, @code{contortion}, вычисляются из
заданного пользователем тензора кручения @code{tr}.

@end defvr

@defvr {Управляющая переменная} cnonmet_flag

Если @code{cnonmet_flag} равен @code{true}, тогда при вычислении
связности учитывается неметричность @code{nonmetricity}, которая, сама
по себе,  вычисляется из заданного пользователем вектора неметричности @code{nm}.

@end defvr

@defvr {Управляющая переменная} ctayswitch

Если  ключ равен @code{true}, то при вычислениях  используются ряды Тейлора. 
В текущем состоянии  пакета, эти ряды влияют на вычисление
следующих тензоров: @code{christof}, @code{ricci},
@code{uricci}, @code{einstein}, и @code{weyl}.

@end defvr

@defvr {Управляющая переменная} ctayvar

Переменная ряда Тейлора. Она активируется при @code{ctayswitch} равном
@code{true}.

@end defvr

@defvr {Управляющая переменная} ctaypov

Максимальная ряда Тэйлора. Ее определение влияет на
вычисления только если @code{ctayswitch} равен @code{true}.

@end defvr

@defvr {Управляющая переменная} ctaypt

Центральная точка ряда Тэйлора. Ее определение влияет на
вычисления только если @code{ctayswitch} равен @code{true}.

@end defvr

@defvr {Системная переменная} gdet

Детерминант метрического тензора @code{lg}. Вычисляется функцией
@code{cmetric}, когда флаг @code{cframe_flag} равен @code{false}.

@end defvr

@defvr {Управляющая переменная} ratchristof

Включает рациональное упрощение коэффициентов связности @code{christof}.

@end defvr

@defvr {Управляющая переменная} rateinstein
Значение по умолчанию: @code{true}

Если равен @code{true} тогда проводится рациональное упрощение компонент
тензора Эйнштейна; если @code{ratfac} равен @code{true}, тогда
компоненты тензора автоматически факторизуются.

@end defvr

@defvr {Управляющая переменная} ratriemann
Значение по умолчанию: @code{true}

Один из ключей, контролирующих упрощение тензора Римана;
Если равен @code{true} тогда применяется рациональное упрощение;
если @code{ratfac} равен @code{true}, тогда
компоненты тензора автоматически факторизуются.

@end defvr

@defvr {Управляющая переменная} ratweyl
Значение по умолчанию: @code{true}

Если равен @code{true} тогда применяется рациональное упрощение тензора Вейля;
если @code{ratfac} равен @code{true}, тогда
компоненты тензора автоматически факторизуются.
@end defvr

@defvr {Переменная} lfg
Имя ковариантной метрики тетрады. По умолчанию совпадает с Лоренцевой
метрикой,  имеет сигнатуру (+,+,+,-). Используется когда @code{cframe_flag} равен @code{true}.
@end defvr

@defvr {Переменная} ufg
Имя контравариантной метрики тетрады. Вычисляется из @code{lfg}, если
вызывается функция @code{cmetric} и флаг @code{cframe_flag} равен @code{true}.
@end defvr

@defvr {Переменная} riem
Тензор Римана ранга (3,1). Вычисляется вызовом функции
@code{riemann}. Для информации о порядке следования индексов см. описание @code{riemann}.

если @code{cframe_flag} равен @code{true}, @code{riem} вычисляется по
ковариантным компонентам тензора Римана @code{lriem}.

@end defvr

@defvr {Переменная} lriem

Ковариантная версия тензора Римана. Вычисляется вызовом функции @code{lriemann}.

@end defvr

@defvr {Переменная} uriem

Контравариантная версия тензора Римана. Вычисляется вызовом функции @code{uriemann}.

@end defvr

@defvr {Переменная} ric

Смешанный тензор Риччи. Вычисляется функцией @code{ricci}.

@end defvr

@defvr {Переменная} uric

Контравариантный тензор Риччи. Вычисляется функцией @code{uricci}.

@end defvr

@defvr {Переменная} lg

Метрический тензор. Данный тензор должен (наравне с переменной
@code{dim}) определен до начала других вычислений.

@end defvr

@defvr {Переменная} ug

Обратный метрический тензор. Вычисляется функцией @code{cmetric}.

@end defvr

@defvr {Переменная} weyl

Тензор Вейля. Вычисляется функцией @code{weyl}.

@end defvr

@defvr {Переменная} fb

Коммутатор (скобка) тетрады, вычисляется функцией @code{frame_bracket}.

@end defvr

@defvr {Переменная} kinvariant

Инвариант Кретчмана. Вычисляется функцией @code{rinvariant}.

@end defvr

@defvr {Переменная} np

Нуль-тетрада Ньюмана-Пенроуза. Вычисляется функцией @code{nptetrad}.

@end defvr

@defvr {Переменная} npi

Нуль-тетрада Ньюмана-Пенроуза с поднятыми индексами; вычисляется процедурой @code{nptetrad}.
Определена посредством @code{ug.np}. Произведение
@code{np.transpose(npi)} является константой:

@example
(%i39) trigsimp(np.transpose(npi));
                              [  0   - 1  0  0 ]
                              [                ]
                              [ - 1   0   0  0 ]
(%o39)                        [                ]
                              [  0    0   0  1 ]
                              [                ]
                              [  0    0   1  0 ]
@end example

@end defvr

@defvr {Переменная} tr

Определенный пользователем тензор 3-го ранга, задающий
кручение. Используется процедурой @code{contortion}.
@end defvr

@defvr {Переменная} kt

Вклад кручения в коэффициенты связности, вычисляется из тензора кручения @code{tr} функцией @code{contortion}.
@end defvr

@defvr {Переменная} nm

Определенный пользователем  вектор неметричности. Используется функцией @code{nonmetricity}.
@end defvr

@defvr {Переменная} nmc

Вклад неметричности в связность; вычисляется из @code{nm} функцией @code{nonmetricity}.

@end defvr

@defvr {Системная переменная} tensorkill

Переменная показывающая, что пакет @code{ctensor} инициализирован. Эти
установки используются процедурой @code{csetup}, и переопределяются процедурой @code{init_ctensor}.

@end defvr

@defvr {Управляющая переменная} ct_coords
Значение по умолчанию: @code{[]}

Опция пакета @code{ctensor} (компонентные вычисления тензоров).
@code{ct_coords} содержит список имен координат. Обычно он определяется
при вызове процедуры  @code{csetup}. Список может быть переопределен
назначением нового списка
@code{ct_coords: [j1, j2, ..., jn]},  j's имена новых координат. Смотри также @code{csetup}.

@end defvr

@subsection Зарезервированные имена

Следующие имена используются функциями и процедурами пакета
@code{ctensor} (не следует их переопределять):

@example
  Name         Description
  ---------------------------------------
  _lg()        Присваивается массиву lfg если используется тетрадная
               метрика; по умолчанию присваивается  массиву lg
  _ug()        Присваивается массиву ufg если используется тетрадная
               метрика;  по умолчанию присваивается массиву ug
  cleanup()    Удаляет элементы drom списка deindex 
  contract4()  используется функцией psi()
  filemet()    используется функцией csetup() при чтении метрики из файла
  findde1()    используется функцией findde()
  findde2()    используется функцией findde()
  findde3()    используется функцией findde()
  kdelt()      дельта-символ Кронекера (необобщенный)
  newmet()     используется функцией csetup() для интерактивного
               определения метрики
  setflags()   используется функцией init_ctensor()
  readvalue()
  resimp()
  sermet()     используется функцией csetup() для ввода метрики в виде
               Тэйлоровского разложения
  txyzsum()
  tmetric()    Метрика тетрады, используется функцией cmetric(), если cframe_flag:true
  triemann()   Тензор Римана в тетрадном представлении, используется если cframe_flag:true
  tricci()     Тензор Риччи в тетрадном представлении, используется если cframe_flag:true
  trrc()       Коэффициенты вращения Риччи, используется  функцией christof()
  yesp()
@end example


@subsection Изменения

В ноябре 2004 пакет @code{ctensor} был существенно переписан. Многие
функции и переменные были переименованы для  того чтобы сделать данный
пакет совместимым с коммерческой версией  Macsyma.


@example
  New Name     Old Name        Description
  --------------------------------------------------------------------------
  ctaylor()    DLGTAYLOR()     Тэйлоровское разложение выражения
  lgeod[]      EM              Уравнения геодезических
  ein[]        G[]             Смешанный тензор Эйнштейна
  ric[]        LR[]            Смешанный тензор Риччи
  ricci()      LRICCICOM()     Вычисляет смешанный тензор Риччи
  ctaypov      MINP            Максимальная степень ряда Тэйлора
  cgeodesic()  MOTION          Вычисляет уравнения геодезических
  ct_coords    OMEGA           метрические координаты
  ctayvar      PARAM           Переменная ряда Тэйлора
  lriem[]      R[]             
  uriemann()   RAISERIEMANN()  Вычисляет контравариантный тензор Римана 
  ratriemann   RATRIEMAN       Рациональное упрощение тензора Римана
  uric[]       RICCI[]         Контравариантный тензор Риччи
  uricci()     RICCICOM()      Вычисляет контравариантный тензор Риччи
  cmetric()    SETMETRIC()     Определяет метрику
  ctaypt       TAYPT           Центральная точка окрестности ряда Тэйлора
  ctayswitch   TAYSWITCH       ключ устанавливающий использовать ли
                                ряды Тэйлора в метрике
  csetup()     TSETUP()        Вызывает начало интерактивного режима
                                задания  метрики и пр.       
  ctransform() TTRANSFORM()    Интерактивное преобразование координат
  uriem[]      UR[]            Контравариантный тензор Римана
  weyl[]       W[]             Тензор Вейля ранга (3,1)

@end example

