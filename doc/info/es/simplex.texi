@c english version 1.2
@menu
* Introducci@'on a simplex::
* Definiciones para simplex::
@end menu

@node Introducci@'on a simplex, Definiciones para simplex, simplex, simplex
@section Introducci@'on a simplex

El paquete @code{simplex} utiliza el algoritmo simplex para programci@'on lineal.

Ejemplo:

@c ===beg===
@c load("simplex")$
@c minimize_sx(x+y, [3*x+2*y>2, x+4*y>3]);
@c ===end===
@example
(%i1) load("simplex")$
(%i2) minimize_sx(x+y, [3*x+2*y>2, x+4*y>3]);
                       9        7       1
(%o2)                 [--, [y = --, x = -]]
                       10       10      5
@end example

@node Definiciones para simplex,  , Introducci@'on a simplex, simplex
@section Definiciones para simplex

@defvr {Variable opcional} epsilon_sx
Valor por defecto: @code{10^-8}

Error epsilon utilizado en los c@'alculos num@'ericos de @code{linear_program}.

V@'ease tambi@'en @code{linear_program}.

@end defvr

@deffn {Funci@'on} linear_program (@var{A}, @var{b}, @var{c})

La funci@'on @code{linear_program} es una implementaci@'on del algoritmo
simplex. La instrucci@'on @code{linear_program(A, b, c)} calcula un 
vector @var{x} tal que minimiza @code{c.x} bajo las restricciones @code{A.x = b}
y @code{x >= 0}. El argumento @var{A} es una matriz y los argumentos @var{b} y
@var{c} son listas.

La funci@'on @code{linear_program} devuelve una lista que contiene el vector
soluci@'on @var{x} y el valor m@'{@dotless{i}}nimo de @code{c.x}.
Si el problema no est@'a acotado, devuelve el mensaje "Problem not bounded!"
y si el problema no es factible, devuelve el mensaje "Problem not feasible!".

Para usar esta funci@'on, c@'arguese primero el paquete con la
instrucci@'on @code{load(simplex);}.

Ejemplo:


@c ===beg===
@c A: matrix([1,1,-1,0], [2,-3,0,-1], [4,-5,0,0])$
@c b: [1,1,6]$
@c c: [1,-2,0,0]$
@c linear_program(A, b, c);
@c ===end===
@example
(%i1) A: matrix([1,1,-1,0], [2,-3,0,-1], [4,-5,0,0])$
(%i2) b: [1,1,6]$
(%i3) c: [1,-2,0,0]$
(%i4) linear_program(A, b, c);
                     [ 1   1   - 1   0  ]
                     [                  ]
(%o4) linear_program([ 2  - 3   0   - 1 ], [1, 1, 6], 
                     [                  ]
                     [ 4  - 5   0    0  ]
                                                  [1, - 2, 0, 0])
@end example

V@'eanse tambi@'en @code{minimize_sx}, @code{scale_sx} y @code{epsilon_sx}.

@end deffn

@deffn {Funci@'on} maximize_sx (@var{obj}, @var{cond}, [@var{pos}])

Maximiza la funci@'on objetivo lineal @var{obj} sujeta a ciertas restricciones
lineales @var{cond}. V@'ease @code{minimize_sx} para una descripci@'on detallada
de los argumentos y de la respuesta dada por esta funci@'on.

@end deffn

@deffn {Funci@'on} minimize_sx (@var{obj}, @var{cond}, [@var{pos}])

Minimiza la funci@'on objetivo lineal @var{obj} sujeta a ciertas restricciones
lineales @var{cond}, siendo @'esta una lista de ecuaciones o inecuaciones lineales.
En las inecuaciones estrictas se reemplaza @code{>} por @code{>=} y @code{<}
por @code{<=}. El argumento opcional @var{pos} es una lista de variables de
decisi@'on que se suponen positivas.

Si el m@'{@dotless{i}}nimo existe, @code{minimize_sx} devuelve una lista que
contiene el valor m@'{@dotless{i}}nimo de la funci@'on objetivo y una lista 
de valores para las variables de decisi@'on con los que se alcanza el 
m@'{@dotless{i}}nimo. 
Si el problema no est@'a acotado, devuelve el mensaje "Problem not bounded!"
y si el problema no es factible, devuelve el mensaje "Problem not feasible!".

Las variables de decisi@'on no se suponen no negativas. Si todas las 
variables de decisi@'on son no negativas, as@'{@dotless{i}}gnese el valor
@code{true} a la variable @code{nonegative_sx}. Si s@'olo algunas de las
variables de decisi@'on son positivas, l@'{@dotless{i}}stense
en el argumento opcional @var{pos}, lo cual es m@'as eficiente que 
a@~nadir restricciones.

La funci@'on @code{minimize_sx} utiliza el algoritmo simplex implementado
en la funci@'on @code{linear_program} de Maxima.

Para usar esta funci@'on, c@'arguese primero el paquete con la
instrucci@'on @code{load(simplex);}.

Ejemplos:

@c ===beg===
@c minimize_sx(x+y, [3*x+y=0, x+2*y>2]);
@c minimize_sx(x+y, [3*x+y>0, x+2*y>2]), nonegative_sx=true;
@c minimize_sx(x+y, [3*x+y=0, x+2*y>2]), nonegative_sx=true;
@c minimize_sx(x+y, [3*x+y>0]);
@c ===end===
@example
(%i1) minimize_sx(x+y, [3*x+y=0, x+2*y>2]);
(%o1)    minimize_sx(y + x, [y + 3 x = 0, 2 y + x > 2])
(%i2) minimize_sx(x+y, [3*x+y>0, x+2*y>2]), nonegative_sx=true;
(%o2)    minimize_sx(y + x, [y + 3 x > 0, 2 y + x > 2])
(%i3) minimize_sx(x+y, [3*x+y=0, x+2*y>2]), nonegative_sx=true;
(%o3)    minimize_sx(y + x, [y + 3 x = 0, 2 y + x > 2])
(%i4) minimize_sx(x+y, [3*x+y>0]);
(%o4)           minimize_sx(y + x, [y + 3 x > 0])
@end example


V@'eanse tambi@'en @code{maximize_sx}, @code{nonegative_sx} y @code{epsilon_sx}.

@end deffn

@defvr {Variable opcional} nonegative_sx
Valor por defecto: @code{false}

Si @code{nonegative_sx} vale @code{true} todas las variables de decisi@'on
pasadas a @code{minimize_sx} y a @code{maximize_sx} se suponen positivas.

V@'ease tambi@'en @code{minimize_sx}.

@end defvr
