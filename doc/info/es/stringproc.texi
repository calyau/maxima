@c english version 1.2
@menu
* Introducci@'on al procesamiento de cadenas::
* Definiciones para entrada y salida::
* Definiciones para caracteres::
* Definiciones para cadenas::
@end menu

@node Introducci@'on al procesamiento de cadenas, Definiciones para entrada y salida, stringproc, stringproc
@section Introducci@'on al procesamiento de cadenas

El paquete @code{stringproc} ampl@'{@dotless{i}}a las capacidades de 
Maxima para manipular cadenas de caracteres; para cargarlo basta con
ejecutar la sentencia @code{load("stringproc")}.

En Maxima, una cadena de caracteres se construye f@'acilmente 
escribi@'endola entre comillas dobles (@code{"}). T@'engase en
cuenta que las cadenas de Maxima no son cadenas de Lisp,
pudi@'endose ejecutar las funciones de chequeo @code{stringp}
y @code{lstringp} con el fin de dilucidar qu@'e tipo de cadena
es su argumento. Si por cualquier motivo el usuario tiene una
cadena de Lisp y la quiere convertir a una cadena de Maxima habr@'a
de utilizar la funci@'on conversora @code{sunlisp}.


@c ===beg===
@c load("stringproc")$
@c m: "text";
@c [stringp(m),lstringp(m)];
@c l: sconcat("text");
@c [stringp(l),lstringp(l)];
@c stringp( sunlisp(l) );
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) m: "text";
(%o2)                         text
(%i3) [stringp(m),lstringp(m)];
(%o3)                     [true, false]
(%i4) l: sconcat("text");
(%o4)                         text
(%i5) [stringp(l),lstringp(l)];
(%o5)                     [false, true]
(%i6) stringp( sunlisp(l) );
(%o6)                         true
@end example

Todas las cadenas devueltas por las funciones de @code{stringproc} son cadenas
de Maxima. 

Los caracteres individuales se introducen como cadenas de Maxima de longitud
igual a la unidad. Estos caracteres no son caracteres de Lisp y se pueden
chequear con las funciones @code{charp} y @code{lcharp}, pudi@'endose
convertir los caracteres de Lisp a Maxima mediante @code{cunlisp}.

@c ===beg===
@c load("stringproc")$
@c c: "e";
@c [charp(c),lcharp(c)];
@c supcase(c);
@c charp(%);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) c: "e";
(%o2)                           e
(%i3) [charp(c),lcharp(c)];
(%o3)                     [true, false]
(%i4) supcase(c);
(%o4)                           E
(%i5) charp(%);
(%o5)                         true
@end example

Todos los caracteres devueltos por las funciones de @code{stringproc} son caracteres
de Maxima. Puesto que los caracteres introducidos son cadenas de longitud igual a
la unidad, se pueden utilizar las funciones de cadenas tambi@'en para los 
caracteres, como se ha hecho con @code{supcase} en el anterior ejemplo.

Es importante tener en cuenta que el primer car@'acter en una cadena de Maxima
ocupa la posici@'on 1. Esto se ha dise@~nado as@'{@dotless{i}} para mantener
la compatibilidad con las listas de Maxima. V@'eanse las definiciones de 
@code{charat} y @code{charlist} para ver ejemplos.

Las funciones de cadenas se utilizan frecuentemente cuando se trabaja con
ficheros. El paquete @code{stringproc} dispone de algunas funciones de
escritura que pueden ser @'utiles. Por ejemplo, si un fichero contiene
instrucciones de entrada y salidas de Maxima, la funci@'on @code{extracti}
extrae los valores de todas las etiquetas de entrada para un fichero que 
puede ser le@'{@dotless{i}}do por Maxima y cuya ruta es devuelta por la
funci@'on. El fichero podr@'a ser ejecutado inmediatamente con @code{batch(%)}.
N@'otese que @code{extracti} falla si al menos una de las etiquetas est@'a
da@~nada, quiz@'as debido a haber borrado @code{).}, o si algunas entradas
proced@'{@dotless{i}}an de la lectura de ficheros externos (mediante @code{batch}),
o si existen caracteres m@'as all@'a de los s@'{@dotless{i}}mbolos de terminaci@'on
de sentencia @code{;} o @code{$}.

@example
extracti(file):= block(
   [ s1: openr(file), ifile: sconc(file,".in"), line, nl: false ],
   s2: openw(ifile), 

   while ( stringp(line: readline(s1)) ) do (
      if ssearch( sconc("(",inchar),line ) = 1 then (
         line: strim(" ",substring( line,ssearch(")",line)+1 )),
         printf( s2,"~a~%",line ),
         checklast(line) )
      else if nl then (
         line: strimr(" ",line),
         printf( s2,"~a~%",line ),
         checklast(line) )),
         
   close(s1), close(s2),
   ifile)$
      
checklast(line):= block(
   [ last: charat( line,slength(line) ) ],
   if cequal(last,";") or cequal(last,"$") then 
      nl:false else nl:true )$
@end example

Contenido del fichero 'C:\home\maxima\test.out':

@example
(%i1) f(x):= sin(x)$
(%i2) diff(f(x),x);
(%o2)                               cos(x)
(%i3) df(x):= ''%;
(%o3)                           df(x) := cos(x)
(%i4) df(0);
(%o4)                                  1
@end example

Ahora desde Maxima:

@example
(%i11) extracti("C:\\home\\maxima\\test.out");
(%o11)             C:\home\maxima\test.out.in
(%i12) batch(%);

batching #pC:/home/maxima/test.out.in
(%i13)                          f(x) := sin(x)
(%i14)                           diff(f(x), x)
(%o14)                              cos(x)
(%i15)                          df(x) := cos(x)
(%o15)                          df(x) := cos(x)
(%i16)                               df(0)
(%o16)                                 1 
@end example

@node Definiciones para entrada y salida, Definiciones para caracteres, Introducci@'on al procesamiento de cadenas, stringproc
@section Definiciones para entrada y salida

Ejemplo: 

@example
(%i1) s: openw("C:\\home\\file.txt");
(%o1)                 #<output stream C:\home\file.txt>
(%i2) control: "~2tAn atom: ~20t~a~%~2tand a list: ~20t~@{~r ~@}~%~2tand an integer: ~20t~d~%"$
(%i3) printf( s,control, 'true,[1,2,3],42 )$
(%o3)                                false
(%i4) close(s);
(%o4)                                true
(%i5) s: openr("C:\\home\\file.txt");
(%o5)                 #<input stream C:\home\file.txt>
(%i6) while stringp( tmp:readline(s) ) do print(tmp)$
  An atom:          true 
  and a list:       one two three  
  and an integer:   42 
(%i7) close(s)$
@end example


@deffn {Funci@'on} close (@var{stream}) 
Cierra el flujo de datos @var{stream} y devuelve @code{true} si @var{stream} hab@'{@dotless{i}}a
sido abierto. 

@end deffn

@deffn {Funci@'on} flength (@var{stream})
Devuelve el n@'umero de elementos en el flujo de datos @var{stream}. 

@end deffn

@deffn {Funci@'on} fposition (@var{stream})
@deffnx {Funci@'on} fposition (@var{stream}, @var{pos})
Devuelve la posici@'on actual en el flujo de datos @var{stream} si no se utiliza @var{pos}.
Si se utiliza @var{pos}, @code{fposition} ajusta la posici@'on en @var{stream}. 
El argumento @var{pos} debe ser un n@'umero positivo,
ocupando el primer elemento en @var{stream} la posici@'on 1.

@end deffn

@deffn {Funci@'on} freshline () 
@deffnx {Funci@'on} freshline (@var{stream}) 
Escribe una nueva l@'{@dotless{i}}nea en el  flujo de datos @var{stream}
si la posici@'on actual no corresponde al inicio de la l@'{@dotless{i}}nea.
La funci@'on @code{freshline} no trabaja correctamente con los flujos de datos  
@code{true} y @code{false}. 

@end deffn

@deffn {Funci@'on} newline () 
@deffnx {Funci@'on} newline (@var{stream}) 
Escribe una nueva l@'{@dotless{i}}nea en el  flujo de datos  @var{stream}.
La funci@'on @code{freshline} no trabaja correctamente con los flujos de datos 
@code{true} y @code{false}.
V@'ease @code{sprint} para un ejemplo de utilizaci@'on de @code{newline}.

@end deffn

@deffn {Funci@'on} opena (@var{file}) 
Devuelve un flujo de datos al fichero @var{file}.
Si se abre un fichero ya existente, @code{opena} a@~nade elementos al final
del fichero.

@end deffn

@deffn {Funci@'on} openr (@var{file}) 
Devuelve un flujo de datos de entrada al fichero @var{file}.
Si @var{file} no existe, ser@'a creado.
@end deffn

@deffn {Funci@'on} openw (@var{file}) 
Devuelve un flujo de datos de salida al fichero @var{file}.
Si @var{file} no existe, ser@'a creado.
Si se abre un fichero ya existente, @code{openw} lo modifica 
borrando el contenido anterior.
@end deffn

@deffn {Funci@'on} printf (@var{dest}, @var{string})
@deffnx {Funci@'on} printf (@var{dest}, @var{string}, @var{expr_1}, ..., @var{expr_n})
La funci@'on @code{printf} se comporta de forma similar a la de FORMAT en Common Lisp.
V@'eanse las referencias de Lisp para m@'as informaci@'on. T@'engase en cuenta que hay
alhunas directivas que funcionan en Lisp, pero no en Maxima. Por ejemplo, @code{~:[}
falla.

La funci@'on @code{printf} ha sido dise@~nada para que @code{~s} se interprete igual que
@code{~a}. Adem@'as la directiva de selecci@'on @code{~[} se indexa a partir del cero.

@example
   ~%       nueva l@'{@dotless{i}}nea
   ~&       l@'{@dotless{i}}nea de refresco
   ~t       tabulaci@'on
   ~$       moneda
   ~d       entero en base decimal
   ~b       entero en base binaria
   ~o       entero en base octal
   ~x       entero en base hexadecimal
   ~br      entero en base b
   ~r       deletrea un entero
   ~p       plural
   ~f       decimal en coma flotante
   ~e       notaci@'on cient@'{@dotless{i}}fica
   ~g       ~f o ~e, dependiendo de la magnitud
   ~a       tal como imprime la funci@'on de Maxima @code{print}
   ~s       como ~a
   ~~       ~
   ~<       justificaci@'on, ~> termina
   ~(       conversor may@'uscula/min@'uscula, ~) termina 
   ~[       selecci@'on, ~] termina 
   ~@{       iteraci@'on, ~@} termina
@end example

@example
(%i1) printf( false, "~s ~a ~4f ~a ~@@r", 
"String",sym,bound,sqrt(8),144), bound = 1.234;
(%o1)                 String sym 1.23 2*sqrt(2) CXLIV
(%i2) printf( false,"~@{~a ~@}",["one",2,"THREE"] );
(%o2)                          one 2 THREE 
(%i3) printf( true,"~@{~@{~9,1f ~@}~%~@}",mat ),
mat = args( matrix([1.1,2,3.33],[4,5,6],[7,8.88,9]) )$
      1.1       2.0       3.3 
      4.0       5.0       6.0 
      7.0       8.9       9.0 
(%i4) control: "~:(~r~) bird~p ~[is~;are~] singing."$
(%i5) printf( false,control, n,n,if n=1 then 0 else 1 ), n=2;
(%o5)                    Two birds are singing.
@end example

Si @var{dest} es un flujo de datos o @code{true}, entonces @code{printf}
devuelve @code{false}. En otro caso, @code{printf} devuelve una cadena
con la salida.
@end deffn

@deffn {Funci@'on} readline (@var{stream}) 
Devuelve una cadena con los caracteres desde la posici@'on actual en el flujo
de datos @var{stream} hasta el final de la l@'{@dotless{i}}nea, o @code{false}
si est@'a al final del fichero.
@end deffn

@deffn {Funci@'on} sprint (@var{expr_1}, ..., @var{expr_n})
Eval@'ua y muestra sus argumentos uno tras otro en un rengl@'on comenzando en 
su extremo izquierdo. 

@example
(%i1) load("stringproc")$
(%i2) for n:0 thru 16 do sprint( fib(n) )$
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
@end example

Si se quiere un salto de l@'{@dotless{i}}nea antes de cada impresi@'on,
a@~n@'adase @code{,newline()}.

V@'ease @code{ascii} para un ejemplo.
@end deffn

@node Definiciones para caracteres, Definiciones para cadenas, Definiciones para entrada y salida, stringproc
@section Definiciones para caracteres

@deffn {Funci@'on} alphacharp (@var{char})
Devuelve @code{true} si @var{char} es una car@'acter alfab@'etico.
@end deffn

@deffn {Funci@'on} alphanumericp (@var{char}) 
Devuelve @code{true} si @var{char} es una car@'acter alfab@'etico o
un d@'{@dotless{i}}gito.
@end deffn

@deffn {Funci@'on} ascii (@var{int})
Devuelve el car@'acter correspondiente al n@'umero ASCII @var{int},
debiendo ser @math{-1 < int < 256}.

@example
(%i1) for n from 0 thru 255 do ( tmp: ascii(n),
if alphacharp(tmp) then sprint(tmp) ), newline()$
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g
h i j k l m n o p q r s t u v w x y z
@end example

@end deffn

@deffn {Funci@'on} cequal (@var{char_1}, @var{char_2})          
Devuelve @code{true} si @var{char_1} y @var{char_2} son el mismo car@'acter. 
@end deffn

@deffn {Funci@'on} cequalignore (@var{char_1}, @var{char_2})
Como @code{cequal}, pero ignora si las letras est@'an en may@'usculas o
min@'usculas.
@end deffn

@deffn {Funci@'on} cgreaterp (@var{char_1}, @var{char_2})    
Devuelve  @code{true} si el n@'umero ASCII de @var{char_1} es mayor que el 
de @var{char_2}. 
@end deffn

@deffn {Funci@'on} cgreaterpignore (@var{char_1}, @var{char_2})
Como @code{cgreaterp}, pero ignora si las letras est@'an en may@'usculas o
min@'usculas.
@end deffn

@deffn {Funci@'on} charp (@var{obj})
Devuelve @code{true} si @var{obj} es un car@'acter de Maxima.
@end deffn

@deffn {Funci@'on} cint (@var{char}) 
Devuelve el n@'umero ASCII de @var{char}.
@end deffn

@deffn {Funci@'on} clessp (@var{char_1}, @var{char_2})
Devuelve  @code{true} si el n@'umero ASCII de @var{char_1} es menor que el 
de @var{char_2}.  
@end deffn

@deffn {Funci@'on} clesspignore (@var{char_1}, @var{char_2})
Como @code{clessp}, pero ignora si las letras est@'an en may@'usculas o
min@'usculas.
@end deffn

@deffn {Funci@'on} constituent (@var{char})
Devuelve @code{true} si @var{char} es un car@'acter gr@'afico y no el
car@'acter espacio. Un car@'acter gr@'afico es el que se puede ver y con un
espacio a@~nadido; @code{constituent} est@'a definido por Paul Graham,
ANSI Common Lisp, 1996, page 67.


@example
(%i1) for n from 0 thru 255 do ( tmp: ascii(n),
if constituent(tmp) then sprint(tmp) ), newline()$
! " #  %  ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @@ A B
C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c
d e f g h i j k l m n o p q r s t u v w x y z @{ | @} ~
@end example

@end deffn

@deffn {Funci@'on} cunlisp (@var{lisp_char}) 
Convierte un car@'acter Lisp en uno de Maxima. El uso de esta funci@'on por
parte del usuario no ser@'a necesario.
@end deffn

@deffn {Funci@'on} digitcharp (@var{char})    
Devuelve @code{true} si @var{char} es un d@'{@dotless{i}}gito. 
@end deffn

@deffn {Funci@'on} lcharp (@var{obj}) 
Devuelve @code{true} si @var{obj} es un car@'acter de Lisp.
El uso de esta funci@'on por parte del usuario no ser@'a necesario.
@end deffn

@deffn {Funci@'on} lowercasep (@var{char})  
Devuelve  @code{true} si @var{char} es un car@'acter en min@'uscula.
@end deffn

@defvr {Variable} newline 
El car@'acter de nueva l@'{@dotless{i}}nea. 
@end defvr

@defvr {Variable} space   
El car@'acter de espacio.
@end defvr

@defvr {Variable} tab     
El car@'acter de tabulaci@'on.
@end defvr

@deffn {Funci@'on} uppercasep (@var{char})  
Devuelve @code{true} si @var{char} es un car@'acter en may@'uscula.
@end deffn

@node Definiciones para cadenas,  , Definiciones para caracteres, stringproc
@section Definiciones para cadenas

@deffn {Funci@'on} sunlisp (@var{lisp_string}) 
Convierte una cadena Lisp en una de Maxima. 
El uso de esta funci@'on por parte del usuario no ser@'a necesario.
@end deffn

@deffn {Funci@'on} lstringp (@var{obj}) 
Devuelve @code{true} si @var{obj} es una cadena de Lisp.
El uso de esta funci@'on por parte del usuario no ser@'a necesario.
@end deffn

@deffn {Funci@'on} stringp (@var{obj}) 
Devuelve @code{true} si @var{obj} es una cadena de Maxima.
V@'ease un ejemplo en la introducci@'on.
@end deffn

@deffn {Funci@'on} charat (@var{string}, @var{n})
Devuelve el @var{n}-@'esimo car@'acter de @var{string}.
Al primer car@'acter de @var{string} le corresponde @var{n} = 1.

@c ===beg===
@c load("stringproc")$
@c charat("Lisp",1);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) charat("Lisp",1);
(%o2)                           L
@end example

@end deffn

@deffn {Funci@'on} charlist (@var{string}) 
Devuelve una lista con todos los caracteres de @var{string}. 

@c ===beg===
@c load("stringproc")$
@c charlist("Lisp");
@c %[1];
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) charlist("Lisp");
(%o2)                     [L, i, s, p]
(%i3) %[1];
(%o3)                           L
@end example

@end deffn

@deffn {Funci@'on} parsetoken (@var{string})  
La funci@'on @code{parsetoken} convierte el primer lexema de @var{string}
a su forma num@'erica, devolviendo @code{false} si no se puede determinar este
n@'umero. El conjunto de delimitadores de lexemas es
@code{@{space, comma, semicolon, tab, newline@}}.

@c ===beg===
@c load("stringproc")$
@c 2*parsetoken("1.234 5.678");
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) 2*parsetoken("1.234 5.678");
(%o2)                         2.468
@end example

Tambi@'en se puede utilizar la funci@'on @code{parse_string} para
el an@'alisis sint@'actico.
@end deffn

@deffn {Funci@'on} sconc (@var{expr_1}, ..., @var{expr_n})
Eval@'ua sus argumentos y los yuxtapone para formar una cadena.
Esta funci@'on es similar a @code{sconcat}, pero devuelve una cadena
de Maxima.

@c ===beg===
@c load("stringproc")$
@c sconc("xx[",3,"]:",expand((x+y)^3));
@c stringp(%);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) sconc("xx[",3,"]:",expand((x+y)^3));
(%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
(%i3) stringp(%);
(%o3)                         true
@end example

@end deffn

@deffn {Funci@'on} scopy (@var{string}) 
Devuelve una copia nueva de la cadena @var{string}. 
@end deffn

@deffn {Funci@'on} sdowncase (@var{string}) 
@deffnx {Funci@'on} sdowncase (@var{string}, @var{start}) 
@deffnx {Funci@'on} sdowncase (@var{string}, @var{start}, @var{end}) 
Convierte caracteres en min@'uscula a may@'uscula. V@'ease tambi@'en @code{supcase}.
@end deffn

@deffn {Funci@'on} sequal (@var{string_1}, @var{string_2}) 
Devuelve @code{true} si @var{string_1} y @var{string_2} son dos cadenas de caracteres iguales. 

@end deffn

@deffn {Funci@'on} sequalignore (@var{string_1}, @var{string_2})
Igual que @code{sequal} pero no diferencia entre min@'usculas y may@'usculas.. 

@end deffn

@deffn {Funci@'on} sexplode (@var{string})
El nombre @code{sexplode} es un seud@'onimo de la funci@'on @code{charlist}.

@end deffn

@deffn {Funci@'on} simplode (@var{list})  
@deffnx {Funci@'on} simplode (@var{list}, @var{delim})  
La funci@'on @code{simplode} admite como entrada una lista de expresiones para
luego convertirla en una cadena de caracteres. Si no se utiliza la opci@'on @var{delim}
para indicar el delimitador, entonces @code{simplode} actúa como @code{sconc} y no 
hace uso de ninguno. El valor de @var{delim} puede ser cualquier cadena.

@c ===beg===
@c load("stringproc")$
@c simplode(["xx[",3,"]:",expand((x+y)^3)]);
@c simplode( sexplode("stars")," * " );
@c simplode( ["One","more","coffee."]," " );
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) simplode(["xx[",3,"]:",expand((x+y)^3)]);
(%o2)             xx[3]:y^3+3*x*y^2+3*x^2*y+x^3
(%i3) simplode( sexplode("stars")," * " );
(%o3)                   s * t * a * r * s
(%i4) simplode( ["One","more","coffee."]," " );
(%o4)                   One more coffee.
@end example

@end deffn

@deffn {Funci@'on} sinsert (@var{seq}, @var{string}, @var{pos}) 
Devuelve la concatenaci@'on de las cadenas @code{substring (@var{string}, 1, @var{pos} - 1)},
@var{seq} y @code{substring (@var{string}, @var{pos})}.
N@'otese que al primer car@'acter de @var{string} le corresponde la posici@'on 1.

@c ===beg===
@c load("stringproc")$
@c s: "A submarine."$
@c sconc( substring(s,1,3),"yellow ",substring(s,3) );
@c sinsert("hollow ",s,3);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) s: "A submarine."$
(%i3) sconc( substring(s,1,3),"yellow ",substring(s,3) );
(%o3)                  A yellow submarine.
(%i4) sinsert("hollow ",s,3);
(%o4)                  A hollow submarine.
@end example

@end deffn

@deffn {Funci@'on} sinvertcase (@var{string})  
@deffnx {Funci@'on} sinvertcase (@var{string}, @var{start})  
@deffnx {Funci@'on} sinvertcase (@var{string}, @var{start}, @var{end})  
Devuelve la misma cadena @var{string} pero con todos sus caracteres desde la
posici@'on @var{start} hasta @var{end} quedan invertidos, esto es, las
may@'usculas se convierten en min@'usculas y @'estas en may@'usculas.
Si no se incluye el argumento @var{end}, se invierten todos los caracteres 
desde @var{start} hasta el final de la cadena.


@c ===beg===
@c load("stringproc")$
@c sinvertcase("sInvertCase");
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) sinvertcase("sInvertCase");
(%o2)                      SiNVERTcASE
@end example

@end deffn

@deffn {Funci@'on} slength (@var{string}) 
Devuelve el n@'umero de caracteres de @var{string}. 

@end deffn

@deffn {Funci@'on} smake (@var{num}, @var{char}) 
Construye una cadena de longitud @var{num} con todos sus
caracteres iguales a @var{char}. 

@c ===beg===
@c load("stringproc")$
@c smake(3,"w");
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) smake(3,"w");
(%o2)                          www
@end example

@end deffn

@deffn {Funci@'on} smismatch (@var{string_1}, @var{string_2}) 
@deffnx {Funci@'on} smismatch (@var{string_1}, @var{string_2}, @var{test}) 
Devuelve la posici@'on del primer car@'acter de @var{string_1} distinto del
correpondiente a @var{string_2}. La respuesta ser@'a @code{false} si no existe
tal car@'acter. Por defecto, la funci@'on de comparaci@'on es @code{sequal}.
Si se quiere ignorar la diferencia entre may@'usculas y min@'usculas, h@'agase uso de 
@code{sequalignore} para el argumento @var{test}.

@c ===beg===
@c load("stringproc")$
@c smismatch("seven","seventh");
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) smismatch("seven","seventh");
(%o2)                           6
@end example

@end deffn

@deffn {Funci@'on} split (@var{string})  
@deffnx {Funci@'on} split (@var{string}, @var{delim})  
@deffnx {Funci@'on} split (@var{string}, @var{delim}, @var{multiple}) 
Devuelve la lista de todos los lexemas (@i{tokens}) de @var{string}.
La funci@'on @code{split} utiliza @var{delim} como delimitador, y en caso
de no ser utilizado este argumento, ser@'a utilizado el espacio en blanco
como delimitador por defecto. El argumento @var{multiple} es una variable
booleana con valor @code{true} por defecto. Los delimitadores m@'ultiples 
se leen como uno solo, lo que resulta de utilidad si las tabulaciones son 
almacenadas como secuencias de espacios en blanco. Si a @var{multiple} se 
le asigna el valor @code{false}, se consirarar@'an todos los delimitadores.

@c ===beg===
@c load("stringproc")$
@c split("1.2   2.3   3.4   4.5");
@c split("first;;third;fourth",";",false);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) split("1.2   2.3   3.4   4.5");
(%o2)                 [1.2, 2.3, 3.4, 4.5]
(%i3) split("first;;third;fourth",";",false);
(%o3)               [first, , third, fourth]
@end example

@end deffn

@deffn {Funci@'on} sposition (@var{char}, @var{string}) 
Devuelve la posici@'on del primer car@'acter de @var{string} que
coincide con @var{char}. Al primer car@'acter de @var{string}
le corresponde la posici@'on 1.
Para cuando se quiera ignorar la diferencia entre may@'usculas y 
min@'usculas, v@'ease @var{ssearch}.
@end deffn

@deffn {Funci@'on} sremove (@var{seq}, @var{string})  
@deffnx {Funci@'on} sremove (@var{seq}, @var{string}, @var{test})  
@deffnx {Funci@'on} sremove (@var{seq}, @var{string}, @var{test}, @var{start})  
@deffnx {Funci@'on} sremove (@var{seq}, @var{string}, @var{test}, @var{start}, @var{end})
Devuelve la cadena @var{string} pero sin las subcadenas que coinciden con @var{seq}.
La funci@'on de comparaci@'on por defecto es @code{sequal}.
Si se quiere ignorar la diferencia entre may@'usculas y min@'usculas, h@'agase uso de 
@code{sequalignore} para el argumento @var{test}.
Util@'{@dotless{i}}cense @var{start} y @var{end} para acotar la b@'usqueda.
Al primer car@'acter de @var{string} le corresponde la posici@'on 1.

@c ===beg===
@c load("stringproc")$
@c sremove("n't","I don't like coffee.");
@c sremove ("DO ",%,'sequalignore);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) sremove("n't","I don't like coffee.");
(%o2)                   I do like coffee.
(%i3) sremove ("DO ",%,'sequalignore);
(%o3)                    I like coffee.
@end example

@end deffn

@deffn {Funci@'on} sremovefirst (@var{seq}, @var{string})  
@deffnx {Funci@'on} sremovefirst (@var{seq}, @var{string}, @var{test})  
@deffnx {Funci@'on} sremovefirst (@var{seq}, @var{string}, @var{test}, @var{start})  
@deffnx {Funci@'on} sremovefirst (@var{seq}, @var{string}, @var{test}, @var{start}, @var{end})  
Act@'ua de forma similar a la funci@'on @code{sremove}, pero s@'olo elimina
la primera aparici@'on de la subcadena @code{seq}.

@end deffn

@deffn {Funci@'on} sreverse (@var{string}) 
Devuelve una cadena con todos los caracteres de @var{string} en orden inverso.

@end deffn

@deffn {Funci@'on} ssearch (@var{seq}, @var{string})  
@deffnx {Funci@'on} ssearch (@var{seq}, @var{string}, @var{test})  
@deffnx {Funci@'on} ssearch (@var{seq}, @var{string}, @var{test}, @var{start})  
@deffnx {Funci@'on} ssearch (@var{seq}, @var{string}, @var{test}, @var{start}, @var{end})
Devuelve la posici@'on de la primera subcadena de @var{string} que coincide con
la cadena @var{seq}.
La funci@'on de comparaci@'on por defecto es @code{sequal}.
Si se quiere ignorar la diferencia entre may@'usculas y min@'usculas, h@'agase uso de 
@code{sequalignore} para el argumento @var{test}.
Util@'{@dotless{i}}cense @var{start} y @var{end} para acotar la b@'usqueda.
Al primer car@'acter de @var{string} le corresponde la posici@'on 1.

@example
(%i1) ssearch("~s","~@{~S ~@}~%",'sequalignore);
(%o1)                                  4
@end example

@end deffn

@deffn {Funci@'on} ssort (@var{string}) 
@deffnx {Funci@'on} ssort (@var{string}, @var{test}) 
Devuelve una cadena con todos los caracteres de @var{string} en un orden
tal que no haya dos caracteres sucesivos @var{c} y @var{d} que verifiquen
que @code{test (@var{c}, @var{d})} sea igual @code{false} y 
@code{test (@var{d}, @var{c})} igual a @code{true}.
La funci@'on de comparaci@'on @var{test} por defecto es  @var{clessp}, siendo
el conjunto de posibles valores para este argumento 
@code{@{clessp, clesspignore, cgreaterp, cgreaterpignore, cequal, cequalignore@}}.

@c ===beg===
@c load("stringproc")$
@c ssort("I don't like Mondays.");
@c ssort("I don't like Mondays.",'cgreaterpignore);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) ssort("I don't like Mondays.");
(%o2)                    '.IMaddeiklnnoosty
(%i3) ssort("I don't like Mondays.",'cgreaterpignore);
(%o3)                 ytsoonnMlkIiedda.'   
@end example

@end deffn

@deffn {Funci@'on} ssubst (@var{new}, @var{old}, @var{string}) 
@deffnx {Funci@'on} ssubst (@var{new}, @var{old}, @var{string}, @var{test}) 
@deffnx {Funci@'on} ssubst (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}) 
@deffnx {Funci@'on} ssubst (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}, @var{end}) 
Devuelve una cadena similar a @var{string} pero en la que aquellas subcadenas 
coincidentes con @var{old} han sido sustituidas por @var{new}. Las subcadenas
@var{old} y @var{new} no necesitan ser de la misma longitud. 
La funci@'on de comparaci@'on por defecto es @code{sequal}.
Si se quiere ignorar la diferencia entre may@'usculas y min@'usculas durante
la b@'usqueda de @var{old}, h@'agase uso de 
@code{sequalignore} para el argumento @var{test}.
Util@'{@dotless{i}}cense @var{start} y @var{end} para acotar la b@'usqueda.
Al primer car@'acter de @var{string} le corresponde la posici@'on 1.

@c ===beg===
@c load("stringproc")$
@c ssubst("like","hate","I hate Thai food. I hate green tea.");
@c ssubst("Indian","thai",%,'sequalignore,8,12);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) ssubst("like","hate","I hate Thai food. I hate green tea.");
(%o2)          I like Thai food. I like green tea.
(%i3) ssubst("Indian","thai",%,'sequalignore,8,12);
(%o3)         I like Indian food. I like green tea.
@end example

@end deffn

@deffn {Funci@'on} ssubstfirst (@var{new}, @var{old}, @var{string}) 
@deffnx {Funci@'on} ssubstfirst (@var{new}, @var{old}, @var{string}, @var{test}) 
@deffnx {Funci@'on} ssubstfirst (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}) 
@deffnx {Funci@'on} ssubstfirst (@var{new}, @var{old}, @var{string}, @var{test}, @var{start}, @var{end}) 
Act@'ua de forma similar a la funci@'on @code{subst}, pero s@'olo hace
la sustituci@'on en la primera coincidencia con @var{old}. 
@end deffn

@deffn {Funci@'on} strim (@var{seq},@var{string}) 
Devuelve la cadena @var{string} pero recortando los caracteres
de @var{seq} que tuviese en sus extremos.

@c ===beg===
@c load("stringproc")$
@c "/* comment */"$
@c strim(" /*",%);
@c slength(%);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) "/* comment */"$
(%i3) strim(" /*",%);
(%o3)                        comment
(%i4) slength(%);
(%o4)                           7
@end example

@end deffn

@deffn {Funci@'on} striml (@var{seq}, @var{string}) 
Act@'ua de forma similar a @code{strim}, pero s@'olo recorta
en el extremo final de @var{string}.
@end deffn

@deffn {Funci@'on} strimr (@var{seq}, @var{string}) 
Act@'ua de forma similar a @code{strim}, pero s@'olo recorta
en el extremo inicial de @var{string}.
@end deffn

@deffn {Funci@'on} substring (@var{string}, @var{start})
@deffnx {Funci@'on} substring (@var{string}, @var{start}, @var{end}) 
Devuelve la subcadena de @var{string} que comienza en la posici@'on
@var{start} y termina en la posici@'on @var{end}.
El car@'acter en la posici@'on @var{end} no se incluye.
En caso de no suministrarse el argumento @var{end}, la subcadena
se extender@'a hasta el final. 
Al primer car@'acter de @var{string} le corresponde la posici@'on 1.

@c ===beg===
@c load("stringproc")$
@c substring("substring",4);
@c substring(%,4,6);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) substring("substring",4);
(%o2)                        string
(%i3) substring(%,4,6);
(%o3)                          in
@end example

@end deffn

@deffn {Funci@'on} supcase (@var{string}) 
@deffnx {Funci@'on} supcase (@var{string}, @var{start}) 
@deffnx {Funci@'on} supcase (@var{string}, @var{start}, @var{end}) 
Devuelve la cadena @var{string} con todos sus caracteres entre las posiciones
@var{start} y @var{end} en min@'uscula transformados a may@'uscula.
En caso de no suministrarse el argumento @var{end}, los cambios
se extender@'an hasta el final.

@c ===beg===
@c load("stringproc")$
@c supcase("english",1,2);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) supcase("english",1,2);
(%o2)                        English
@end example

@end deffn

@deffn {Funci@'on} tokens (@var{string}) 
@deffnx {Funci@'on} tokens (@var{string}, @var{test}) 
Devuelve la lista de todos los lexemas (@i{tokens}) de @var{string}.
Los lexemas son subcadenas cuyos caracteres satisfacen la  condici@'on @var{test}.
Si no se suministra el argumento @var{test}, se utilizar@'a la condici@'on
@var{constituent}, siendo el conjunto de las otras alternativas
@code{@{constituent, alphacharp, digitcharp, lowercasep, uppercasep, charp, characterp, alphanumericp@}}.

@c ===beg===
@c load("stringproc")$
@c tokens("24 October 2005");
@c tokens("05-10-24",'digitcharp);
@c map(parsetoken,%);
@c ===end===
@example
(%i1) load("stringproc")$
(%i2) tokens("24 October 2005");
(%o2)                  [24, October, 2005]
(%i3) tokens("05-10-24",'digitcharp);
(%o3)                     [05, 10, 24]
(%i4) map(parsetoken,%);
(%o4)                      [5, 10, 24]
@end example

@end deffn
